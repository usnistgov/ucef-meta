/*

Generated by PluginGenerator 0.14.0 from webgme
on Wed Dec 02 2015 15:06:02 GMT-0600 (CST).

Modified by T. Kramer 

Reformatted in C style, as far as possible.

*/

define
([
  'text!./metadata.json',
  'plugin/PluginBase',
  'common/util/ejs',
  'C2Core/xmljsonconverter',
  'C2Core/ModelTraverserMixin',
  'DeploymentExporter/Templates/Templates',
  'FederatesExporter/RTIVisitors',
  'FederatesExporter/PubSubVisitors',
  'combinatorics/combinatorics',
  'q',
  'superagent'],
 function(pluginMetadata,
	  PluginBase,
	  ejs,
	  JSON2XMLConverter,
	  ModelTraverserMixin,
	  TEMPLATES,
	  RTIVisitors,
	  PubSubVisitors,
	  combinations,
	  Q,
	  superagent)
{
    'use strict';
    var objectTraverser;            // function variable
    var objectTraverserCheck;       // function variable
    var objectTraverserXml;         // function variable
    var interactionTraverser;       // function variable
    var interactionTraverserCheck;  // function variable
    var interactionTraverserXml;    // function variable
    
    pluginMetadata = JSON.parse(pluginMetadata);
    /**
     * Initializes a new instance of DeploymentExporter.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin DeploymentExporter.
     * @constructor
     */
    var DeploymentExporter = function()
    {
      this.pubSubInteractions = {};
      this.pubSubObjects = {};
      PluginBase.call(this);
      ModelTraverserMixin.call(this);
      PubSubVisitors.call(this);
      RTIVisitors.call(this);

      this._jsonToXml = new JSON2XMLConverter.Json2xml();
      this.pluginMetadata = pluginMetadata;
    };

    // Prototypal inheritance from PluginBase.
    DeploymentExporter.prototype = Object.create(PluginBase.prototype);
    DeploymentExporter.prototype.constructor = DeploymentExporter;
    DeploymentExporter.metadata = pluginMetadata;

/***********************************************************************/

/* objectTraverser

Returned Value: fed file text for the object and its descendants

Called By:
  anonyomous fed fom generator in DeploymentExporter.prototype.main
  objectTraverser (recursively)

*/
    objectTraverser = function(object)
    {
      var objModel = {name: object.name,
                      attributes: object.attributes,
                      children: []};
      object.children.forEach(function(child)
      {
        objModel.children.push(objectTraverser(child));
      });
      return ejs.render(TEMPLATES["fedfile_simobject.ejs"], objModel);
    };
    
/***********************************************************************/

/* objectTraverserCheck

Returned Value: none

Called By:
  anonyomous fom generator in DeploymentExporter.prototype.main
  objectTraverserCheck (recursively)

This adds entries to pubSubObjects for all ancestors of objects that
already have entries.

By calling itself recursively, this goes through the object tree (from
top down) but builds the pubSubObjectss from bottom up. If an object is
on the pubSubObjects but its parent is not, an entry for the parent
of the object is added to the pubSubObjects; the entry represents that
the parent neither publishes or subscribes. If the parent publishes or
subscribes, an entry for the parent will have been made previously in
PubSubVisitors.

The final effect is that any object that is an ancestor of any object
originally put on the pubSubObjects in PubSubVisitors is also on
pubSubObjects.

*/
    objectTraverserCheck = function(depEx, object)
    {
      var objectPubSub;
      var parentPubSub;

      object.children.forEach(function (child)
      {
        objectTraverserCheck(depEx, child);
      });
      if ((object.name != 'ObjectRoot') &&
	  (object.id in depEx.pubSubObjects))
        {
	  objectPubSub = depEx.pubSubObjects[object.id];
          if ((object.basePath in depEx.pubSubObjects))
            {
	      parentPubSub = depEx.pubSubObjects[object.basePath];
	      if (objectPubSub.mayPublish)
		{
		  parentPubSub.mayPublish = 1;
		}
	      if (objectPubSub.maySubscribe)
		{
		  parentPubSub.maySubscribe = 1;
		}
	    }
	  else
	    {
              depEx.pubSubObjects[object.basePath] =
                {publish: 0,
                 subscribe: 0,
		 mayPublish: objectPubSub.mayPublish,
		 maySubscribe: objectPubSub.maySubscribe};
            }
        }
    };
    
/***********************************************************************/

/* objectTraverserXml

Returned Value: a string of XML representing the object and its descendants

Called By:
  anonyomous fom generator in DeploymentExporter.prototype.main
  objectTraverserXml (recursively)

This builds the XML for objects.

The objectTraverserXml is a recursive function that takes an object
that may have children (also objects) and builds an objModel from
it. The objModel is given the same name and attributes as the object
and is given children that are XML code built by a recursive call to
itself on the children of the object.

Then XML for the objModel is generated (and saved) by calling
ejs.render using the fedfile_simobject_xml XML Template.

*/

    objectTraverserXml = function(depEx, object, space)
    {
      var objModel;
      var objPuBSub;
      var hasOwn;

      objModel = {name: object.name,
                  sharingXml: 0,
                  indent: space,
		  attributes: object.attributes,
		  children: []};

      hasOwn = 0;
      // The attributes in the objModel are the attributes of the object.
      // Properites of attributes not related to XML generation are not
      // modified, but properties of attributes related to XML generation
      // are assigned as follows.
      objModel.attributes.forEach(function(attr)
      {
        attr.deliveryXml = ((attr.delivery === "reliable") ? "HLAreliable" :
                            "HLAbestEffort");
        attr.orderXml = ((attr.order === "timestamp") ? "TimeStamp" :
                         "Receive");
	if (!attr.inherited)
	  {
	    hasOwn = 1;
	  }
      });

      objPuBSub = depEx.pubSubObjects[object.id];
      if (objPuBSub && (objPuBSub.publish ||
			(objPuBSub.mayPublish && hasOwn)))
        {
          if (objPuBSub.subscribe || objPuBSub.maySubscribe)
            {
              objModel.sharingXml = "PublishSubscribe";
            }
          else
            {
              objModel.sharingXml = "Publish";
            }
        }
      else if (objPuBSub && (objPuBSub.subscribe ||
			     (objPuBSub.maySubscribe && hasOwn)))
        {
          objModel.sharingXml = "Subscribe";
        }
      else
        {
          objModel.sharingXml = "Neither";
        }

      // Here, objectTraverserXml calls itself recursively to
      // generate XML for the children before generating
      // XML for the parent.
      // We do not want to include the FederateObject.
      object.children.forEach(function(child)
      {
        if ((child.name != "FederateObject") &&
            (child.id in depEx.pubSubObjects))
          {
            objModel.children.push
              (objectTraverserXml(depEx, child, space + "    "));
          }
      });
      // now generate XML for the parent if on pubSubObjects
      if (object.id in depEx.pubSubObjects)
        {
          return ejs.render(TEMPLATES["fedfile_simobject_xml.ejs"],
                            objModel);
        }
    };

/***********************************************************************/

/* interactionTraverser

Returned Value: fed file text for the interaction and its descendants

Called By:
  anonyomous fed fom generator in DeploymentExporter.prototype.main
  interactionTraverser (recursively)

*/
    interactionTraverser = function(interaction)
    {
      var intModel = {interaction: interaction,
                      parameters: interaction.parameters,
                      children: []};
      interaction.children.forEach(function(child)
      {
        intModel.children.push(interactionTraverser(child));
      });
      return ejs.render(TEMPLATES["fedfile_siminteraction.ejs"], intModel);
    };

/***********************************************************************/

/* interactionTraverserCheck

Returned Value: none

Called By:
  anonyomous fom generator in DeploymentExporter.prototype.main
  interactionTraverserCheck (recursively)

This adds entries to pubSubInteractions for all ancestors of interactions
that already have entries.

By calling itself recursively, this goes through the interaction tree
(from top down) but builds the pubSubInteractions from bottom up. If
an interaction is on the pubSubInteractions but its parent is not, an
entry for the parent of the interaction is added to the
pubSubInteractions; the entry represents that the parent neither
publishes or subscribes. If the parent publishes or subscribes, an
entry for the parent will have been made previously in PubSubVisitors.

The final effect is that any interaction that is an ancestor of any
interaction originally put on the pubSubInteractions in PubSubVisitors
is also on pubSubInteractions.

*/
    interactionTraverserCheck = function(depEx, interaction)
    {
      interaction.children.forEach(function (child)
      {
        interactionTraverserCheck(depEx, child);
      });
      if (interaction.name != 'InteractionRoot')
        {
          if ((interaction.id in depEx.pubSubInteractions) &&
              !(interaction.basePath in depEx.pubSubInteractions))
            {
              depEx.pubSubInteractions[interaction.basePath] =
                {publish: 0,
                 subscribe: 0};
            }
        }
    };

/***********************************************************************/

/* interactionTraverserXml

Returned Value: a string of XML representing the interaction and its
                descendants

Called By:
  anonyomous fom generator in DeploymentExporter.prototype.main
  interactionTraverserXml (recursively)

This builds the XML for interactions.

*/
    interactionTraverserXml = function(depEx, interaction, space)
    {
      var intModel = {name: interaction.name,
                      sharingXml: 0,
                      deliveryXml: 0,
                      orderXml: 0,
                      indent: space,
                      parameters: interaction.parameters,
                      children: []};
      var intPubSub;
      intPubSub = depEx.pubSubInteractions[interaction.id];
      if (intPubSub && intPubSub.publish)
        {
          if (intPubSub.subscribe)
            {
              intModel.sharingXml = "PublishSubscribe";
            }
          else
            {
              intModel.sharingXml = "Publish";
            }
        }
      else if (intPubSub && intPubSub.subscribe)
        {
          intModel.sharingXml = "Subscribe";
        }
      else
        {
          intModel.sharingXml = "Neither";
        }
      if (interaction.delivery === "reliable")
        {
          intModel.deliveryXml = "HLAreliable";
        }
      else
        {
          interaction.deliveryXml = "HLAbestEffort";
        }
      if (interaction.order === "timestamp")
        {
          intModel.orderXml = "TimeStamp";
        }
      else
        {
          intModel.orderXml = "Receive";
        }
      // here interactionTraverserXml calls itself recursively to
      // generate XML for the children before generating
      // XML for the parent
      interaction.children.forEach(function(child)
      {
        if (child.id in depEx.pubSubInteractions)
          {
            intModel.children.push
              (interactionTraverserXml(depEx, child, space + "    "));
          }
      });
      
      // now generate XML for the parent if on pubSubInteractions
      if (interaction.id in depEx.pubSubInteractions)
        {
          return ejs.render(TEMPLATES["fedfile_siminteraction_xml.ejs"],
                            intModel);
        }
    };

/***********************************************************************/

/* DeploymentExporter.prototype.main

Returned Value: none

Called By: ?

This is the main function for the plugin to execute. This will perform
the execution.

Notes:
  - Do NOT put any user interaction logic UI, etc. inside this method.
  - callback always has to be called even if error happened.

    @param {function(string, plugin.PluginResult)} callback -
    the result callback
*/

    DeploymentExporter.prototype.main = function(callback)
    {
      // Use self to access core, project, result, logger etc from PluginBase.
      // These are all instantiated at this point.
      var self = this,
          generateFiles,           // function
          numberOfFilesToGenerate, // counter used in generateFiles function
          finishExport,            // function
          pomModel = {};
      var today = new Date();
      var year = today.getFullYear();
      var month = today.getMonth();
      var day = today.getDate();

      self.workingDir="/home/ubuntu/file-server";

      self.fileGenerators = [];
      self.fom_sheets = {};
      self.federates = [];
      self.interactions = {};
      self.interactionRoots = [];
      self.objects = {};
      self.objectRoots = [];
      self.attributes = {};

      // Experiment Related
      self.experimentModelConfig = [ [] ];
      self.experimentPaths = [];

      // COA related
      self.coaNodes = [];
      self.coaEdges = [];
      self.coaPaths = {};
      self.coaPathNode = {};
      self.coaPathEdge = {};

      // COAS related
      self.coasNode = [ [] ];
      self.coasPath = [];

      // COA Sequence
      self.coaSequenceGroup = [ [] ];
      self.coaGroupNodes = [];

      self.experimentsGuid = [ [] ];

      self.projectName = self.core.getAttribute(self.rootNode, 'name');
      self.bindAddress = self.getCurrentConfig().bindAddress.trim();

      pomModel.projectName = self.projectName;
      pomModel.groupId = self.getCurrentConfig().groupId.trim();
      pomModel.projectVersion =
        self.getCurrentConfig().exportVersion.trim() +
        (self.getCurrentConfig().isRelease ? "" : "-SNAPSHOT");
      pomModel.cpswtVersion = self.getCurrentConfig().cpswtVersion;
      pomModel.repositoryUrlSnapshot =
        self.getCurrentConfig().repositoryUrlSnapshot;
      pomModel.repositoryUrlRelease =
        self.getCurrentConfig().repositoryUrlRelease;
      pomModel.federates = self.federates;

      pomModel.porticoPOM = {};
      pomModel.porticoPOM.artifactId = "portico";
      pomModel.porticoPOM.groupId = "org.porticoproject";
      pomModel.porticoPOM.version = self.getCurrentConfig().porticoReleaseNum;
      pomModel.porticoPOM.scope = "provided";

      self.runningOnClient = false;

      if (typeof WebGMEGlobal !== 'undefined')
        {
          self.runningOnClient = true;
          var errMsg =
            'This plugin is only supported to run on the server side!';
          self.logger.error(errMsg);
          return callback(errMsg );
        }

/***********************************************************************/

/* anonymous function

This anonymous function adds the POM generator to the file
generators. 

The function does not return anything.

*/

      self.fileGenerators.push(function(artifact, callback)
      {
        pomModel['federatesByType'] = {};
        pomModel.federates.forEach(function(fed)
        {
          if (!pomModel['federatesByType'][fed.FederateType])
            {
              pomModel['federatesByType'][fed.FederateType] = [];
            }
          pomModel['federatesByType'][fed.FederateType].push(fed);
        });

        artifact.addFile('pom.xml',
                         ejs.render(TEMPLATES['execution_pom.xml.ejs'],
                                    pomModel),
                         function(err)
                         {
                           if (err)
                             {
                               callback(err);
                               return;
                             }
                           else
                             {
                               callback();
                             }
                         });
      });

/***********************************************************************/

/* anonymous function

This anonymous function adds the fed FOM generator to the file
generators.  Processing the objectRoot(s) and the interactionRoot(s)
processes all objects and interactions.  There is normally only one
objectRoot and one interactionRoot.

The function does not return anything.

*/
      
      self.fileGenerators.push(function(artifact, callback)
      {
        var fomModelFed =
          {federationname: self.projectName,
           version: self.getCurrentConfig().exportVersion.trim(),
           pocOrg: self.getCurrentConfig().groupId.trim(),
           objects: [],
           interactions: []};

        self.interactionRoots[0].children.forEach(function(inta)
        {
          fomModelFed.interactions.push(interactionTraverser(inta));
        });
        self.objectRoots[0].children.forEach(function(obj)
        {
          fomModelFed.objects.push(objectTraverser(obj));
        });

        artifact.addFile('fom/' + self.projectName + '.fed',
                         ejs.render(TEMPLATES['fedfile.fed.ejs'], fomModelFed),
                         function(err)
                         {
                           if (err)
                             {
                               callback(err);
                               return;
                             }
                           else
                             {
                               callback();
                             }
                         });
      });

/***********************************************************************/

/* anonymous function

This anonymous function adds the XML FOM generator to the file
generators.  Processing the objectRoot(s) and the interactionRoot(s)
processes all objects and interactions.  There is normally only one
objectRoot and one interactionRoot.

The function does not return anything.

*/
      
      self.fileGenerators.push(function(artifact, callback)
      {
        var today = new Date();
        var year = today.getFullYear();
        var month = today.getMonth();
        var day = today.getDate();
        var fomModelXml =
          {federationname: self.projectName,
           version: self.getCurrentConfig().exportVersion.trim(),
           pocOrg: self.getCurrentConfig().groupId.trim(),
           dateString: (year + "-" +
                        ((month < 10) ? "0" : "") + month + "-" +
                        ((day < 10) ? "0" : "") + day),
           objectsXml: [],
           interactionsXml: []};
        self.interactionRoots.forEach(function (interactionRoot)
        {
          interactionTraverserCheck(self, interactionRoot);
          fomModelXml.interactionsXml.push
            (interactionTraverserXml(self, interactionRoot, "    "));
        });
        self.objectRoots.forEach(function(objectRoot)
        {
          objectTraverserCheck(self, objectRoot);
          fomModelXml.objectsXml.push
            (objectTraverserXml(self, objectRoot, "    "));
        });
        // add fom XML to artifact
        artifact.addFile('fom/' + self.projectName + '.xml',
                         ejs.render(TEMPLATES['fedfile.xml.ejs'],
                                    fomModelXml),
                         function(err)
                         {
                           if (err)
                             {
                               callback(err);
                               return;
                             }
                           else
                             {
                               callback();
                             }
                         });
           
      });

/***********************************************************************/
        //////////////////////
        /// COA Groups
        //////////////////////

      self.fileGenerators.push(function(artifact, callback)
      {
        var saveObj = {COAs: {}};
        self.coasPath.forEach(function(obj)
        {
          if (!saveObj.COAs.hasOwnProperty(obj))
            {
              saveObj.COAs[obj] = {nodes: [],
                                   edges: []};
            }
          self.coasNode[obj].forEach(function(nodes)
          {
            if (self.coaPathNode.hasOwnProperty(nodes))
              {
                var tempNode = {};
                tempNode = self.coaPathNode[nodes];
                if (tempNode.nodeType === "Outcome" ||
                    tempNode.nodeType === "Action")
                  {
                    tempNode.interactionName =
                      self.interactions[tempNode.interactionName].fullName;
                  }
                saveObj.COAs[obj].nodes.push(tempNode);
              }
            else if (self.coaPathEdge.hasOwnProperty(nodes))
              {
                self.coaPathEdge[nodes].fromNode =
                  self.coaPaths[self.coaPathEdge[nodes].fromNode];
                self.coaPathEdge[nodes].toNode =
                  self.coaPaths[self.coaPathEdge[nodes].toNode];
                saveObj.COAs[obj].edges.push(self.coaPathEdge[nodes]);
              }
          });
        });

        artifact.addFile('conf/' + 'NewcoaConfig.json',
                         JSON.stringify(saveObj.COAs, null, 2),
                         function(err)
                         {
                           if (err)
                             {
                               callback(err);
                               return;
                             }
                           else
                             {
                               callback();
                             }
                         });
      }); // closes self.fileGenerators.push(function(artifact, callback)

/***********************************************************************/
    

      //////////////////
      // New Experiment Config
      /////////////////
      self.fileGenerators.push(function(artifact, callback)
      {
        var response = [];

        if (self.experimentPaths.length != 0)
          {
            self.experimentPaths.forEach(function(objPath)
            {
              var experimentmodel =
                {name: "",
                 exptConfig: {'federateTypesAllowed': [],
                              'expectedFederates': [],
                              'lateJoinerFederates': [],
                              "coaDefinition": 'conf/' + 'NewcoaConfig.json',
                              'coaSelection': '',
                              "terminateOnCOAFinish": false,
                              "COASelectionToExecute":""}
                };
              var experimentmodelcoaselection = {};

              if (self.experimentsGuid.hasOwnProperty(objPath))
                {
                  var coa_selection_name = [];
                  var required_coa_selection_name = [];
                  var coa_selection_nodes = [ [] ];
                  var coa_group_comb = [ [] ];

                  self.experimentsGuid[objPath].forEach(function(coagroup)
                  {
                    var array = {SelectionName: "",
                                 SelectionID: "",
                                 coaNodes: []};

                    coa_selection_name = [];
                    self.coaGroupNodes[coagroup.guid].forEach(function(coanode)
                    {
                      coa_selection_name.push(coanode.name);
                      coa_selection_nodes[coanode.name] =
                        coa_selection_nodes[coanode.name] || [];
                      coa_selection_nodes[coanode.name].push(
                                        {Name: coanode.name,
                                         ID: coanode.guid});
                    });                            
                    var cmb, a;
                    cmb = combinations.combination(coa_selection_name,
                                                   coagroup.NumCOAsToSelect);
                    while (a = cmb.next())
                      {
                        var estr = a.toString();
                        estr = estr.replace(/,/g, "-");
                        coa_group_comb[coagroup.guid] =
                          coa_group_comb[coagroup.guid] || [];
                        coa_group_comb[coagroup.guid].push(estr);
                      }
                  });
                    
                  var cartesianproductarray = [ [] ];
                  self.experimentsGuid[objPath].forEach(function(coagroup)
                  {
                    cartesianproductarray.push(coa_group_comb[coagroup.guid]);
                  });

                  cartesianproductarray.shift(1);
                  var cp;
                  cp = combinations.cartesianProduct.apply
                    (this, cartesianproductarray);
                  var cp_array = cp.toArray();
                  cp_array.forEach(function(a)
                  {
                    var bstr = a.toString();
                    bstr = bstr.replace(/,/g, "-");
                    experimentmodelcoaselection[bstr] =
                      experimentmodelcoaselection[bstr] || [];
                    a.forEach(function(element)
                    {
                      element.split("-").forEach(function(ele)
                      {
                        experimentmodelcoaselection[bstr].push
                          (coa_selection_nodes[ele]);
                      });
                    });
                  });
                } //closes if (self.experimentPaths.length != 0)
              
              self.experimentModelConfig[objPath].forEach(function(expSet)
              {
                var reference_name =
                  self.core.getAttribute(expSet, "name").split("-")[0];
                experimentmodel.name =
                  self.core.getAttribute(self.core.getParent(expSet), "name");
                experimentmodel.exptConfig.federateTypesAllowed.push
                  (reference_name);
                if (!self.core.getAttribute(expSet, "isLateJoiner"))
                  {
                    experimentmodel.exptConfig.expectedFederates.push(
                          {"federateType": reference_name,
                           "count": self.core.getAttribute(expSet, "count")});
                  }
                else
                  {
                    experimentmodel.exptConfig.lateJoinerFederates.push(
                          {"federateType": reference_name,
                           "count": self.core.getAttribute(expSet, "count")});
                  }
              });
              
              experimentmodel.exptConfig.coaSelection =
                'conf/' + experimentmodel.name.toLowerCase() +
                '/coaSelection_' + experimentmodel.name.toLowerCase() +
                '.json';
              // This will be the coaselection for the experiment
              artifact.addFile('conf/' + experimentmodel.name.toLowerCase() +
                               '/coaSelection_' +
                               experimentmodel.name.toLowerCase() +
                               '.json',
                               JSON.stringify
                               (experimentmodelcoaselection, null, 2),
                               function(err)
                               {
                                 response.push(err);
                                 if (response.length ==
                                     self.experimentPaths.length)
                                   {
                                     if (response.indexOf(err) == -1)
                                       {
                                         callback(err);
                                       }
                                     else
                                       {
                                         callback();
                                       }
                                   }
                               });
              experimentmodel.exptConfig.COASelectionToExecute =
                Object.keys(experimentmodelcoaselection)[0];
              artifact.addFile('conf/' + experimentmodel.name.toLowerCase() +
                               "/"+ experimentmodel.name.toLowerCase() +
                               '.json',
                               JSON.stringify
                               (experimentmodel.exptConfig, null, 2),
                               function(err)
                               {
                                 response.push(err);
                                 if (response.length ==
                                     self.experimentPaths.length)
                                   {
                                     if (response.indexOf(err) == -1)
                                       {
                                         callback(err);
                                       }
                                     else
                                       {
                                         callback();
                                       }
                                   }
                               });
            }); // closes self.experimentPaths.forEach(function(objPath)
          }
        else
          {
            callback();
          }
      }); // closes self.fileGenerators.push(function(artifact, callback)

/***********************************************************************/

      // Generating the Docker Compose for each experiment type:

      self.fileGenerators.push(function(artifact, callback)
      {
        var timestamp = (new Date()).getTime();

        self.getDockerDetails(function(err, DockerDetails)
        {
          if (err)
            {
              callback(err, self.result);
              return;
            }
          self.inputPrefix = DockerDetails.DIR + '/input/';
          self.outputPrefix = DockerDetails.DIR + '/output/';           
          self.dockerInfoMap =
            {'JavaFederate': {'name': DockerDetails.Java,
                              'profile':"ExecJava"},
             'CppFederate': {'name': DockerDetails.CPP,
                             'profile':"CppFed"},
             'FedManager': {'name': DockerDetails.FedMgr,
                            'profile':"ExecJava"}
            };
          var response = [];
          
          if (self.experimentPaths.length != 0)
            {
              self.experimentPaths.forEach(function (objPath)
              {
                var experimentmodel =
                  {name: "",
                   exptConfig: {'federateTypesAllowed': []}};
                var experimentmodelcoaselection = {};
                self.experimentModelConfig[objPath].forEach(function(expSet)
                {
                  //  This is the reference name or the experiment name
                  var reference_name =
                    self.core.getAttribute(expSet, "name").split("-")[0];
                  
                  experimentmodel.name =
                    self.core.getAttribute(self.core.getParent(expSet),
                                           "name");
                  var temp =
                    self.federates.filter(function(key)
                    {
                      if (key["name"] == reference_name)
                        {
                          return(key["FederateType"]);
                        }
                    });
                  var DockerImageType = temp[0].FederateType;
                  experimentmodel.exptConfig.federateTypesAllowed.push
                    ({name:reference_name,
                      type: DockerImageType,
                      count :self.core.getAttribute(expSet, "count")});
                });

                self.dockerFileData =
                  ejs.render(TEMPLATES['dockerFileTemplate.ejs'],
                             {cpswtng_archiva_ip: DockerDetails.cpswtng_archiva,
                              inputPrefix: self.inputPrefix,
                              outputPrefix: self.outputPrefix,
                              fedInfos: experimentmodel.exptConfig.
                                 federateTypesAllowed,
                              dockerInfoMap: self.dockerInfoMap});

                experimentmodel.exptConfig.COASelectionToExecute =
                  Object.keys(experimentmodelcoaselection)[0];  
                artifact.addFile('conf/' +
                                 experimentmodel.name.toLowerCase() +
                                 "/"+ "docker-compose.yml",
                                 self.dockerFileData,
                                 function(err)
                                 {
                                   response.push(err);
                                   if (response.length ==
                                       self.experimentPaths.length)
                                     {
                                       if (response.indexOf(err) == -1)
                                         {
                                           callback(err);
                                         }
                                       else
                                         {
                                           callback();
                                         }
                                     }
                                 });
                
                artifact.addFile('conf/' +
                                 experimentmodel.name.toLowerCase() +
                                 "/"+ "start.sh",
                                 ejs.render(TEMPLATES['startScript.ejs'], {}),
                                 function(err)
                                 {
                                   response.push(err);
                                   if (response.length ==
                                       self.experimentPaths.length)
                                     {
                                       if (response.indexOf(err) == -1)
                                         {
                                           callback(err);
                                         }
                                       else
                                         {
                                           callback();
                                         }
                                     }
                                 });
                
		artifact.addFile('conf/' +
				 experimentmodel.name.toLowerCase() +
				 "/"+ "federatelist.txt",
				 ejs.render(TEMPLATES['federatelist.ejs'],
					    {
					    cpswtng_archiva_ip:
					      DockerDetails.cpswtng_archiva,
					    inputPrefix: self.inputPrefix,
					    outputPrefix: self.outputPrefix,
					    fedInfos:
					      experimentmodel.exptConfig.
						federateTypesAllowed,
					    dockerInfoMap: self.dockerInfoMap}
					    ),
				 function(err)
				 {
				   response.push(err)
				     if (response.length ==
					 self.experimentPaths.length)
				       {
					 if (response.indexOf(err) == -1)
					   {
					     callback(err);
					   }
					 else
					   {
					     callback();
					   }
				       }
				 });
	      }); // closes self.experimentPaths.forEach(function (objPath)
            }
	  else
	    {
	      callback();
            }
	}); // closes self.getDockerDetails(function(err, DockerDetails)
      }); // closes self.fileGenerators.push(function(artifact, callback)

/***********************************************************************/

    // list of experiments.json
      self.fileGenerators.push(function(artifact, callback)
      {
	var experimentlist = [];
        if (self.experimentPaths.length != 0)
	  {
	    self.experimentPaths.forEach(function(objPath)
	    {
	      self.experimentModelConfig[objPath].forEach(function(expSet)
	      {
		if (experimentlist.indexOf(self.core.
		      getAttribute(self.core.getParent(expSet), "name") )== -1)
		  {
		    experimentlist.push(self.
		      core.getAttribute(self.core.getParent(expSet), "name"));
		  }
	      });
	    });
	  }

	artifact.addFile('conf/' + 'experimentlist.json',
			 JSON.stringify(experimentlist, null, 2),
			 function(err)
			 {
			   if (err)
			     {
			       callback(err);
			       return;
			     }
			   else
			     {
			       callback();
			     }
			 });
      });

/***********************************************************************/

      //Add default RID file
      self.fileGenerators.push(function(artifact, callback)
      {
	artifact.addFile('RTI.rid',
			 ejs.render(TEMPLATES['rti.rid.ejs'], self),
			 function(err)
			 {
			   if (err)
			     {
			       callback(err);
			       return;
			     }
			   else
			     {
			       callback();
			     }
			 });
      });

/***********************************************************************/

      //Add impl log config from template
      self.fileGenerators.push(function(artifact, callback)
      {
	var java_implLog = {};
	java_implLog.projectName = self.projectName;
	artifact.addFile('conf/' + 'log4j2.xml',
			 ejs.render(TEMPLATES['log4j2.xml.ejs'],
				    self),
			 function(err)
			 {
			   if (err)
			     {
			       callback(err);
			       return;
			     }
			   else
			     {
			       callback();
			     }
			 });
      });

/***********************************************************************/

      self.experimentModel = {'script': {'federateTypesAllowed': [],
					 'expectedFederates': [],
				 	 'lateJoinerFederates': []}};
      // Experiment Config    
      self.fileGenerators.push(function(artifact, callback)
      {
	self.federates.forEach(function(fed)
	{
	  self.experimentModel.script.federateTypesAllowed.push(fed.name);
	  self.experimentModel.script.expectedFederates.push(
						 {"federateType": fed.name,
						  "count": 1});
	  self.experimentModel.script.lateJoinerFederates.push(
						 {"federateType": fed.name,
						  "count": 0});
	});
	artifact.addFile('conf/default/' + 'experimentConfig.json',
			 JSON.stringify(self.experimentModel.script, null, 2),
			 function(err)
			 {
			   if (err)
			     {
			       callback(err);
			       return;
			     }
			   else
			     {
			       callback();
			     }
			 });
      });

/***********************************************************************/

      self.fileGenerators.push(function(artifact, callback)
      {
        if (self.experimentPaths.length != 0)
	  {
            var federateConfigurations = [];
	    // each element is one configuration file to generate

            var federateLookup = {};
	    // to speed up access to federate attributes
	    
            self.federates.forEach(function(federate)
	    {
	      federateLookup[federate.name] = federate;
            });

            self.experimentPaths.forEach(function(experimentPath)
	    {
                self.experimentModelConfig[experimentPath].
		  forEach(function(federateReference)
		  {
                    var experimentName =
		      self.core.getAttribute(self.core.
					     getParent(federateReference),
					     "name");
		    // this is wrong (and also how it's been done everywhere)
		    // because a user can change the name field
                    // this should use self.core.getPointerPath on 'ref' to
		    // get the pointer to the federate node
                    // however, I have no idea how to get the WebGME node
		    // from its string path
                    var federateType =
		      self.core.getAttribute(federateReference, "name").
		      split("-")[0];

                    var federateJsonObject =
		      {"federateRTIInitWaitTimeMs": 200,
                       "federateType": federateType,
		       "federationId": self.projectName,
		       "isLateJoiner": self.core.getAttribute(
					 federateReference, "isLateJoiner"),
		       "lookAhead": federateLookup[federateType].Lookahead,
		       "stepSize": federateLookup[federateType].Step};

                    // filePath needs work because if an experiment is
		    // called 'default' I assume it breaks terribly
                    var federateConfiguration =
		      {"jsonObject": federateJsonObject,
                       "filePath": "conf/" + experimentName.toLowerCase() +
		       "/" + federateType.toLowerCase() + ".json"};
                    federateConfigurations.push(federateConfiguration);
		  });
            }); //closes self.experimentPaths.forEach(function(experimentPath)

            var response = [];
            federateConfigurations.forEach(function(configuration)
	    {
	      artifact.addFile(configuration.filePath,
			       JSON.stringify(configuration.jsonObject,
					      null, 2),
			       function(err)
			       {
				 response.push(err);
				 if (response.length ==
				     federateConfigurations.length)
				   {
				     if (response.indexOf(err) == -1)
				       {
					 callback(err);
				       }
				     else
				       {
					 callback();
				       }
				   }
			       });
            });
	  } // closes if (self.experimentPaths.length != 0)
	else
	  {
            callback();
	  }
      });

/***********************************************************************/

      // Federate Config JSON
      self.fileGenerators.push(function(artifact, callback)
      {
        var FederateJsonModel = {"federateRTIInitWaitTimeMs": 200,
				 "federateType": "",
				 "federationId": self.projectName,
				 "isLateJoiner": false,
				 "lookAhead": 0.1,
				 "stepSize": 1.0};
        var response = [];
        self.federates.forEach(function(fed)
	{
	  FederateJsonModel.lookAhead = fed.Lookahead;
	  FederateJsonModel.stepSize = fed.Step;
	  FederateJsonModel.federateType = fed.name;
	  artifact.addFile('conf/default/' + fed.name.toLowerCase() + '.json',
			   JSON.stringify(FederateJsonModel, null, 2),
			   function(err)
			   {
			     response.push(err);
			     if (response.length == self.federates.length)
			       {
				 if (response.indexOf(err) == -1)
				   {
				     callback(err);
				   }
				 else
				   {
				     callback();
				   }
			       }
			   });
        });
      });

/***********************************************************************/

      // Add fedmgrconfig.json 
      self.fileGenerators.push(function(artifact, callback)
      {
        var fedmgrConfig =
	  {'script': {"federateRTIInitWaitTimeMs": 200,
		      "federateType": "FederationManager",
		      "federationId": self.projectName,
		      "isLateJoiner": true,
		      "lookAhead": 0.1,
		      "stepSize": 1.0,
		      "bindHost": "0.0.0.0",
		      "port": 8083,
		      "controlEndpoint": "/fedmgr",
		      "federatesEndpoint": "/federates",
		      "federationEndTime": 0.0,
		      "realTimeMode": true,
		      "fedFile": "fom/" + self.projectName + '.fed',
		      "experimentConfig":
		        "conf/default/experimentConfig.json"}};

        artifact.addFile('conf/fedmgrconfig.json',
			 JSON.stringify(fedmgrConfig.script, null, 2),
			 function(err)
			 {
			   if (err)
			     {
			       callback(err);
			       return;
			     }
			   else
			     {
			       callback();
			     }
			 });
      });

/***********************************************************************/

/* generateFiles

Returned Value: none

Called By:
  finishExport
  generateFiles (recursively)

*/
      generateFiles = function(artifact, doneBack)
      {
	if (numberOfFilesToGenerate > 0)
	  {
	    self.fileGenerators[self.fileGenerators.length -
				numberOfFilesToGenerate](artifact,
							 function(err)
                                {
                                  if (err)
                                    {
                                      callback(err, self.result);
                                      return;
                                    }
                                  numberOfFilesToGenerate--;
                                  if (numberOfFilesToGenerate > 0)
                                    {
                                      generateFiles(artifact, doneBack);
                                    }
                                  else
                                    {
                                      doneBack();
                                    }
                                });
	  }
	else
	  {
	    doneBack();
	  }
      };

/***********************************************************************/

/* finishExport

Returned Value: ?

Called By: DeploymentExporter.Prototype.main (near the end)

This is awful. Would be good to decompose it.

When this function executes in Chrome (so that
"if (self.runningOnClient)" evaluates to true), the line marked "error
here" causes an error three times in require.js the first time the
DeploymentExporter is run (however, the exporting succeeds). If the
DeploymentExporter is run again there is no error. There are 8 local
versions of require.js in cpswt-meta/node_modules, but the error
message that may be downloaded says the error is at
http://127.0.0.1:8088/common/lib/require.js/require.js/1738:36.
http://127.0.0.1:8088 is not reachable in a browser.

*/
      finishExport = function(err)
      {
        if (err)
	  {
            self.logger.error(err);
            return callback(err, self.result);
	  }

        var path;
        var filendir;
        var fs;
	
        if (self.runningOnClient)
	  {
	    require(['path'], function(path) {});
            require(['filendir'], function(filendir) {});
            require(['fs'], function(fs) {}); // error here
	  }
        else
	  {
            path = require('path');
            filendir = require('filendir');
            fs  = require('fs');
	  }

        var artifact = self.blobClient.
	               createArtifact(self.projectName.trim().
				      replace(/\s+/g, '_') + '_deployment');

        numberOfFilesToGenerate = self.fileGenerators.length;
        if (numberOfFilesToGenerate > 0)
	  {
            generateFiles(artifact, function(err)
	    {
	      if (err)
		{
		  callback(err, self.result);
		  return;
                }
                    
	      self.blobClient.saveAllArtifacts(function(err, hashes)
	      {
		if (err)
		  {
		    callback(err, self.result);
		    return;
		  }
		if (!self.runningOnClient)
		  {
		    for (var idx = 0; idx < hashes.length; idx++)
		      {
                        self.blobClient.getObject(hashes[idx],
						  function(err, content)
			  {
                            if (err )
			      {
                                self.logger.error(
			      'Failed obtaining desert configuration, err: ' +
			       err.toString());
                                return callback(
			      'Failed obtaining desert configuration, err: ' +
			       err.toString());
			      }
                            // Set up directories and file-paths.
                            
                            self.getUserDir(function(err, filestoreDir)
			    {
			      if (err)
				{
				  callback(err, self.result);
				  return;
                                }
			      self.workingDir = filestoreDir;
			      self.getUserIdAsync(function(err, userInfo)
			      {
				if (err)
				  {
                                    callback(err, self.result);
                                    return;
				  }

                                var userDir =
				  path.normalize(path.join(self.workingDir,
							   userInfo));
                                var projectDir = self.project.projectName;
                                var projectPath = path.join(userDir,
							    projectDir); 
                                var runDir = path.normalize(projectPath);
                                if (!fs.existsSync(userDir))
				  {
                                    self.logger.info('Directory"' +
						     userDir +
						     '"does not exist');
                                    fs.mkdirSync(userDir);
                                    self.logger.
				      info('Created directory for "' +
					   userDir + '".' );
				  }
                                if (!fs.existsSync(runDir))
				  {
				    self.logger.info('Directory"' +
						     runDir +
						     '"does not exist' );
                                    fs.mkdirSync(runDir);
                                    self.logger.
				      info('Created directory for "' +
					   runDir + '".' );
				  }
                                var inputZip =
				  path.normalize(path.join(runDir,
							   "deployer.zip"));
                                fs.writeFile(inputZip, content, function(err)
				{
				  var cmd;
				  if (err)
				    {
				      self.logger.
					error('Failed writing out ZIP, err: ' +
					      err.toString());
				      return callback(
					      'Failed writing out ZIP, err: ' +
					      err.toString());
                                    }
				  self.logger.info('Created input XML at ' +
						   inputZip);
				  const unzip = require('unzip');
				  fs.createReadStream(inputZip).
				    pipe(unzip.Extract({path: runDir}));
				});
                                var userProjectJSON =
                                  path.join(userDir,'UserProjects.json');
                                if (!fs.existsSync(userProjectJSON))
				  { // the file does not exist locally
                                    var obj = {};
                                    obj[self.project.projectName] =
                                       self.project.projectName
                                    let data = JSON.stringify(obj, null, 2);
                                    fs.writeFile(userProjectJSON, data,
					    (err) => {if (err) throw err;});
				  }
                                else
				  { // The file does exist locally
                                    fs.readFile(userProjectJSON, 'utf8',
						function(err, data)
                                      {
                                        if (err) throw err;
                                        var obj = JSON.parse(data);
                                        
                                        if (!(obj.hasOwnProperty(self.project.
							       projectName)))
					  {
                                            obj[self.project.projectName] =
					      self.project.projectName;
                                            let data =
					      JSON.stringify(obj, null, 2);
                                            fs.writeFile(userProjectJSON, data,
					       (err) => {if (err) throw err;});
					  }
                                        else
					  {

					  }
				      });
				  }    
			      }); // closes self.getUserIdAsync(function(...)
                            }); // closes self.getUserDir(function(...)
			  }); // closes self.blobClient.getObject(...)
		      }; // closes for (var idx = 0; ...)
		  } // closes if (!self.runningOnClient)   
                    // Next save all the artifacts to a directory location:
                       
                    // This will add a download hyperlink in the result-dialog.
		for (var idx = 0; idx < hashes.length; idx++)
		  {
		    self.result.addArtifact(hashes[idx]);

		    var artifactMsg = 'Deployment package ' +
		      self.blobClient.artifacts[idx].name +
		      ' was generated with id:[' + hashes[idx] + ']';
		    var buildURL = "'http://c2w-cdi.isis.vanderbilt.edu:8080/job/c2w-pull/buildWithParameters?GME_ARTIFACT_ID=" + hashes[idx] + "'";
		    artifactMsg += '<br><a title="Build package..." ' +
		      'onclick="window.open(' + buildURL +
		      ', \'Build System\'); return false;">Build artifact..</a>';
                        self.createMessage(null, artifactMsg);
		  };
		// This will save the changes. If you don't want to save;
		// exclude self.save and call callback directly from this scope.
		self.save('DeploymentExporter updated model.', function(err)
			  {
			    if (err)
			      {
				callback(err, self.result);
				return;
			      } 
			    self.result.setSuccess(true);
			    callback(null, self.result);
			  });
	      }); //closes self.blobClient.saveAllArtifacts(...)
            }); // closes generateFiles(...)
	  }//closes if (numberOfFilesToGenerate > 0)
	else
	  {
            self.result.setSuccess(true);
            callback(null, self.result);
	  }
      }; // closes finishExport = function(...)

/***********************************************************************/

/*

This is a call to the visitAllChildrenFromRootContainer function (!) which
is defined in ModelTraverserMixin.js. The anonymous function is the second
argument. It is not clear why the block under "if (err)" differs from
the corresponding block in the FederatesExporter, which calls callback
but does not return it.

*/
      
      self.visitAllChildrenFromRootContainer(self.rootNode, function(err)
      {
        if (err)
	  {
            self.logger.error(err);
            return callback(err, self.result);
	  }
        finishExport(err);
      });

/***********************************************************************/
    
    } // end of DeploymentExporter.Prototype.main

/***********************************************************************/
    
    DeploymentExporter.prototype.getDockerDetails = function(callback)
    {
      var deferred,
      req;

      deferred = Q.defer();
      req = superagent.get(this.blobClient.origin +
                           '/api/componentSettings/DockerDetails');
      if (typeof this.blobClient.webgmeToken === 'string')
        {
          // running on the server; set the token.
          req.set('Authorization', 'Bearer ' + this.blobClient.webgmeToken);
        }
      else
        {
          //running inside browser; cookie will be used at request..
        }
      
      req.end(function(err, res)
      {
        if (err)
          {
            deferred.reject(err);
          }
        else
          {
            deferred.resolve(res.body);
          }
      });
      return deferred.promise.nodeify(callback);
    };

/***********************************************************************/

    DeploymentExporter.prototype.getUserDir = function(callback)
    {
      var deferred,
          req;
      
      deferred = Q.defer();
      req = superagent.get(this.blobClient.origin +
			   '/api/componentSettings/UserDir');
      if (typeof this.blobClient.webgmeToken === 'string')
	{
	  // running on the server; set the token.
	  req.set('Authorization', 'Bearer ' + this.blobClient.webgmeToken);
        }
      else
	{
	  // running inside the browser; cookie will be used at the request..
        }
      req.end(function(err, res)
      {
	if (err)
	  {
	    deferred.reject(err);
	  }
	else
	  {
	    deferred.resolve(res.body.folder);
	  }
      });
      return deferred.promise.nodeify(callback);
    };

/***********************************************************************/

    DeploymentExporter.prototype.getUserIdAsync = function(callback)
    {
      var deferred,
          req;

      if (typeof this.project.userName === 'string')
	{ // Running from bin script	  
	  return Q(this.project.userName).nodeify(callback);
        }
      if (this.gmeConfig.authentication.enable === false)
	{
	  return Q(this.gmeConfig.authentication.guestAccount).
	           nodeify(callback);
        }
      deferred = Q.defer();
      req = superagent.get(this.blobClient.origin + '/api/user');
      if (typeof this.blobClient.webgmeToken === 'string')
	{ // running on the server; set the token.
	  req.set('Authorization', 'Bearer ' + this.blobClient.webgmeToken);
        }
      else
	{
            // running inside the browser; cookie will be used at the request..
        }
      req.end(function(err, res)
      {
	if (err)
	  {
	    deferred.reject(err);
	  }
	else
	  {
	    deferred.resolve(res.body._id);
	  }
      });
      
      return deferred.promise.nodeify(callback);
    };

/***********************************************************************/
    
    DeploymentExporter.prototype.visit_FederateExecution =
      function(node, parent, context)
    {
      var self = this;

      if (self.experimentPaths.indexOf(self.core.getGuid(parent)) === -1)
	{
	  self.experimentPaths.push(self.core.getGuid(parent));
	}
      self.experimentModelConfig[self.core.getGuid(parent)] =
        self.experimentModelConfig[self.core.getGuid(parent)] || [];
      self.experimentModelConfig[self.core.getGuid(parent)].push(node);
      return {context: context};
    };

/***********************************************************************/
    
    /////////////////////////
    // COA Sequence Visitors
    /////////////////////////
    DeploymentExporter.prototype.visit_COARef = function(node, parent, context)
    {
      var self = this,
          obj = {};

      self.core.loadPointer(node, "ref", function(err, result)
      {
        if (err)
	  {
	  }
	else
	  {
            obj.guid = self.core.getGuid(result);
            obj.name = self.core.getAttribute(result, "name");
            self.coaGroupNodes[self.core.getGuid(parent)] =
	      self.coaGroupNodes[self.core.getGuid(parent)] || [];
            self.coaGroupNodes[self.core.getGuid(parent)].push(obj);
	  }
      });
      return {context: context};
    };

/***********************************************************************/
    
    DeploymentExporter.prototype.visit_COASequencesGroup =
      function(node, parent, context)
    {
      var self = this,
          obj = {};

      obj.guid = self.core.getGuid(node);
      obj.name = self.core.getAttribute(node, "name");
      obj.SelectAllCOAsInEachRun =
        self.core.getAttribute(node, "SelectAllCOAsInEachRun");
      obj.NumCOAsToSelect = self.core.getAttribute(node, "NumCOAsToSelect");
      obj.experiment = self.core.getAttribute(parent, "name");
      self.coaSequenceGroup[obj.guid] = self.coaSequenceGroup[obj.guid] || [];
      self.coaSequenceGroup[obj.guid] = obj;

      var parentGuid = self.core.getGuid(parent);

      self.experimentsGuid[parentGuid] = self.experimentsGuid[parentGuid] || [];
      self.experimentsGuid[parentGuid].push(obj);
      return {context: context};
    };

/***********************************************************************/
    
/* COA node visitors

TK comment: Because of automatic semicolon insertion, the if statement
does nothing, and the line after the if statement always executes.
It is not clear whether this is an error.

*/
    
    DeploymentExporter.prototype.visit_COA = function(node, parent, context)
    {
      var self = this,
          obj = {};

      self.coasNode[self.core.getAttribute(node, "name")] =
        self.coasNode[self.core.getAttribute(node, "name")] || [];
      self.core.getChildrenPaths(node).forEach(function(path)
      {
        self.coasNode[self.core.getAttribute(node, "name")].push(path);
      });
      if (!self.coasPath[self.core.getAttribute(node, "name")])
        self.coasPath.push(self.core.getAttribute(node, "name"))

    return {context: context};
};

/***********************************************************************/

    DeploymentExporter.prototype.addCoaNode = function(node, obj)
    {
      var self = this;

      obj.name = self.core.getAttribute(node, 'name');
      obj.nodeType = self.core.getAttribute(self.getMetaType(node), 'name');
      obj.ID = self.core.getGuid(node);
      self.coaNodes.push(obj);
      self.coaPaths[self.core.getPath(node)] = self.core.getGuid(node);
      self.coaPathNode[self.core.getPath(node)] = obj;
    };

/***********************************************************************/
    
    DeploymentExporter.prototype.visit_Action = function(node, parent, context)
    {
      var self = this,
          obj = {interactionName: self.core.getPointerPath(node, "ref")},
          paramValues = self.core.getAttribute(node, 'ParamValues');

      paramValues.split(" ").forEach(function(param)
      {
	try {obj[param.split('=')[0]] = param.split('=')[1].split('"')[1];}
	catch (err)
          {
	    self.logger.debug('Erroneous param ' + param);
	  }
      });

      self.addCoaNode(node, obj);
      return {context: context};
    };

/***********************************************************************/

    DeploymentExporter.prototype.visit_Fork = function(node, parent, context)
    {
      var self = this,
          obj = {isDecisionPoint:
	           self.core.getAttribute(node, 'isDecisionPoint')};

      self.addCoaNode(node, obj);
      return {context: context};
    };

/***********************************************************************/

    DeploymentExporter.prototype.visit_ProbabilisticChoice =
      function(node, parent, context)
    {
      var self = this,
          obj = {isDecisionPoint:
		   self.core.getAttribute(node, 'isDecisionPoint')};

      self.addCoaNode(node, obj);
      return {context: context};
    };

/***********************************************************************/

    DeploymentExporter.prototype.visit_SyncPoint =
      function(node, parent, context)
    {
      var self = this,
          obj = {time: self.core.getAttribute(node, 'time'),
		 minBranchesToSync:
		   self.core.getAttribute(node, 'minBranchesToSync')};

      self.addCoaNode(node, obj);
      return {context: context};
    };

/***********************************************************************/
    
    DeploymentExporter.prototype.visit_Dur =
      function(node, parent, context)
    {
      var self = this,
          obj = {time: self.core.getAttribute(node, 'time')};

      self.addCoaNode(node, obj);
      return {context: context};
    };

/***********************************************************************/
    
    DeploymentExporter.prototype.visit_RandomDur =
      function(node, parent, context)
    {
      var self = this,
          obj = {lowerBound: self.core.getAttribute(node, 'lowerBound'),
		 upperBound: self.core.getAttribute(node, 'upperBound')};

      self.addCoaNode(node, obj);
      return {context: context};
    };

/***********************************************************************/

    DeploymentExporter.prototype.visit_AwaitN =
      function(node, parent, context)
    {
      var self = this,
          obj = {minBranchesToAwait:
		 self.core.getAttribute(node, 'minBranchesToAwait')};

      self.addCoaNode(node, obj);
      return {context: context};
    };

/***********************************************************************/

    DeploymentExporter.prototype.visit_Outcome =
      function(node, parent, context)
    {
      var self = this,
          obj = {interactionName: self.core.getPointerPath(node, "ref")};

      self.addCoaNode(node, obj);
      return {context: context};
    };

/***********************************************************************/

    DeploymentExporter.prototype.visit_OutcomeFilter =
      function(node, parent, context)
    {
      var self = this;

      self.addCoaNode(node, {});
      return {context: context};
    };

/***********************************************************************/

    DeploymentExporter.prototype.visit_TerminateCOA =
      function(node, parent, context)
    {
      var self = this;

      self.addCoaNode(node, {});
      return {context: context};
    };

/***********************************************************************/

    DeploymentExporter.prototype.addCoaEdge = function(node, obj)
    {
      var self = this;

      obj.name = self.core.getAttribute(node, 'name');
      obj.type = self.core.getAttribute(self.getMetaType(node), 'name');
      obj.ID = self.core.getGuid(node);
      obj.flowID = self.core.getAttribute(node, 'flowID');
      obj.fromNode = self.core.getPointerPath(node, 'src');
      obj.toNode = self.core.getPointerPath(node, 'dst');
      self.coaEdges.push(obj);
      self.coaPathEdge[self.core.getPath(node)] = obj;
    };

/***********************************************************************/

    DeploymentExporter.prototype.visit_COAFlow =
      function(node, parent, context)
    {
      var self = this;

      self.addCoaEdge(node, {});
      return {context: context};
};

/***********************************************************************/

    DeploymentExporter.prototype.visit_COAFlowWithProbability =
      function(node, parent, context)
    {
      var self = this,
      obj = {probability: self.core.getAttribute(node, 'probability')};

      self.addCoaEdge(node, obj);
      return {context: context};
    };

/***********************************************************************/

    DeploymentExporter.prototype.visit_Outcome2Filter =
      function(node, parent, context)
    {
      var self = this;

      self.addCoaEdge(node, {});
      return {context: context};
    };

/***********************************************************************/

    DeploymentExporter.prototype.visit_Filter2COAElement =
      function(node, parent, context)
    {
      var self = this;
      
      self.addCoaEdge(node, {});
      return {context: context};
    };

/***********************************************************************/

    DeploymentExporter.prototype.visit_COAException =
      function(node, parent, context)
    {
      var self = this;
      
      self.addCoaEdge(node, {});
      return {context: context};
    };
    
////////////////////////
// END COA node visitors
///////////////////////

/***********************************************************************/

    DeploymentExporter.prototype.visit_Federate =
      function(node, parent, context)
    {
    var self = this,
        ret = {context: context},
        nodeType = self.core.getAttribute(self.getMetaType(node), 'name'),
        fed = {name: self.core.getAttribute(node, 'name')},
        nodeAttrNames;
    self.logger.info('Visiting a Federate');
    nodeAttrNames = self.core.getAttributeNames(node);
    for (var i = 0; i < nodeAttrNames.length; i += 1)
      {
        fed[nodeAttrNames[i]] = self.core.getAttribute(node, nodeAttrNames[i]);
      }
    fed.FederateType = nodeType;
    fed.configFilename = fed.name.toLowerCase() + ".json";
    self.federates.push(fed);
    
    if (nodeType != 'Federate')
      {
        try {ret = self['visit_' + nodeType](node, parent, context);}
	catch (err)
	{
	  self.logger.debug('No visitor function for ' + nodeType);
        }
    }

    return ret;
};

/***********************************************************************/

    DeploymentExporter.prototype.getVisitorFuncName = function(nodeType)
    {
      var self = this,
          visitorName = 'generalVisitor';
      if (nodeType)
	{
	  visitorName = 'visit_' + nodeType;
	  if (nodeType.endsWith('Federate'))
	    {
	      visitorName = 'visit_' + 'Federate';
	    }
	}
      self.logger.debug('Generated visitor Name: ' + visitorName);
      return visitorName;
    }

/***********************************************************************/

    DeploymentExporter.prototype.getPostVisitorFuncName = function(nodeType)
    {
      var self = this,
          visitorName = 'generalPostVisitor';
      if (nodeType)
        {
          visitorName = 'post_visit_' + nodeType;
          if (nodeType.endsWith('Federate'))
            {
              visitorName = 'post_visit_' + 'Federate';
            }
        }
      return visitorName;
    }

/***********************************************************************/

    DeploymentExporter.prototype.getChildSorterFunc = function(nodeType, self)
    {
      var self = this,
          visitorName = 'generalChildSorter';
      var generalChildSorter = function(a, b)
      {
        //a is less than b by some ordering criterion : return -1;
        //a is greater than b by the ordering criterion: return 1;
        // a equal to b, than return 0;
        var aName = self.core.getAttribute(a, 'name');
        var bName = self.core.getAttribute(b, 'name');
        if (aName < bName) return -1;
        if (aName > bName) return 1;
        return 0;
      };
      return generalChildSorter;
    }

/***********************************************************************/

    DeploymentExporter.prototype.excludeFromVisit = function(node)
    {
      var self = this,
          exclude = false;

      exclude = exclude ||
                self.isMetaTypeOf(node, self.META['Language [C2WT]']);
      return exclude;
    }

/***********************************************************************/

/*
 * Rest of TRAVERSAL CODE:
 * - PubSubVisitors.js
 * - RTIVisitors.js
 * - C2Federates folder for Federate specific vistors
 */

    DeploymentExporter.prototype.ROOT_visitor = function(node)
    {
      var self = this;
      self.logger.info('Visiting the ROOT');

      var root = {"@id": 'model:' + '/root',
                  "@type": "gme:root",
                  "model:name": self.projectName,
                  "gme:children": []};

      return {context: {parent: root}};
}

/***********************************************************************/

    DeploymentExporter.prototype.calculateParentPath = function(path)
    {
      if (!path)
        {
          return null;
        }
      var pathElements = path.split('/');
      pathElements.pop();
      return pathElements.join('/');
    }

/***********************************************************************/

    return DeploymentExporter;
});
