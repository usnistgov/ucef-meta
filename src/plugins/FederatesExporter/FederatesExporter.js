/*

Comment from PluginGenerator
--------------------------------------------
Template for file Generated by PluginGenerator 0.14.0 from webgme
on Wed Dec 02 2015 15:05:52 GMT-0600 (CST). 
--------------------------------------------

File completed by unknown programmer (probably H. Neema)

File modified extensively by T. Kramer 

File reformatted in C style, as far as possible.

In this file, the functions defined in the "define" arguments are
executed by calls such as, for example, PubSubVisitors.call(this),
which in a sane language would be written as this.call(PubSubVisitors).

A separate XML file is generated for each Federate in a project.

federateInfos
-------------

The federateInfos object collects information for each
federate. federateInfos uses federate ids as property names and has
the form

{federateId1: value1, federateId2: value2, ...}. 

The value corresponding to a federateId is an object of the form
{name: federateName,
 directory: directoryPath,
 pubSubObjects:
  {objectId1: objectData1, objectId2: objectData2, ...},
 pubSubInteractions:
  {interactId1: interactData1, interactId2: interactData2, ...}}

The directory property is not used in the FederatesExporter but is used
elsewhere.

The interactData values have the form:

{publish: n, subscribe: m} where n and m are each either 1 or 0,
meaning yes and no. The interactData values are used in an obvious way in
interactionTraverserXml to set the sharingXml of the interaction to
one of Publish, Subscribe, PublishSubscribe, or Neither.

The objectData values have the form:

{publish: n, mayPublish: p, subscribe: m, maySubscribe: q, attribs: attribData} 
where n, m, p and q are each either 1 or 0, meaning yes and no.
publish means definitely publish. mayPublish means maybe publish.

attribData is entered only in the case of crosscuts and has the form
{attId1: attData1, attId2: attData2 ...}

The attData have the form {publish: s, subscribe: t} where s and t are
each either 1 or 0, meaning yes and no. The attribData is entered only
for attributes found in visit_StaticObjectAttributePublish.

The objectData values are used in objectTraverserXml to set the
sharingXml of the object to one of Publish, Subscribe,
PublishSubscribe, or Neither. 

For publishing, an object should Publish if any of the following apply:
 (1) it has a publish relation with the federate
     (call it a type P object) or
 (2) it is an ancestor of a type P object and has an own attribute
     (call it a type Q object)
 (3) it has an own attribute that publishes to the federate in a
     crosscut (call it a type R object)
All ancestors of any of the three types must be included in the XML
whether or not they publish.

For a type P object, publish and mayPublish are both set to 1 when the
publish relation is examined.

For a type Q object that is not also type P, publish is always
0, but mayPublish will be set to 1 in objectTraverserCheck if any
descendant has mayPublish set to 1.

For a type R object that is not also P, publish and mayPublish are
both set to 0 when the crosscut publish relation for an attribute of
the object is examined (so that the object and its ancestors will be
included in the output). Also when that relation is examined,
information that the attribute should be published for the federate
is stored in the attribute.

For subscribing, the situation is exactly analogous to publishing.

Notice that pubSubInteractions and pubSubObjects of a federate have
the same name and same structure as the pubSubInteractions and
pubSubObjects of the deployment exporter. This enables using the six
visit_XXX functions in PubSubVisitors.js for both exporters. 

The value in federateInfos for a federateId is initialized where
the federate is first encountered. That may be in any of three places:

(1) the atModelNode function defined in C2Core/ModelTraverserMixin.js.
If initialized here, the pubSubObjects and pubSubInteractions are both
empty objects. If a federateInfo for a federate has already been created
when the federate is encountered in this function, the name of the
federate is added to the data (since it will be missing).

(2) one of the four visit_StaticXXX functions defined in
PubSubVisitors.js.  If initialized here, (i) some data will be put
into either the pubSubObjects or the pubSubInteractions and (ii) the
federate name will be set to null since it is not available. If a
federateInfo for a federate has already been created when the federate
is encountered in a visit_StaticXXX function, some data will be put
into either the pubSubObjects or the pubSubInteractions.

(3) one of the two visit_StaticObjectAttributeXXX functions defined in
PubSubVisitors.js.

See the documentation of objectTraverserCheck and
interactionTraverserCheck regarding how additional items are added to
pubSubInteractions and pubSubObjects.

The pubSubInteractions and pubSubObjects of a federate are used in the
objectTraverserXml and interactionTraverserXml functions to set the
values for sharing that are put into the output XML file for the
federate. For objects, the data for the federate in each attribute of
the object (if there is any) is also used, and the three rules given
above are followed.

endJoinResigns
--------------

The endJoinResigns object uses interaction ids as property names; the
value corresponding to a name is a pointer to the interaction. The
endJoinResigns are built in the visit_Interaction function of
RTIVisitors.js (where the required information is available). The
interactions put into endJoinResigns are those whose name is one of:
SimEnd, FederateJoinInteraction, FederateResignInteraction. The
endJoinResigns are used in the fomGenerator function to add those
interactions to those to be be included in an XML fom file for a
federate. The publish and subscribe values for interactions in the
endJoinResigns are set in the addEndJoinResign function.

*/

define
([
  'text!./metadata.json',
  'plugin/PluginBase',
  'common/util/ejs',
  'C2Core/ModelTraverserMixin',
  'C2Core/xmljsonconverter',
  'C2Core/MavenPOM',
  'FederatesExporter/PubSubVisitors',
  'FederatesExporter/RTIVisitors',
  'FederatesExporter/Templates/Templates',
  'C2Federates/GenericFederate',
  'C2Federates/JavaFederate',
  'C2Federates/MapperFederate',
  'C2Federates/CppFederate',
  'C2Federates/OmnetFederate',
  'C2Federates/CPNFederate',
  'C2Federates/GridLabDFederate',
  'C2Federates/LabVIEWFederate'],
 function (pluginMetadata,
           PluginBase,
           ejs,
           ModelTraverserMixin,
           JSON2XMLConverter,
           MavenPOM,
           PubSubVisitors,
           RTIVisitors,
           TEMPLATES,
           GenericFederate,
           JavaFederate,
           MapperFederate,
           CppFederate,
           OmnetFederate,
           CPNFederate,
           GridLabDFederate,
           LabVIEWFederate)
 {
    'use strict';
    var FederatesExporter;          // function variable
    var addEndJoinResign;           // function variable
    var objectTraverserCheck;       // function variable
    var objectTraverserXml;         // function variable
    var interactionTraverserCheck;  // function variable
    var interactionTraverserXml;    // function variable
    var fomGenerator;               // function variable

    pluginMetadata = JSON.parse(pluginMetadata);

/***********************************************************************/

/* FederatesExporter (function-valued variable of top-level function object)

*/

    FederatesExporter = function()
    {
      var feder;
      
      this.federateTypes = this.federateTypes || {};
      this.federateInfos = {}; // see documentation above
      this.endJoinResigns = {};  // see documentation above
      this.callObjectTraverser = true;
      PluginBase.call(this);
      ModelTraverserMixin.call(this);
      PubSubVisitors.call(this);
      RTIVisitors.call(this);
      GenericFederate.call(this);
      JavaFederate.call(this);
      MapperFederate.call(this);
      CppFederate.call(this);
      OmnetFederate.call(this);
      CPNFederate.call(this);
      GridLabDFederate.call(this);
      LabVIEWFederate.call(this);      
      
      this.mainPom = new MavenPOM();
      this._jsonToXml = new JSON2XMLConverter.Json2xml();
      this.pluginMetadata = pluginMetadata;
    };

/***********************************************************************/

    // Prototypal inheritance from PluginBase.
    FederatesExporter.prototype = Object.create(PluginBase.prototype);
    FederatesExporter.prototype.constructor = FederatesExporter;
    FederatesExporter.metadata = pluginMetadata;

/***********************************************************************/

/*  addEndJoinResign (function-valued variable of top-level function object)

Returned Value: none

Called By: fomGenerator

This adds an entry to the pubSubInteractions for any interaction named
SimEnd, FederateResignInteraction, or FederateJoinInteraction.

*/
    addEndJoinResign = function( /* ARGUMENTS                               */
     name,                       /* (string) name of the interaction to add */
     pubSubInteractions,         /* (object) interaction data to add to     */
     id)                         /* (string) id of the interation to add    */
    {
      if (name == 'SimEnd')
        {
          if (pubSubInteractions[id])
            {
              pubSubInteractions[id].subscribe = 1;
            }
          else
            {
              pubSubInteractions[id] = {publish: 0,
                                        subscribe: 1};
            }
        }
      else if ((name == 'FederateResignInteraction') ||
               (name == 'FederateJoinInteraction'))
        {
          if (pubSubInteractions[id])
            {
              pubSubInteractions[id].publish = 1;
            }
          else
            {
              pubSubInteractions[id] = {publish: 1,
                                        subscribe: 0};
            }
        }
    };

/***********************************************************************/

/* objectTraverserCheck (function-valued variable of top-level function object)

Returned Value: none

Called By:
  anonyomous fom generator in FederatesExporter.prototype.main
  objectTraverserCheck (recursively)

This adds entries to the pubSubObjects of a federate for all ancestors
of objects that already have entries.

By calling itself recursively, this goes through the object tree (from
top down) but builds the pubSubObjects of the federate from bottom up.
 
For each object that has an entry in the federate.pubSubObjects:

  If the parent already has an entry in the federate.pubSubObjects:
    If object has non-zero mayPublish, the parent's mayPublish is set to 1.
    If object has non-zero maySubscribe, the parent's maySubscribe is set to 1.

  Otherwise, a new entry for parent is put into the federate.pubSubObjects
  with publish set to 0, subscribe set to 0, mayPublish set to the object's
  mayPublish and maySubscribe set to the object's maySubscribe.

If the parent publishes or subscribes to the federate, an entry in
federate.pubSubObjects for the parent will have been made previously
in PubSubVisitors.

The final effect is that any object that is an ancestor of any object
originally put on the federate.pubSubObjects in PubSubVisitors is also
on federate.pubSubObjects, with its publish, subscribe, mayPublish, and
maySubscribe values set appropriately.

*/

    objectTraverserCheck = function( /* ARGUMENTS                           */
     federate,               /* (object) data in FederateInfos for federate */
     object)                 /* (object) object to process                  */
    {
      var objectPubSub;
      var parentPubSub;

      object.children.forEach(function(child)
      {
        objectTraverserCheck(federate, child);
      });
      if (object.name != 'ObjectRoot' &&
          (object.id in federate.pubSubObjects))
        {
          objectPubSub = federate.pubSubObjects[object.id];
          if (object.basePath in federate.pubSubObjects)
            {
              parentPubSub = federate.pubSubObjects[object.basePath];
              if (objectPubSub.mayPublish)
                {
                  parentPubSub.mayPublish = 1;
                }
              if (objectPubSub.maySubscribe)
                {
                  parentPubSub.maySubscribe = 1;
                }
            }
          else
            {
              federate.pubSubObjects[object.basePath] =
                {publish: 0,
                 subscribe: 0,
                 mayPublish: objectPubSub.mayPublish,
                 maySubscribe: objectPubSub.maySubscribe};
            }
        }
    };

/***********************************************************************/

/* objectTraverserXml (function-valued variable of top-level function object)

Returned Value: a string of XML representing the object and its descendants

Called By:
  anonyomous fom generator in FederatesExporter.prototype.main
  objectTraverserXml (recursively)

objectTraverserXml is a recursive function that builds the XML for
objects in a federate.

The function takes (1) information about a federate, (2) an object
that may have children (which are also objects), and (3) a string of
blank space to use for indenting.

The function begins by creating an objModel. The objModel is given the
same name and attributes as the object and is given children that are
XML code built by a recursive call to the function on the children of
the object.  Information for printing XML is added to the data for
each attribute of the object. Data regarding "sharing" for the XML is
derived from the federate information and the attribute data.

Then XML for the objModel is generated from the objModel (and saved)
by calling ejs.render using the fedfile_simobject_xml XML Template.

Crosscuts are Publish or Subscribe links from a federate directly to
an attribute of an object. Crosscuts are handled by putting entries
for crosscuts (only) into the attribs property of the object data for
a federate. The code for crosscuts is mostly in the great big "else"
near the end of the function, but there is also code dealing with
crosscuts in two places before that. Setting the printFor property of
an attribute allows it to be printed (by fedfile_simobject_xml.ejs)
even when the attribute is an inherited property. The printFor
property is set back to 0 there so the attribute won't necessarily be
printed for the same object in the XML file for some other federate.

NOTE: An alternative to using the printFor attribute would be to
create a deferredPubSubs property of the federate. When a crosscut hit
an inherited attribute A of an object D, an entry would be made in the
deferredPubSubs recording the id of A and the type of sharing. When an
object C is deciding how to set sharing for an own attribute B, a
check of the deferredPubSubs would be made to see if an attribute with
the id of B is recorded. If so, B is A, and the sharing of B would be
set taking into account the sharing given in the deferredPubSubs
entry.

*/

    objectTraverserXml = function( /* ARGUMENTS                             */
     federate,               /* (object) data in federateInfos for federate */
     object,                 /* (object) object to process                  */
     space)                  /* (string) indentation space                  */
    {
      var objModel;
      var objPuBSub;
      var hasOwn;

      objModel = {name: object.name,
                  sharingXml: 0,
                  indent: space,
                  attributes: object.attributes,
                  children: []};

      objPuBSub = federate.pubSubObjects[object.id];
      hasOwn = 0;
      // The attributes in the objModel are the attributes of the object.
      // Properites of attributes not related to XML generation are not
      // modified, but properties of attributes related to XML generation
      // are assigned as follows.
      objModel.attributes.forEach(function(attr)
      {
        if (!attr.inherited)
          {
            attr.deliveryXml = ((attr.delivery === "reliable") ?
                                "HLAreliable" : "HLAbestEffort");
            attr.orderXml = ((attr.order === "timestamp") ?
                             "TimeStamp" : "Receive");
            hasOwn = 1;
          }
      });
      // An object should publish if: (1) the data for it in the
      // federate information says publish or (2) the data says maybe
      // publish and one or more of the object's attributes is an own
      // attribute or (3) the data says there is publish crosscut.
      // Similarly for subscribing.
      if (objPuBSub && (objPuBSub.publish ||
                        (objPuBSub.mayPublish && hasOwn)))
        { // object publishes
          if (objPuBSub.subscribe || (objPuBSub.maySubscribe && hasOwn))
            { // object also subscribes
              objModel.sharingXml = "PublishSubscribe";
              objModel.attributes.forEach(function(attr)
              { // also set sharing for own attributes
                if (!attr.inherited)
                  {
                    attr.sharingXml = "PublishSubscribe";
                  }
              });
            }
          else
            { // object publishes but does not subscribe
              objModel.sharingXml = "Publish";
              objModel.attributes.forEach(function(attr)
              { // also set sharing for own attributes
                if (objPuBSub.attribs && (attr.id in objPuBSub.attribs))
                  { // if crosscut subscribes, upgrade to PublishSubscribe
                    if (objPuBSub.attribs[attr.id].subscribe)
                      {
                        attr.sharingXml = "PublishSubscribe";
                        objModel.sharingXml = "PublishSubscribe";
                      }
                  }
                else if (!attr.inherited)
                  { // otherwise mark the attribute as Publish if not inherited
                    attr.sharingXml = "Publish";
                  }
              });
            }
        }
      else if (objPuBSub && (objPuBSub.subscribe ||
                             (objPuBSub.maySubscribe && hasOwn)))
        { // object subscribes but does not publish
          objModel.sharingXml = "Subscribe";
          objModel.attributes.forEach(function(attr)
          { // also set sharing for own attributes
            if (objPuBSub.attribs && (attr.id in objPuBSub.attribs))
              { // if crosscut publishes, upgrade to PublishSubscribe
                if (objPuBSub.attribs[attr.id].publish)
                  {
                    attr.sharingXml = "PublishSubscribe";
                    objModel.sharingXml = "PublishSubscribe";
                  }
              }
            else if (!attr.inherited)
              { // otherwise mark the attribute as Subscribe if not inherited
                attr.sharingXml = "Subscribe";
              }
          });
        }
      else
        { // object neither publishes nor subscribes; deal with crosscuts
          objModel.sharingXml = "Neither";
          objModel.attributes.forEach(function(attr)
          {
            if (objPuBSub.attribs && (attr.id in objPuBSub.attribs))
              { // attribute is involved in a crosscut
                if (attr.inherited)
                  { // if not own attribute, set values and set flag to print
                    attr.deliveryXml = ((attr.delivery === "reliable") ?
                                        "HLAreliable" : "HLAbestEffort");
                    attr.orderXml = ((attr.order === "timestamp") ?
                                     "TimeStamp" : "Receive");
                    attr.printFor = objModel.name; 
                  }
                if (objPuBSub.attribs[attr.id].publish)
                  { // some crosscut says publish
                    if (objPuBSub.attribs[attr.id].subscribe)
                      { // some other crosscut says subscribe
                        attr.sharingXml = "PublishSubscribe";
                        objModel.sharingXml = "PublishSubscribe";
                      }
                    else
                      { // there is no subscribe crosscut, so Publish
                        attr.sharingXml = "Publish";
                        if (objModel.sharingXml != "PublishSubscribe")
                          { // but do not change if already PublishSubscribe
                            objModel.sharingXml = "Publish";
                          }
                      }
                  }
                else if (objPuBSub.attribs[attr.id].subscribe)
                  { // is subscribe but not publish crosscut, so Subscribe
                    attr.sharingXml = "Subscribe";
                    if (objModel.sharingXml != "PublishSubscribe")
                      { // but do not change if already PublishSubscribe
                        objModel.sharingXml = "Subscribe";
                      }
                  }
              }
            else
              { // no publish, subscribe, or relevant crosscut
                attr.sharingXml = "Neither";
              }
          }); // end of function body and forEach
        } // end of else
      
      // Here, objectTraverserXml calls itself recursively to
      // generate XML for the children before generating
      // XML for the parent.
      // We do not want to include the FederateObject.
      object.children.forEach(function(child)
      {
        if ((child.name != "FederateObject") &&
            (child.id in federate.pubSubObjects))
          {
            objModel.children.push
              (objectTraverserXml(federate, child, space + "    "));
          }
      });
      // now generate XML for the parent if on pubSubObjects
      if (object.id in federate.pubSubObjects)
        {
          return ejs.render(TEMPLATES["fedfile_simobject_xml.ejs"], objModel);
        }
    };

/***********************************************************************/

/* interactionTraverserCheck (function-valued var of top-level function object)

Returned Value: none

Called By:
  anonyomous fom generator in FederatesExporter.prototype.main
  interactionTraverserCheck (recursively)

This adds entries to the pubSubInteractions of a federate for all ancestors
of interactions that already have entries.

By calling itself recursively, this goes through the interaction tree
(from top down) but builds the pubSubInteractions from bottom up.

If an interaction is on the pubSubInteractions of the federate but its
parent is not, an entry for the parent of the interaction is added to
the pubSubInteractions; the entry represents that the parent neither
publishes or subscribes. If the parent publishes or subscribes, an
entry for the parent will have been made previously in PubSubVisitors.

The final effect is that any interaction that is an ancestor of any
interaction originally put on the pubSubInteractions in PubSubVisitors
is also on pubSubInteractions.

*/
    interactionTraverserCheck = function( /* ARGUMENTS                       */
     federate,                /* (object) data in federateInfos for federate */
     interaction)             /* (object) interaction to process             */
    {
      interaction.children.forEach(function (child)
      {
        interactionTraverserCheck(federate, child);
      });
      if (interaction.name != 'InteractionRoot')
        {
          if ((interaction.id in federate.pubSubInteractions) &&
              !(interaction.basePath in federate.pubSubInteractions))
            {
              federate.pubSubInteractions[interaction.basePath] =
                {publish: 0,
                 subscribe: 0};
            }
        }
    };

/***********************************************************************/

/* interactionTraverserXml (function-valued var of top-level function object)

Returned Value: a string of XML representing the interaction and its
                descendants

Called By:
  anonyomous fom generator in FederatesExporter.prototype.main
  interactionTraverserXml (recursively)

interactionTraverserXml is a recursive function that builds the XML
for interactions in a federate.

The function takes information about a federate and takes an interaction
that may have children (which are also interactions).

The function begins by creating an intModel. The intModel is given the
same name and parameters as the interaction and is given children that are
XML code built by a recursive call to the function on the children of
the interaction.  The intModel is also given other properties needed for
generating XML.

Then XML for the intModel is generated from the intModel (and saved)
by calling ejs.render using the fedfile_siminteraction_xml XML Template.

*/
    interactionTraverserXml = function( /* ARGUMENTS                        */
     federate,               /* (object) data in federateInfos for federate */
     interaction,            /* (object) interaction to process             */
     space)                  /* (string) indentation space                  */
    {
      var intModel;
      var intPubSub;

      intModel = {name: interaction.name,
                  sharingXml: 0,
                  deliveryXml: 0,
                  orderXml: 0,
                  indent: space,
                  parameters: interaction.parameters,
                  children: []};
      intPubSub = federate.pubSubInteractions[interaction.id];
      if (intPubSub && intPubSub.publish)
        {
          if (intPubSub.subscribe)
            {
              intModel.sharingXml = "PublishSubscribe";
            }
          else
            {
              intModel.sharingXml = "Publish";
            }
        }
      else if (intPubSub && intPubSub.subscribe)
        {
          intModel.sharingXml = "Subscribe";
        }
      else
        {
          intModel.sharingXml = "Neither";
        }
      if (interaction.delivery === "reliable")
        {
          intModel.deliveryXml = "HLAreliable";
        }
      else
        {
          interaction.deliveryXml = "HLAbestEffort";
        }
      if (interaction.order === "timestamp")
        {
          intModel.orderXml = "TimeStamp";
        }
      else
        {
          intModel.orderXml = "Receive";
        }
      // here interactionTraverserXml calls itself recursively to
      // generate XML for the children before generating
      // XML for the parent
      interaction.children.forEach(function (child)
      {
        if (child.id in federate.pubSubInteractions)
          {
            intModel.children.push
              (interactionTraverserXml(federate, child, space + "    "));
          }
      });
      
      // now generate XML for the parent if on pubSubInteractions
      if (interaction.id in federate.pubSubInteractions)
        {
          return ejs.render(TEMPLATES["fedfile_siminteraction_xml.ejs"],
                            intModel);
        }
    };
            
/***********************************************************************/

/* fomGenerator (function-valued variable of top-level function object)

Returned Value: none

Called By: finishExport

This builds a file generator that generates a separate fom file for each
federate in a project.

Where fedEx.objectRoots.forEach is called, objectTraverserXml will
return undefined if there is no XML for objects. In that case,
objectsXml will have length 1, but objectsXml[0] will be undefined.

The call to the callback function with no argument evidently triggers
printing all the files that have been put into the artifact. If callback
is called each time around the loop below, a zip file is generated each
time containing one more fom file than the preceding zip file. Hence
that call can be made only once. In addition, webGME complains if
callback is called more than once.

*/
    fomGenerator = function( /* ARGUMENTS                             */
     fedEx)                  /* the FederatesExporter function object */
    {
      var today = new Date();
      var year = today.getFullYear();
      var month = today.getMonth();
      var day = today.getDate();
      var dateString = (year + "-" + ((month < 10) ? "0" : "") + month +
                        "-" + ((day < 10) ? "0" : "") + day);
      var fomModelXml;      // model from which to generate XML
      var federId;          // id of federate  
      var feder;            // data for federate in federateInfos
      var endJoinResignId;  // id of a 
      var directory;        // SOM.xml output directory    
      var endJoinResign;
      var remaining;
      var xmlCode;
      var fullPath;
      var template;

      remaining = Object.keys(fedEx.federateInfos).length;
      template = TEMPLATES['fedfile.xml.ejs'];
      fedEx.fileGenerators.push(function(artifact, callback)
      {
        for (federId in fedEx.federateInfos)
          {
            remaining--;
            feder = fedEx.federateInfos[federId];
            directory = feder.directory || 'som/';

            fomModelXml =
              {federateName: feder.name,
               projectName: fedEx.projectName,
               version: fedEx.getCurrentConfig().exportVersion.trim(),
               pocOrg: fedEx.mainPom.groupId,
               dateString: dateString,
               objectsXml: [],
               interactionsXml: []};
            fedEx.interactionRoots.forEach(function (interactionRoot)
            {
              for (endJoinResignId in fedEx.endJoinResigns)
                {
                  endJoinResign = fedEx.endJoinResigns[endJoinResignId];
                  addEndJoinResign(endJoinResign.name,
                                   feder.pubSubInteractions, endJoinResignId);
                }
              interactionTraverserCheck(feder, interactionRoot);
              fomModelXml.interactionsXml.push
                (interactionTraverserXml(feder, interactionRoot, "    "));
            });
            fedEx.objectRoots.forEach(function(objectRoot)
            {
              //objectTraverserCheck(feder, objectRoot);
              fomModelXml.objectsXml.push
                (objectTraverserXml(feder, objectRoot, "    "));
            });
            // add fom XML files to artifact
            fullPath = directory + feder.name + '.xml';
            xmlCode = ejs.render(template, fomModelXml);
            console.log('calling addFile for: ' + fullPath);
            artifact.addFile(fullPath, xmlCode,
                             (remaining ?
                              function (err) // there are more
                              {if (err) {callback(err); return;}} :
                              function (err) // last one
                              {if (err) {callback(err); return;}
                                else {callback();}}
                              )
                             );
          }
      });
    };
      
/***********************************************************************/
    
/* FederatesExporter.prototype.main

Returned Value: none

Called By: ?

Notes autogenerated or from previous coder:
-------------------------------------------

    This is the main function for the plugin to execute. This will perform
    the execution.

    Use self to access core, project, result, etc from PluginBase;
    these are all instantiated at this point.

    Do NOT put any user interaction logic UI, etc. inside this method.
    callback always has to be called even if error happened.

    @param {function(string, plugin.PluginResult)} callback -
    the result callback
---------------------------------------

*/
    FederatesExporter.prototype.main = function(
     callback)
    {
      var self = this;            // federates exporter function
      var feder;                  // for-in variable
      var generateFiles;          // function
      var numberOfFileGenerators; // counter used in generateFiles function
      var finishExport;           // function
      var saveAndReturn;          // function

      self.fileGenerators = [];
      self.corefileGenerators = [];
      self.fom_sheets = {};
      self.interactions = {};
      self.interactionRoots = [];
      self.objects      = {};
      self.objectRoots = [];
      self.attributes   = {};
      self.federates = {};
      self.javafederateName = {};
      self.fedFilterMap = {};
      self.fedFilterMap["MAPPER_FEDERATES"] = "MAPPER";
      self.fedFilterMap["NON-MAPPER_FEDERATES"] = "NON_MAPPER";
      self.fedFilterMap["BOTH"] = "ORIGIN_FILTER_DISABLED";
      self.fedFilterMap["SELF"] = "SELF";
      self.fedFilterMap["NON-SELF"] = "NON_SELF";
      
      self.projectName = self.core.getAttribute(self.rootNode, 'name');
      self.project_version =
      self.getCurrentConfig().exportVersion.trim() +
      (self.getCurrentConfig().isRelease ? "" : "-SNAPSHOT");
      self.cpswt_version = self.getCurrentConfig().cpswtVersion.trim();
      self.directoryNameTemplate=
      '<%=federation_name%><%=artifact_name?"-"+artifact_name:""%><%=language?"-"+language:""%>';
      self.generateExportPackages =
        self.getCurrentConfig().generateExportPackages;
      self.mainPom.artifactId = self.projectName + "-root";
      self.mainPom.version = self.project_version;
      self.mainPom.packaging = "pom";
      self.mainPom.groupId = self.getCurrentConfig().groupId.trim();
      self.mainPom.addRepository(
        {
           'id': 'archiva.internal',
           'name': 'Internal Release Repository',
           'url': self.getCurrentConfig().repositoryUrlRelease.trim()
        });
        
      self.mainPom.addSnapshotRepository(
        {
           'id': 'archiva.snapshots',
           'name': 'Internal Snapshot Repository',
           'url': self.getCurrentConfig().repositoryUrlSnapshot.trim()
        });
      self.getCurrentConfig().includedFederateTypes.trim().split(" ").
        forEach(function(e)
          {
            if (self.federateTypes.hasOwnProperty(e))
              {
                self.federateTypes[e].includeInExport = true;
                if (self.federateTypes[e].hasOwnProperty('init'))
                  {
                    self.federateTypes[e].init.call(self); 
                  }
              }
          });

/***********************************************************************/

/* generateFiles (function-valued variable of FederatesExporter.prototype.main)

Returned Value: none

Called By:
  finishExport
  generateFiles (recursively)

This generates the text of files to be included in the output. It executes
one file generating function on each recursive call.

*/      

      generateFiles = function( /* ARGUMENTS                                */
       artifact,                /* (object) see above                       */
       fileGenerators,          /* (array) of functions that generate files */
       doneBack)                /* (?) function                             */
      {
        if (numberOfFileGenerators > 0)
          { 
            fileGenerators[fileGenerators.length -
                           numberOfFileGenerators](artifact, function(err)
              {
                if (err)
                  {
                    callback(err, self.result);
                    return;
                  }
                numberOfFileGenerators--;
                if (numberOfFileGenerators > 0)
                  {
                    generateFiles(artifact, fileGenerators, doneBack);
                  }
                else
                  {
                    doneBack();
                  }
              });                
          }
        else
          {
            doneBack();
          }
      };

/***********************************************************************/

/* saveAndReturn (function-valued variable of FederatesExporter.prototype.main)

Returned Value: none

Called By: finishExport

This function is defined as a variable of FederatesExporter.prototype.main.
It uses the self variable.

*/      

      saveAndReturn = function( /* ARGUMENTS                             */
       err)                     /* (string)  an error string or null (?) */
      {
        var errorRaised;
        var i;
        var msg;
        var idx;
        var artifactMsg;
        var buildURL;

        errorRaised = false;
        for (i = 0; i < self.result.getMessages().length; i++)
          {
            msg = self.result.getMessages()[i];
            if (msg.severity == 'error')
              {
                errorRaised = true;
              }
          }
        if (!errorRaised)
          {
            self.blobClient.saveAllArtifacts(function (err, hashes)
            {
              if (err)
                {
                  callback(err, self.result);
                  return;
                }
              // comment from previous coder:
              // This will add a download hyperlink in the result-dialog.
              for (idx = 0; idx < hashes.length; idx++)
                {
                  self.result.addArtifact(hashes[idx]);
                  
                  artifactMsg =
                    'Code package ' +
                    self.blobClient.artifacts[idx].name +
                    ' was generated with id:[' + hashes[idx] + ']';
                  buildURL =
                    "'http://c2w-cdi.isis.vanderbilt.edu:8080/job/c2w-pull/buildW ithParameters?GME_ARTIFACT_ID=" + hashes[idx] + "'";
                  artifactMsg += '<br><a title="Build package..." '+
                    'onclick="window.open(' + buildURL + ', \'Build System\'); return false;">Build artifact..</a>';
                  self.createMessage(null, artifactMsg );
                };
              // comment from previous coder:
              // This will save the changes. If you don't want to save;
              // exclude self.save and call callback directly from this
              // scope.
              self.save('FederatesExporter updated model.', function (err)
                {
                  if (err)
                    {
                      callback(err, self.result);
                      return;
                    }
                  self.result.setSuccess(true);
                  callback(null, self.result);
                  return;
                });
            });
          }
        else
          {
            self.result.setSuccess(false);
            callback(null, self.result);
            return;
          }
      };

/***********************************************************************/

/* finishExport (function-valued variable of FederatesExporter.prototype.main)

Returned Value: none

Called By: anonymous function used as an argument to 
  visitAllChildrenFromRootContainer

This function is defined as a variable of FederatesExporter.prototype.main.
It uses the self variable.

*/      

      finishExport = function( /* ARGUMENTS                            */
       err)                    /* (string) an error string or null (?) */
      {
        var artifact;
        var coreArtifact;

        artifact =
          self.blobClient.createArtifact(self.projectName.trim().
                                         replace(/\s+/g,'_') + '_generated');
        fomGenerator(self);
        if (self.generateExportPackages)
          {
            coreArtifact =
              self.blobClient.createArtifact('generated_Core_Files');
          }
        numberOfFileGenerators = self.fileGenerators.length;
        if (numberOfFileGenerators > 0)
          {
            generateFiles(artifact, self.fileGenerators, function(err)
            {
              if (err)
                {
                  callback(err, self.result);
                  return;
                }
              numberOfFileGenerators = self.corefileGenerators.length;
              if (self.generateExportPackages &&
                  numberOfFileGenerators > 0)
                {
                  generateFiles(coreArtifact,
                                self.corefileGenerators, function(err)
                    {
                      if (err)
                        {
                          callback(err, self.result);
                          return;
                        }
                      saveAndReturn();
                      return;
                    });
                }
              else
                {
                  saveAndReturn();
                  return;
                }
            });
          }
        else
          {
            self.result.setSuccess(true);
            callback(null, self.result);
          } 
      };

/***********************************************************************/

/*

This is a call to the visitAllChildrenFromRootContainer function (!) which
is defined in ModelTraverserMixin.js. The anonymous function is the second
argument.

*/

      self.visitAllChildrenFromRootContainer(self.rootNode, function(err)
        {
          if (err)
            {
              self.logger.error(err);
              self.createMessage(null, err, 'error');
              self.result.setSuccess(false);
              callback(null, self.result);
            }
          else
            {
              finishExport(err);
            }
        }); 

/***********************************************************************/

      // self.postAllVisits(self); COMMENTED OUT
    }; // end of FederatesExporter.prototype.main

/***********************************************************************/

/* FederatesExporter.prototype.getChildSorterFunc

This defines the FederatesExporter.prototype.getChildSorterFunc function
that defines a function to be passed to a sorting routine. The function
to be passed to a sorting routine takes pointers to two attributes (a and b)
and implements the rules:
  If the name of a is less than the name of b, return -1.
  Otherwise, if the name of a is greater than the name of b, return 1.
  Otherwise, return 0.

This is a very strange function because it does not use either of its
arguments. This function is not called in this file.

*/    
    FederatesExporter.prototype.getChildSorterFunc = function(
     nodeType, // argument not used
     self)     // argument not used (overridden by var also named self)
    {
      var self;
      var generalChildSorter;

      self = this; // overrides self argument
      generalChildSorter = function(a, b)
      {
        var aName;
        var bName;

        aName = self.core.getAttribute(a,'name');
        bName = self.core.getAttribute(b,'name');
        if (aName < bName) return -1;
        if (aName > bName) return 1;
        return 0;
      };
      return generalChildSorter;
    };

/***********************************************************************/

/* excludeFromVisit (function property of FederatesExporter.prototype)

Returned Value: true or false

Called By: ? does not appear to be called anywhere

A function named excludeFromVisit is also defined (and called) in
ModelTraverserMixin.js.

*/

    FederatesExporter.prototype.excludeFromVisit = function(node)
    {
      var self;
      var exclude;
      var nodeTypeName;
      
      self = this,
      exclude = false;
      
      if (self.rootNode != node)
        {    
          nodeTypeName =
            self.core.getAttribute(self.getMetaType(node),'name');
          exclude = exclude 
            || self.isMetaTypeOf(node, self.META['Language [C2WT]'])
            || (self.federateTypes.hasOwnProperty(nodeTypeName) &&
                !self.federateTypes[nodeTypeName].includeInExport);
        }
      return exclude;
    };

/***********************************************************************/

/* getVisitorFuncName (function property of FederatesExporter.prototype)

Returned Value: a visitor function name

Called By: atModelNode in ModelTraverserMixin.js

This is defining the getVisitorFuncName function as a property of the
prototype of FederatesExporter. The getVisitorFuncName function is
also defined as a property of "this" in ModelTraverserMixin.js, but
the one that gets called when the FederatesExporter is executing is
this one.

*/

    FederatesExporter.prototype.getVisitorFuncName = function(
     nodeType) // (string) the name of a type of node or null
    {
      var visitorName = 'generalVisitor';
      if (nodeType)
        {
          visitorName = 'visit_'+ nodeType;
          if (nodeType.endsWith('Federate'))
            {
              visitorName = 'visit_'+ 'Federate';
            }
        }
      return visitorName;   
    };

/***********************************************************************/

/* getPostVisitorFuncName (function property of FederatesExporter.prototype)

*/

    FederatesExporter.prototype.getPostVisitorFuncName = function(nodeType)
    {
      var self = this,
      visitorName = 'generalPostVisitor';
      
      if (nodeType)
        {
          visitorName = 'post_visit_'+ nodeType;
          if (nodeType.endsWith('Federate'))
            {
              visitorName = 'post_visit_'+ 'Federate';
            }
        }
      return visitorName;
    };

/***********************************************************************/

    FederatesExporter.prototype.ROOT_visitor = function(node)
    {
      var self = this;
      var root = {"@id": 'model:' + '/root',
                  "@type": "gme:root",
                  "model:name": self.projectName,
                  "gme:children": []};
      return {context:{parent: root}};
    };

/***********************************************************************/

    FederatesExporter.prototype.calculateParentPath = function(path)
    {
      if (!path)
        {
          return null;
        }
      var pathElements = path.split('/');
      pathElements.pop();
      return pathElements.join('/');
    };

/***********************************************************************/

    return FederatesExporter;
 }); // end define
