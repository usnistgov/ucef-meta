//jshint ignore: start
/* Generated file based on ejs templates */
define([], function() {
    return {
    "common/log4j2.xml.ejs": "<% /*\ninput properties\n----------------\nnone\n\nused in\n-------\nGridLabDFederate.js\nJavaImplFederate.js\nLabVIEWFederate.js\nTRNSYSFederate.js\n\n*/ -%>\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration status=\"WARN\">\n    <Appenders>\n        <Console\n            name=\"Console\"\n            target=\"SYSTEM_OUT\">\n            <PatternLayout pattern =\n                \"%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/>\n        </Console>\n    </Appenders>\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\" />\n        </Root>\n    </Loggers>\n</Configuration>\n",
    "common/mvn-install.sh.ejs": "<% /*\ninput properties\n----------------\nnone\n\nused in\n-------\nGridLabDFederate.js\nJavaImplFederate.js\nLabVIEWFederate.js\nTRNSYSFederate.js\n\n*/ -%>\n#!/bin/bash\nmvn clean install -U\n",
    "common/rti.rid.ejs": "<% /*\ninput properties\n----------------\nbindAddress\n\nused in\n-------\nGridLabDFederate.js\nJavaImplFederate.js\nLabVIEWFederate.js\nTRNSYSFederate.js\n\n*/ -%>\n# ================================\n# Portico RTI Initialization Data\n# ================================\n# This file contains all available configuration options for Portico. \n# Values are initially commented out and are provided shown with their default settings.\n#\n# All options are formatted as name=value pairs, the '#' and '!' characters mark comment lines\n#\n# To make use of this file, put it in the directory that your federate is executed from, or set the\n# RTI_RID_FILE environment variable to point at wherever it is located.\n#\n\n# ===================================\n# 1. General Portico Logging Options\n# ===================================\n# (NOTE) Some sub-components have their own log settings. See the sections relaing to them for\n#        those particular properties.\n\n# (1.1) Portico Log Directory\n#        Specify the directory to put the Portico log-files into. This defaults to \"logs\" and\n#        if a relative path is used, it will be releative to the location of the process that\n#        executed Portico\n#\n# portico.logdir = logs\n\n# (1.2) Portico Log Level\n#        Specify the level that Portico will log at. Valid values are: TRACE, DEBUG, INFO, WARN,\n#        ERROR, FATAL, OFF. The default value is \"WARN\".\n#\n# portico.loglevel = INFO\n\n# (1.3) Print FOM when federate Joins\n#        When a federate joins a federation, Portico can pretty-print the FOM data of that\n#        federation. If this is enabled, the FOM is logged to the INFO level (so make sure you\n#        have logging turned up high enough). By default this is disabled.\n#\n# portico.fom.print = disabled\n\n# (1.4) Logging by Handle/Name\n#        Making sense of log files can be difficult. To help make sense of this data, various bits\n#        of HLA information can be logged by their HLA handle or their name. For example, an HLA\n#        object class can be logged by its handle, or by its name.\n#\n#        Any items specified in logWithHandles are logged using their handles (and vice versa for\n#        logWithNames). The format of these properties is a comma-separated list containing any of\n#        the following identifiers (defaults specified in parentheses):\n#\n#        objectClass       (handle)\n#        attributeClass    (handle)\n#        interactionClass  (handle)\n#        parameterClass    (handle)\n#        objectInstance    (name)\n#        space             (handle)\n#        dimension         (handle)\n#        federate          (name)\n#\n#        (NOTE) You only have to specify the bits you want. If a value isn't specified in either\n#               list, it will assume its default value. If a value is specified in both lists, the\n#               logWithNames takes precedence.\n#\n# portico.logWithHandles=objectClass,attributeClass,interactionClass,parameterClass,space,dimension\n# portico.logWithNames=objectInstance,federate\n\n\n# ================================\n# 2. HLA Related RTI Properties\n# ================================\n# These settings relate to how the RTI works with regard to HLA operations\n\n# (2.1) Management Object Model\n#        This controls whether or not the MOM is enabled. By default it is turned on, but if you\n#        don't want it you can turn it off. Valid values are \"enabled\" and \"disabled\"\n#\n# portico.mom = enabled\n\n# (2.2) Save/Restore Data Files Directory\n#        This specifies the path to the directory where federate save/restore data files are stored.\n#        By default, this is the \"savedata\" directory relative to the directory that the federate\n#        was launched from. Any valid operating system path can be specified, as long as it is\n#        writeable by the operating system user under which the federate is executing\n#\n# portico.saveDirectory = ./savedata\n\n# (2.3) Unsupported Methods Throw Exceptions\n#        Portico does not support all the RTIambassador methods in all interface versions. To alert\n#        users to situations where a method is called that isn't support, Portico will log a warning\n#        and take no action. This is often a non-fatal action, but in some situations it may cause\n#        federates to stall or misbehave. As such, if this value is set to true, an RTIinternalError\n#        will be thrown when an unsupported method is called. By default, this is false.\n#\n# portico.unsupportedExceptions = false\n\n# (2.4) Object Names Negotiated With Federation\n#        When registering an object with a specific name, to ensure that name is unique, the\n#        federate much negotiate with the rest of the federation. This incurs a performance hit.\n#        By default, this negotiation is turned off. If you have problems with conflicting names,\n#        set this property to true. In the default mode (negotiation disabled) the RTI is not\n#        totally standards compliant, and conflicts can occur if federates try to register objects\n#        with the same name at the same time (if the requests are sufficiently spaced out in time,\n#        this problem shouldn't occur).\n#\n# portico.object.negotiateNames = false\n\n# (2.5) Unique Federate Names\n#        By default, Portico, like other RTIs, will ensure that all federates in a federation have\n#        unique names. However, in some situations this is not desirable (like running Portico with\n#        JSAF or VBS2). In this case, you can turn the unique name checking to false. When you do\n#        this, what happens is that when Portico sees a name conflict, rather than throwing an\n#        exception it will change the requested name from \"name\" to \"name (handle)\" thus making it\n#        unique. Default is true, set to false to turn unique name checking off.\n#\n# portico.uniqueFederateNames = true\n\n\n# ================================\n# 3. Advanced Options\n# ================================\n# These really shouldn't be changed unless you really know what you want\n\n# (3.1) Portico Communications Binding\n#        Defines the mechanism used by federates to communicate. Two valid options: jgroups, jvm.\n#\n#        jgroups: Use for LAN/WAN communications (default)\n#            jvm: Use when running many federates in separate threads within a single process.\n#\n# portico.connection = jgroups\n\n# (3.2) LRC Tick Timeout\n#        When a federate calls tick() and there is no work to do, the LRC will wait for a period of\n#        time to allow work to arrive before it returns. This is designed to avoid a busy-looping\n#        situation where people are calling tick in a loop while waiting for some event.\n#\n#        The period of time the LRC will wait is specified by this value (in *MILLISECONDS*).\n#        DEFAULT = 5\n#\n#        (NOTE) This does not apply to the tick(min,max) call (in that case, the LRC will wait\n#               for at most \"min\" seconds for work to arrive).\n#\n# portico.lrc.tt = 5\n\n\n# =========================================\n# 4. JGroups Network Settings\n# =========================================\n# Portico uses the JGroups library for its inter-federate network communication.\n# These settings control various parameters of the network layer and JGroups itself.\n\n# (4.1) JGroups UDP Address and Port\n#        Address and port to use for communication between federates.\n#        DEFAULT: 239.20.9.13:20913\n#\n# portico.jgroups.udp.address = 239.20.9.13\n# portico.jgroups.udp.port = 20913\n\n\n# (4.2) JGroups Bind Address\n#        The address/NIC Portico should use. Can use an IP address associated with a NIC, or\n#        one of the following special values:\n#\n#            GLOBAL: Pick a global IP address if available. If not, falls back to a SITE_LOCAL IP address.\n#        SITE_LOCAL: Picks a site local (non routable) IP address, e.g. from the 192.168.0.0 or 10.0.0.0 address range.\n#        LINK_LOCAL: Picks a link-local IP address, from 169.254.1.0 through 169.254.254.255.\n#      NON_LOOPBACK: Picks any non loopback address.\n#          LOOPBACK: Pick a loopback address, e.g. 127.0.0.1.\n#   match-interface: Pick an address which matches a pattern against the interface name, e.g. match-interface:eth.*\n#     match-address: Pick an address which matches a pattern against the host address, e.g. match-address:192.168.*\n#        match-host: Pick an address which matches a pattern against the host name, e.g. match-host:linux.*\n#\n#        DEFAULT: SITE_LOCAL\n#\nportico.jgroups.udp.bindAddress = <%= bindAddress%>\n\n# (4.3) JGroups UDP Sent/Receive Buffer Size\n#        Incoming/Outgoing buffer sizes. Default receive buffer is quite large to allow ample\n#        space on fast networks and avoid dropped packets.\n#\n# portico.jgroups.udp.receiveBuffer = 25M\n# portico.jgroups.udp.sendBuffer = 640K\n\n\n# (4.4) JGroups Bundling Support\n#         If you are sending lots of smaller messages, higher overall throughput can be obtained by\n#         bundling them together into a fewer number of larger messages. However, doing so comes at\n#         the cost of latency. Messages are buffered until either the timeout period (milliseconds)\n#         is reached, or the total size of the messages exceeds the specified threshold. Bundling\n#         is enabled by default. For latency-critical tasks, disable it or reduce the max-timeout.\n#\n# portico.jgroups.bundling = true\n# portico.jgroups.bundling.maxSize = 64K\n# portico.jgroups.bundling.maxTime = 30\n\n\n# (4.5) JGroups Flow Control\n#         Flow control is used to rate limit transmission so that slow receivers don't get overrun,\n#         causing them to drop messages and requiring expensive retransmission.\n#\n#         This value sets the maximum number of bytes that can be sent by a federate before it\n#         needs to receive more credits from other cluster members. These credits are not sent\n#         until the other federates have processed enough of the prior sent messages. The ratio\n#         setting defines how far through its current credits a sender can get before it should\n#         issue a request for more.\n#\n#         Setting the credit limit higher will allow a federate to send more messages before it\n#         gets blocked. Consider adjusting this value in conjunction with the buffer sizes, as\n#         they will dictate storage capacity on the sender side.\n#\n#         Note: If you start experiencing unstable behaviour, turn this value down. Flow control\n#               can be sensitive to the number of messages you try to send out in a hurry. If\n#               bundling is enabled, you can use a higher value because although you are sending\n#               more messages, the actual number hitting the network is smaller.\n#\n# portico.jgroups.flow.credits = 2M\n# portico.jgroups.flow.threshold = 0.4\n\n\n# (4.6) Packet Fragmentation Size\n#         Messages larger than this size will be broken down into smaller ones for transmission,\n#         reducing potentially lengthy delays retransmitting whole large messages when a single\n#         datagram is lost.\n#         Note: The max bundling size must be greater than this value.\n#\n# portico.jgroups.frag.size = 60K\n\n\n# (4.7) JGroups Traffic Auditing\n#         If this option is enabled a special log file will be produced for each federate listing\n#         the messages it has sent and received, along with their size and other useful details.\n#         This information can be used to make judgements about network config (such as bundling\n#         limits) or to just see what is happening in the federation at a network level.\n#\n#         The audit files are placed in the logs directory (see sec 1.1) with the name:\n#         \"audit-FEDERATENAME.log\"\n#\n#         If the auditor is enabled you can specify a detail level to control what is logged.\n#         When set to \"full\", each message will be logged with its specific details. (default)\n#         When set to \"summary\", only the summary tables will be printed\n#\n# portico.jgroups.auditor.enabled = false\n# portico.jgroups.auditor.details = full\n\n# (4.8) JGroups Traffic Audit Filtering\n#         Federates can generate a lot of messages. Sometimes you really just want to zero in\n#         on a particular type of message, or messages for a particular FOM type. These filters\n#         let you do that. These filters work in combination. For example, consider the following:\n#             - action  = sent\n#             - type    = UpdateAttributes\n#             - fomtype = Lifeform, GroundVehicle\n#\n#         Given this, only attribute updates for the FOM classes \"Lifeform\" and \"GroundVehicle\"\n#         that the local federate sends will be logged. Leaving a value empty, or using the\n#         keyword \"all\" will cause no filtering for that type to be applied.\n#\n#         NOTE: If the detail level is set to \"summary\", -no- individual messages will be logged,\n#               regardless of the filter settings.\n#         \n# portico.jgroups.auditor.filter.direction = \n# portico.jgroups.auditor.filter.message   = \n# portico.jgroups.auditor.filter.fomtype   = \n\n# =========================================\n# 5. WAN Connection Options\n# =========================================\n\n# (5.1) WAN Mode Enable/Disable\n#       If true, WAN mode will be enabled and this federate will act as both a\n#       local participant, and also as a bridge for all the local federates.\n#       Messages exchanged on the local JGroups channel will be forwarded to a\n#       central router (see 5.2) to be reflected out to other sites. Messagest\n#       received from the router will be pushed out to the local JGroups channel\n#       so everyone here can process them.\n#\n#       Note that this mode does not support bundling. If enabled in the RID, it\n#       will be active on the local JGroups network, but ignored for the WAN.\n#\n#       Note: Router must be running before federate startup. If not - federates\n#             will fail to start.\n#\n#       Default: false\n#       \n# portico.wan.enabled = false\n\n# (5.2) Router Address/Port\n#       Specifies the address and port of the WAN router to use. Note that the\n#       syntax is \"address:port\".\n#\n#       Default: 127.0.0.1:23114\n#\n# portico.wan.router = 127.0.0.1:23114\n\n# (5.2) Enable / Disable Bundling\n#       Bundling enables higher throughput by grouping together a number of\n#       smaller messages and sending them as one. This makes much more efficient\n#       use of the network and provides considerable improvements to throughput\n#       at a minor cost to latency.\n#\n#       If enabled, the subsequent options will control how it is applied.\n#\n#       Default: true\n#\n# portico.wan.bundle.enabled = true\n\n# (5.3) Max Bundle Size\n#       Messages sent over the WAN will be grouped into bundles and sents as\n#       a batch when their total size exceeds this value. Specify a size with\n#       a suffix of 'b', 'k' or 'm' (or 'g' if you dare!)\n#\n#       Default: 64k\n#\n# portico.wan.bundle.maxsize = 64K\n\n# (5.4) Max Bundle Timeout\n#       The maximum amount of time we will hold messages in the bundler for while\n#       waiting for more messages to arrive and bundle together. From the time that\n#       a message is received, the bundler will hold it for no longer than this\n#       value (specified in milliseconds).\n#\n#       Default: 20\n#\n# portico.wan.bundle.timeout = 20\n\n\n# =========================================\n# A51. Undocumented Settings\n# =========================================\n# This section is a catch-all of settings we use for internal work, and infrequently.\n# Their specific usecase and function is undocumented as they are not intended for general use.\n# portico.container.loglevel = OFF\n# portico.jgroups.loglevel = OFF\n# portico.jgroups.timeout = 1000\n",
    "common/run.sh.ejs": "<% /*\ninput properties\n----------------\nclassname  string\njarfile    string\n\nused in\n-------\nGridLabFederate.js\nLabVIEWFederate.js\nTRNSYSFederate.js\n\n*/ -%>\n#!/bin/bash\nconfigFile=conf/<%=classname%>.json\nif [ $# -eq 1 ] && [ -f $1 ]; then\n    configFile=$1\nfi\n\necho using the file $configFile\njava -Djava.net.preferIPv4Stack=true -Dlog4j.configurationFile=conf/log4j2.xml -jar <%=jarfile%> $configFile\n",
    "cpp/class.cpp.ejs": "<% /*\ninput properties\n----------------\nalldatamembers         array\ncodeclassname          string\ncppjavaArgumentTypeMap object not used here\ncppjavaTypeMap         object not used here\ndatamembers            array\nhlaclassname           string\nisc2winteractionroot   boolean\nisinteraction          boolean\nparentclassname        string\nTEMPLATES              object\n\nused in\n-------\nCppRTI.js\n\nThis also uses ejs, but apparently it is available without being passed in.\n\n*/ -%>\n#include \"rti/<%=codeclassname%>.hpp\"\n\n<% /*classcommon(...)*/ -%>\n<%- ejs.render(TEMPLATES[\"cpp/classcommon.cpp.ejs\"], {\n                isinteraction: isinteraction,\n                codeclassname: codeclassname,\n                parentclassname: parentclassname,\n                hlaclassname: hlaclassname,\n                datamembers: datamembers,\n                alldatamembers: alldatamembers\n}) -%>\n<% if(isc2winteractionroot){ -%>\n\nvoid C2WInteractionRoot::sendInteraction( RTI::RTIambassador *rti, double time ) {\n    if ( get_sourceFed().empty() || get_originFed().empty() ) {\n        throw C2WException( \"C2WInteractionRoot::sendInteraction:  source and/or origin federate not specified.\" );\n    }\n    Super::sendInteraction( rti, time );\n}\n\nvoid C2WInteractionRoot::sendInteraction( RTI::RTIambassador *rti ) {\n    if ( get_sourceFed().empty() || get_originFed().empty() ) {\n        throw C2WException( \"C2WInteractionRoot::sendInteraction:  source and/or origin federate not specified.\" );\n    }\n    Super::sendInteraction( rti );\n}\n<% } -%>\n<% if(!isinteraction){ -%>\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\n\n<%=codeclassname%>::AttributeHandleValuePairSetSP <%=codeclassname%>::createDatamemberHandleValuePairSet( bool force ) {\n    AttributeHandleValuePairSetSP datamembers = AttributeHandleValuePairSetSP(RTI::AttributeSetFactory::create(<%=alldatamembers.length%>) );\n    std::string stringConversion;\n    bool isPublished;\n<% /*alldatamembers:{ d |<supplied_attribute(codeclassname=codeclassname,datamember=d)>}*/ -%>\n<% alldatamembers.forEach(function(datamember){ -%>\n    isPublished = ( m_publishedAttributeNames.find( \"<%=datamember.name%>\" ) != m_publishedAttributeNames.end() );\n    if ( isPublished && _<%=datamember.name%>.shouldBeUpdated(force) ) {\n        stringConversion = static_cast< std::string >( TypeMedley(get_<%=datamember.name%>() ) );\n        datamembers->add( get_<%=datamember.name%>_handle(), stringConversion.c_str(), stringConversion.size() );\n        _<%=datamember.name%>.setHasBeenUpdated();\n        }\n<% }); -%>\n    return datamembers;\n}\n\nboost::unordered_set< std::string > <%=codeclassname%>::m_publishedAttributeNames;\n<% } -%>\n<% } -%>\n",
    "cpp/class.hpp.ejs": "<% /*\ninput properties\n----------------\nalldatamembers         array\nclassname              string\ncodeclassname          string\ncppjavaArgumentTypeMap object\ncppjavaTypeMap         object\ndatamembers            array\nhlaclassname           string\nisc2winteractionroot   boolean\nisinteraction          boolean\nparentclassname        string\nTEMPLATES              object\n\nused in\n-------\nCppRTI.js\n\nThis also uses ejs, but apparently ejs is available without being passed in.\n\n*/ -%>\n\n/*\n * Copyright (c) 2008, Institute for Software Integrated Systems,\n * Vanderbilt University\n * All rights reserved.\n *\n * Permission to use, copy, modify, and distribute this software and its\n * documentation for any purpose, without fee, and without written agreement is\n * hereby granted, provided that the above copyright notice, the following\n * two paragraphs and the author appear in all copies of this software.\n *\n * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\n * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT\n * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n *\n */\n\n/*\n *     NOTE:  ALL \"if\" STATEMENTS IN THIS CODE THAT HAD THE FORM:\n *\n *  if (condition) statement;\n *\n *    OR\n *\n *  if (condition) statement1;\n *  else           statement2;\n *\n *  HAVE BEEN CONVERTED TO THE FORMS:\n *\n *  if (condition) {\n *        statement;\n *    }\n *\n *    AND\n *\n *  if (condition) {\n *        statement1;\n *    } else {\n *        statement2;\n *    }\n *\n * RESPECTIVELY.  THIS IS BECAUSE THE OMNET DEBUGGER APPEARS TO HAVE\n * A PROBLEM WITH THE NON-BRACED FORMS OF THE IF STATEMENT.\n *     *PLEASE* DO NOT CHANGE IT BACK.\n *  -- H.S.N.\n *\n */\n\n#ifndef _<%=codeclassname%>_CLASS\n#define _<%=codeclassname%>_CLASS\n\n#include \"<%=parentclassname%>.hpp\"\n#include \"C2WException.hpp\"\n<% if(!isinteraction){ -%>\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\n\n#include <boost/unordered_set.hpp>\n<% }} -%>\n\nclass <%=codeclassname%> : public <%=parentclassname%> {\npublic:\n    typedef <%=parentclassname%> Super;\n    typedef boost::shared_ptr< <%=codeclassname%> > SP;\n\n    static StringVector get_<%=isinteraction?\"parameter\":\"attribute\"%>_names() {\n        return getDatamemberNames();\n    }\n\n    static StringVector get_all_<%=isinteraction?\"parameter\":\"attribute\"%>_names() {\n        return getAllDatamemberNames();\n    }\n\n    <%=codeclassname%>( void ) { }\n\n    static SP create( void ) { return SP( new <%=codeclassname%> ); }\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\n\nprivate:\n<% if(!isinteraction){ -%>\n    static boost::unordered_set< std::string > m_publishedAttributeNames;\n\n<% } -%>\n<% /*alldatamembers:handle()*/ -%>\n<% alldatamembers.forEach(function(datamember){ -%>\n    static int &get_<%=datamember.name%>_handle_var( void ) {\n        static int <%=datamember.name%>_handle;\n        return <%=datamember.name%>_handle;\n    }\n\n<% }); -%>\npublic:\n<% /*alldatamembers:gethandle()*/ -%>\n<% alldatamembers.forEach(function(datamember){ -%>\n    static int get_<%=datamember.name%>_handle( void ) { return get_<%=datamember.name%>_handle_var(); }\n<% }); -%>\n<% } -%>\n\n<% /*classcommon(...)*/ -%>\n<%- ejs.render(TEMPLATES[\"cpp/classcommon.hpp.ejs\"], {\n        alldatamembers: alldatamembers,\n        classname: codeclassname,\n        datamembers: datamembers,\n        isinteraction: isinteraction,\n        parentclassname: parentclassname\n}) -%>\n<% if(isc2winteractionroot){ -%>\n\npublic:\n    void sendInteraction( RTI::RTIambassador *rti, double time );\n    void sendInteraction( RTI::RTIambassador *rti );\n<% } -%>\n<% if(isinteraction){ -%>\n<% if(datamembers && datamembers.length > 0){ -%>\n\nprivate:\n<% /*datamembers:interactionmembers()*/ -%>\n<% datamembers.forEach(function(datamember){ -%>\n    <%- cppjavaTypeMap[datamember.parameterType] %> _<%=datamember.name%>;\n<% }); -%>\n\npublic:\n<% /*datamembers:interactiongetters()*/ -%>\n<% datamembers.forEach(function(datamember){ -%>\n    void set_<%=datamember.name%>( <%- cppjavaArgumentTypeMap[datamember.parameterType] %> <%=datamember.name%> ) { _<%=datamember.name%> = <%=datamember.name%>; }\n\n    <%- cppjavaArgumentTypeMap[datamember.parameterType] %> get_<%=datamember.name%>( void ) const { return _<%=datamember.name%>; }\n\n<% }); -%>\n<% } -%>\n<% }else{ -%>\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\n\npublic:\n<% alldatamembers.forEach(function(attribute){ -%>\n<% /*alldatamembers:{ a |<publish(codeclassname=codeclassname,attribute=a)> }*/ -%>\n    static void publish_<%=attribute.name%>( void ) {\n        getPublishAttributeNameVector().push_back( \"<%=attribute.name%>\" );\n        m_publishedAttributeNames.emplace( \"<%=attribute.name%>\" );\n    }\n\n    static void unpublish_<%=attribute.name%>( void ) {\n        getPublishAttributeNameVector().erase( std::remove( getPublishAttributeNameVector().begin(), getPublishAttributeNameVector().end(), \"<%=attribute.name%>\" ), getPublishAttributeNameVector().end() );\n        m_publishedAttributeNames.erase( \"<%=attribute.name%>\" );\n    }\n\n<% /*alldatamembers:{ a |<subscribe(codeclassname=codeclassname,attribute=a)> }*/ -%>\n    static void subscribe_<%=attribute.name%>( void ) {\n        getSubscribeAttributeNameVector().push_back( \"<%=attribute.name%>\" );\n    }\n\n    static void unsubscribe_<%=attribute.name%>(void ) {\n        getSubscribeAttributeNameVector().erase( std::remove( getSubscribeAttributeNameVector().begin(), getSubscribeAttributeNameVector().end(), \"<%=attribute.name%>\" ), getSubscribeAttributeNameVector().end() );\n    }\n\n<% }); -%>\nprotected:\n<% /*datamembers:objectmembers()*/ -%>\n<% datamembers.forEach(function(datamember){ -%>\n    Attribute< int, <%- cppjavaTypeMap[datamember.parameterType] %> > _<%=datamember.name%>;\n<% }); -%>\n\npublic:\n<% datamembers.forEach(function(datamember){ -%>\n<% /*datamembers:objectsetters()*/ -%>\n    void set_<%=datamember.name%>( <%- cppjavaArgumentTypeMap[datamember.parameterType] %> <%=datamember.name%> ) {\n        _<%=datamember.name%>.setValue( <%=datamember.name%> );\n        _<%=datamember.name%>.setTime( getTime() );\n    }\n\n<% /*datamembers:objectgetters()*/ -%>\n    <%- cppjavaArgumentTypeMap[datamember.parameterType] %> get_<%=datamember.name%>( void ) const {\n        return _<%=datamember.name%>.getValue();\n    }\n\n<% /*datamembers:objecttimegetters()*/ -%>\n    double get_<%=datamember.name%>_time( void ) {\n        return _<%=datamember.name%>.getTime();\n    }\n\n<% }); -%>\n<% } -%>\n<% } -%>\n    <%=codeclassname%>( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap ) : Super( datamemberMap ) { }\n\n    <%=codeclassname%>( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap, const RTIfedTime &logicalTime ) : Super( datamemberMap, logicalTime ) { }\n<% if(datamembers && datamembers.length > 0){ -%>\n\npublic:\n    TypeMedley get<%=isinteraction?\"Parameter\":\"Attribute\"%>( const std::string &datamemberName ) const {\n<% /*first(datamembers):startgetbyname()*/ -%>\n<% for(var i = 0; i<datamembers.length; i++ ){ -%>\n<%= i == 0  ? '        if' : ' else if' %> ( \"<%=datamembers[i].name%>\" == datamemberName ) {\n            return TypeMedley( get_<%=datamembers[i].name%>() );\n        }<%}%> else {\n            return Super::get<%=isinteraction?\"Parameter\":\"Attribute\"%>( datamemberName );\n        }\n    }\n\nprotected:\n    virtual bool set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( const std::string &datamemberName, const std::string &val ) {\n        bool retval = true;\n<% /*first(datamembers):startifstring()*/ -%>\n<% for(var i = 0; i<datamembers.length; i++ ){ -%>\n<%= i == 0  ? '        if' : ' else if'%> ( \"<%=datamembers[i].name%>\" == datamemberName ) {\n            set_<%=datamembers[i].name%>(  TypeMedley( val )  );\n        }<%}%> else {\n            retval = Super::set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( datamemberName, val );\n        }\n\n        return retval;\n    }\n\n    virtual bool set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( const std::string &datamemberName, const TypeMedley &val ) {\n        bool retval = true;\n<% /*first(datamembers):startifname()*/ -%>\n<% for(var i = 0; i<datamembers.length; i++ ){ -%>\n<%= i == 0  ? '        if' : ' else if'%> ( \"<%=datamembers[i].name%>\" == datamemberName ) {\n            set_<%=datamembers[i].name%>( val );\n        }<%}%> else {\n            retval = Super::set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( datamemberName, val );\n        }\n\n        return retval;\n    }\n<% if(!isinteraction){ -%>\n\n    virtual AttributeHandleValuePairSetSP createDatamemberHandleValuePairSet( bool force );\n<% } -%>\n<% } -%>\n};\n\ntypedef <%=codeclassname%>::SP <%=codeclassname%>SP;\n\nstatic bool call_<%=codeclassname%>_static_init = <%=codeclassname%>::static_init();\n\nstd::ostream &operator<<( std::ostream &os, <%=codeclassname%>::SP entitySP );\nstd::ostream &operator<<( std::ostream &os, const <%=codeclassname%> &entity );\n\n#endif\n",
    "cpp/classcommon.cpp.ejs": "<% /*\ninput properties\n----------------\nalldatamembers\ncodeclassname\ndatamembers\nhlaclassname\nisinteraction\nparentclassname\n\nused in\n-------\nclass.cpp.ejs\nclassroot.cpp.ejs\n\n*/ -%>\nvoid <%=codeclassname%>::init( RTI::RTIambassador *rti ) {\n    static bool isInitialized = false;\n    if ( isInitialized ) {\n        return;\n    }\n    isInitialized = true;\n<% if(parentclassname){ -%>\n\n    <%=parentclassname%>::init( rti );\n<% } -%>\n\n    bool isNotInitialized = true;\n    while ( isNotInitialized ) {\n        try {\n            getHandle() = rti->get<%=isinteraction?\"Interaction\":\"Object\"%>ClassHandle( \"<%=hlaclassname%>\" );\n            isNotInitialized = false;\n        } catch ( RTI::FederateNotExecutionMember & ) {\n            std::cerr << getInitErrorMessage() << \"Federate Not Execution Member\" << std::endl;\n            return;\n        } catch ( RTI::NameNotFound & ) {\n            std::cerr << getInitErrorMessage() << \"Name Not Found\" << std::endl;\n            return;\n        } catch ( ... ) {\n            std::cerr << getInitErrorMessage() << \"Exception caught ... retry\" << std::endl;\n        }\n    }\n    getClassNameHandleMap().insert(  std::make_pair( \"<%=codeclassname%>\", get_handle() )  );\n    getClassHandleNameMap().insert(  std::make_pair( get_handle(), \"<%=codeclassname%>\" )  );\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\n    isNotInitialized = true;\n    while ( isNotInitialized ) {\n        try {\n<% /*alldatamembers:handle_init()*/ -%>\n<% alldatamembers.forEach(function(datamember){ -%>\n            get_<%=datamember.name%>_handle_var() = rti->get<%=isinteraction?\"Parameter\":\"Attribute\"%>Handle( \"<%=datamember.name%>\", get_handle() );\n<% }); -%>\n            isNotInitialized = false;\n        } catch ( RTI::FederateNotExecutionMember & ) {\n            std::cerr << getInitErrorMessage() << \"Federate Not Execution Member\" << std::endl;\n            return;\n        } catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined & ) {\n            std::cerr << getInitErrorMessage() << \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" << std::endl;\n            return;\n        } catch ( RTI::NameNotFound & ) {\n            std::cerr << getInitErrorMessage() << \"Name Not Found\" << std::endl;\n            return;\n        } catch ( ... ) {\n            std::cerr << getInitErrorMessage() << \"Exception caught ... retry\" << std::endl;\n        }\n    }\n<% alldatamembers.forEach(function(datamember){ -%>\n<% /*alldatamembers: { d |<initDatamemberNameHandleMap(codeclassname=codeclassname,datamember=d)>}*/ -%>\n    getDatamemberNameHandleMap().insert(  std::make_pair( \"<%=codeclassname%>.<%=datamember.name%>\", get_<%=datamember.name%>_handle() )  );\n<% /*alldatamembers:initDatamemberHandleNameMap()*/ -%>\n    getDatamemberHandleNameMap().insert(  std::make_pair( get_<%=datamember.name%>_handle(), \"<%=datamember.name%>\" )  );\n<% /*alldatamembers:initDatamemberTypeMap()*/ -%>\n    getDatamemberTypeMap().insert( std::make_pair(\"<%=datamember.name%>\", \"<%=datamember.parameterType%>\") );\n<% }); -%>\n<% } -%>\n}\n\nvoid <%=codeclassname%>::publish( RTI::RTIambassador *rti ) {\n    if ( getIsPublished() ) {\n        return;\n    }\n    init( rti );\n<% if(!isinteraction){ -%>\n    getPublishedAttributeHandleSet_var().empty();\n    for ( StringVector::iterator stsItr = getPublishAttributeNameVector().begin() ;\n    stsItr != getPublishAttributeNameVector().end() ;\n    (void)++stsItr ) {\n        try {\n            getPublishedAttributeHandleSet_var().add(  getDatamemberNameHandleMap().find( \"<%=codeclassname%>.\" + *stsItr )->second  );\n        } catch ( ... ) {\n            std::cerr << getPublishErrorMessage() << \"Could not publish \\\"\" << *stsItr + \"\\\" attribute.\" << std::endl;\n        }\n    }\n<% } -%>\n    bool isNotPublished = true;\n    while ( isNotPublished ) {\n        try {\n            rti->publish<%=isinteraction?\"Interaction\":\"Object\"%>Class( get_handle()<% if(!isinteraction){ %>, getPublishedAttributeHandleSet_var()<%}%> );\n            isNotPublished = false;\n        } catch ( RTI::FederateNotExecutionMember & ) {\n            std::cerr << getPublishErrorMessage() << \"Federate Not Execution Member\" << std::endl;\n            return;\n        } catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined & ) {\n            std::cerr << getPublishErrorMessage() << \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" << std::endl;\n            return;\n        } catch ( ... ) {\n            std::cerr << getPublishErrorMessage() << \"Exception caught ... retry\" << std::endl;\n        }\n    }\n    getIsPublished() = true;\n}\n\nvoid <%=codeclassname%>::unpublish( RTI::RTIambassador *rti ) {\n    if ( !getIsPublished() ) {\n        return;\n    }\n    init( rti );\n    bool isNotUnpublished = true;\n    while ( isNotUnpublished ) {\n        try {\n            rti->unpublish<%=isinteraction?\"Interaction\":\"Object\"%>Class( get_handle() );\n            isNotUnpublished = false;\n        } catch ( RTI::FederateNotExecutionMember & ) {\n            std::cerr << getUnpublishErrorMessage() + \"Federate Not Execution Member\" << std::endl;\n            return;\n        } catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined & ) {\n            std::cerr << getUnpublishErrorMessage() + \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" << std::endl;\n            return;\n        } catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotPublished & ) {\n            std::cerr << getUnpublishErrorMessage() + \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Published\" << std::endl;\n            return;\n        } catch ( ... ) {\n            std::cerr << getUnpublishErrorMessage() << \"Exception caught ... retry\" << std::endl;\n        }\n    }\n    getIsPublished() = false;\n}\n\nvoid <%=codeclassname%>::subscribe( RTI::RTIambassador *rti ) {\n    if ( getIsSubscribed() ) {\n        return;\n    }\n    init( rti );\n<% if(!isinteraction){ -%>\n    getSubscribedAttributeHandleSet_var().empty();\n    for ( StringVector::iterator sstItr = getSubscribeAttributeNameVector().begin() ;\n          sstItr != getSubscribeAttributeNameVector().end() ;\n          (void)++sstItr ) {\n        try {\n            getSubscribedAttributeHandleSet_var().add(  getDatamemberNameHandleMap().find( \"<%=codeclassname%>.\" + *sstItr )->second  );\n        } catch ( ... ) {\n            std::cerr << getSubscribeErrorMessage() << \"Could not subscribe to \\\"\" << *sstItr << \"\\\" attribute.\" << std::endl;\n        }\n    }\n<% } -%>\n\n    bool isNotSubscribed = true;\n    while ( isNotSubscribed ) {\n        try {\n            rti->subscribe<% if(isinteraction){ %>InteractionClass( get_handle() )<% }else{ %>ObjectClassAttributes( get_handle(), getSubscribedAttributeHandleSet_var() )<%}%>;\n            isNotSubscribed = false;\n        } catch ( RTI::FederateNotExecutionMember & ) {\n            std::cerr << getSubscribeErrorMessage() << \"Federate Not Execution Member\" << std::endl;\n            return;\n        } catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined & ) {\n            std::cerr << getSubscribeErrorMessage() << \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" << std::endl;\n            return;\n        } catch ( ... ) {\n            std::cerr << getSubscribeErrorMessage() << \"Exception caught ... retry\" << std::endl;\n        }\n    }\n    getIsSubscribed() = true;\n}\n\nvoid <%=codeclassname%>::unsubscribe( RTI::RTIambassador *rti ) {\n    if ( !getIsSubscribed() ) {\n        return;\n    }\n    init( rti );\n    bool isNotUnsubscribed = true;\n    while ( isNotUnsubscribed ) {\n        try {\n            rti->unsubscribe<%=isinteraction?\"Interaction\":\"Object\"%>Class( get_handle() );\n            isNotUnsubscribed = false;\n        } catch ( RTI::FederateNotExecutionMember & ) {\n            std::cerr << getUnsubscribeErrorMessage() << \"Federate Not Execution Member\" << std::endl;\n            return;\n        } catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined & ) {\n            std::cerr << getUnsubscribeErrorMessage() << \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" << std::endl;\n            return;\n        } catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotSubscribed & ) {\n            std::cerr << getUnsubscribeErrorMessage() << \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Subscribed\" << std::endl;\n            return;\n        } catch ( ... ) {\n            std::cerr << getUnsubscribeErrorMessage() << \"Exception caught ... retry\" << std::endl;\n        }\n    }\n    getIsSubscribed() = false;\n}\n\nbool <%=codeclassname%>::static_init( void ) {\n    static bool isInitialized = false;\n    if ( isInitialized ) {\n        return true;\n    }\n    isInitialized = true;\n    getClassNameSet().insert( \"<%=codeclassname%>\" );\n    getClassNameFactoryMap().insert(  std::make_pair( \"<%=codeclassname%>\", &<%=codeclassname%>::factory )  );\n    getClassNamePublishMap().insert(   std::make_pair(  \"<%=codeclassname%>\", (PubsubFunctionPtr)( &<%=codeclassname%>::publish )  )   );\n    getClassNameUnpublishMap().insert(   std::make_pair(  \"<%=codeclassname%>\", (PubsubFunctionPtr)( &<%=codeclassname%>::unpublish )  )   );\n    getClassNameSubscribeMap().insert(   std::make_pair(  \"<%=codeclassname%>\", (PubsubFunctionPtr)( &<%=codeclassname%>::subscribe )  )   );\n    getClassNameUnsubscribeMap().insert(   std::make_pair(  \"<%=codeclassname%>\", (PubsubFunctionPtr)( &<%=codeclassname%>::unsubscribe )  )   );\n    getDatamemberClassNameVectorPtrMap().insert(  std::make_pair( \"<%=codeclassname%>\", &getDatamemberNames() )  );\n    getAllDatamemberClassNameVectorPtrMap().insert(  std::make_pair( \"<%=codeclassname%>\", &getAllDatamemberNames() )  );\n<% if(datamembers && datamembers.length > 0){ -%>\n<% /*datamembers:initDatamemberNameSet()*/ -%>\n<% datamembers.forEach(function(datamember){ -%>\n<% if(!datamember.hidden && !datamember.inherited){ -%>\n    getDatamemberNames().push_back( \"<%=datamember.name%>\" );\n<% } -%>\n<% }); -%>\n<% } -%>\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\n<% /*alldatamembers:initAllDatamemberNameSet()*/ -%>\n<% alldatamembers.forEach(function(datamember){ -%>\n    getAllDatamemberNames().push_back( \"<%=datamember.name%>\" );\n<% }); -%>\n<% } -%>\n<% if(!isinteraction){ -%>\n    getClassNamePublishAttributeNameVectorPtrMap().insert(  std::make_pair( \"<%=codeclassname%>\", &getPublishAttributeNameVector() )  );\n    getClassNameSubscribeAttributeNameVectorPtrMap().insert(  std::make_pair( \"<%=codeclassname%>\", &getSubscribeAttributeNameVector() )  );\n    getClassNamePublishedAttributesPtrMap().insert(  std::make_pair( \"<%=codeclassname%>\", &getPublishedAttributeHandleSet_var() )  );\n    getClassNameSubscribedAttributesPtrMap().insert( std::make_pair( \"<%=codeclassname%>\", &getSubscribedAttributeHandleSet_var() )  );\n<% } -%>\n    return true;\n}\n\nstd::ostream &operator<<( std::ostream &os, <%=codeclassname%>::SP entitySP ) {\n    return os << *entitySP;\n}\n\nstd::ostream &operator<<( std::ostream &os, const <%=codeclassname%> &entity ) {\n    return os << \"<%=codeclassname%>(\"\n<% alldatamembers.forEach(function(datamember,i){ -%>\n             <% if( i > 0){%> << \", \"<%}%> << \"<%=datamember.name%>:\" << entity.get_<%=datamember.name%>()\n<% }); -%>\n            << \")\";\n}\n",
    "cpp/classcommon.hpp.ejs": "<% /*\ninput properties\n----------------\nalldatamembers\nclassname\ndatamembers\nisinteraction\nparentclassname\n\nused in\n-------\nclass.hpp.ejs\nclassroot.hpp.ejs\n\n*/ -%>\nprivate:\n    static int &getHandle( void ) {\n        static int handle;\n        return handle;\n    }\n\npublic:\n    static int get_handle( void ) { return getHandle(); }\n    static std::string get_class_name( void ) { return \"<%=classname%>\"; }\n\nprivate:\n    static StringVector &getDatamemberNames( void ) {\n        static StringVector datamemberNames;\n        return datamemberNames;\n    }\n\n    static StringVector &getAllDatamemberNames( void ) {\n        static StringVector allDatamemberNames;\n        return allDatamemberNames;\n    }\n<% if(!isinteraction){ -%>\n\nprivate:\n    static RTI::AttributeHandleSet &getPublishedAttributeHandleSet_var( void ) {\n        static RTI::AttributeHandleSet *publishedAttributeHandleSetPtr = RTI::AttributeHandleSetFactory::create( <%= alldatamembers.length %> );\n        return *publishedAttributeHandleSetPtr;\n    }\n    static StringVector &getPublishAttributeNameVector( void ) {\n        static StringVector publishAttributeNameVector;\n        return publishAttributeNameVector;\n    }\n\n    static RTI::AttributeHandleSet &getSubscribedAttributeHandleSet_var( void ) {\n        static RTI::AttributeHandleSet *subscribedAttributeHandleSet = RTI::AttributeHandleSetFactory::create( <%= alldatamembers.length %> );\n        return *subscribedAttributeHandleSet;\n    }\n    static StringVector &getSubscribeAttributeNameVector( void ) {\n        static StringVector subscribeAttributeNameVector;\n        return subscribeAttributeNameVector;\n    }\n<% } -%>\n\nprivate:\n<% if(isinteraction){ -%>\n    static InteractionRoot::SP factory( void ) {\n        return InteractionRoot::SP( new <%=classname%>() );\n    }\n<% }else{ -%>\n    static ObjectRoot::SP factory( void ) {\n        return ObjectRoot::SP( new <%=classname%>() );\n    }\n<% } -%>\n\n    static std::string &getInitErrorMessage( void ) {\n        static std::string initErrorMessage( \"Error:  <%=classname%>:  could not initialize:  \" );\n        return initErrorMessage;\n    }\n\nprotected:\n    static void init( RTI::RTIambassador *rti );\n\nprivate:\n    static bool &getIsPublished( void ) {\n        static bool isPublished = false;\n        return isPublished;\n    }\n\n    static std::string &getPublishErrorMessage( void ) {\n        static std::string publishErrorMessage = \"Error:  <%=classname%>:  could not publish:  \";\n        return publishErrorMessage;\n    }\n\npublic:\n    static void publish( RTI::RTIambassador *rti );\n\nprivate:\n    static std::string &getUnpublishErrorMessage( void ) {\n        static std::string unpublishErrorMessage = \"Error:  <%=classname%>:  could not unpublish:  \";\n        return unpublishErrorMessage;\n    }\n\npublic:\n    static void unpublish( RTI::RTIambassador *rti );\n\nprivate:\n    static bool &getIsSubscribed( void ) {\n        static bool isSubscribed = false;\n        return isSubscribed;\n    }\n    static std::string &getSubscribeErrorMessage( void ) {\n        static std::string subscribedErrorMessage = \"Error:  <%=classname%>:  could not subscribe:  \";\n        return subscribedErrorMessage;\n    }\n\npublic:\n    static void subscribe( RTI::RTIambassador *rti );\n\nprivate:\n    static std::string getUnsubscribeErrorMessage( void ) {\n        static std::string unsubscribeErrorMessage = \"Error:  <%=classname%>:  could not unsubscribe:  \";\n        return unsubscribeErrorMessage;\n    }\n\npublic:\n    static void unsubscribe( RTI::RTIambassador *rti );\n\n    static bool static_init( void );\n\n    static bool match( int handle ) { return handle == get_handle(); }\n\n    virtual int getClassHandle( void ) const { return get_handle(); }\n    \n    virtual std::string getClassName( void ) const { return get_class_name(); }\n    \n    virtual StringVector get<%=isinteraction?\"Parameter\":\"Attribute\"%>Names( void ) const { return get_<%=isinteraction?\"parameter\":\"attribute\"%>_names(); }\n    \n    virtual StringVector getAll<%=isinteraction?\"Parameter\":\"Attribute\"%>Names( void ) const { return get_all_<%=isinteraction?\"parameter\":\"attribute\"%>_names(); }\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\n\n    virtual std::string get<%=isinteraction?\"Parameter\":\"Attribute\"%>Name( int datamemberHandle ) const {\n<% for(var i = 0; i<alldatamembers.length; i++ ){ -%>\n<%= i == 0 ? '        if' : ' else if'%> (datamemberHandle == get_<%=alldatamembers[i].name%>_handle()) {\n            return std::string(\"<%=alldatamembers[i].name%>\");\n        }<% } %> else {\n<% if(parentclassname){ -%>\n            return <%=parentclassname%>::get<%=isinteraction?\"Parameter\":\"Attribute\"%>Name(datamemberHandle);\n<% } else { -%>\n            return std::string();\n<% } -%>\n        }\n    }\n<% } -%>\n\n    virtual void publish<%=isinteraction?\"Interaction\":\"Object\"%>( RTI::RTIambassador *rti ) { publish( rti ); }\n\n    virtual void subscribe<%=isinteraction?\"Interaction\":\"Object\"%>( RTI::RTIambassador *rti ) { subscribe( rti ); }\n\n    virtual <%=isinteraction?\"Interaction\":\"Object\"%>Root::SP clone( void ) {\n        return <%=isinteraction?\"Interaction\":\"Object\"%>Root::SP(  new <%=classname%>( *this )  );\n    }\n<% if(!isinteraction){ -%>\n\n    virtual const RTI::AttributeHandleSet &getSubscribedAttributeHandleSet( void ) { return getSubscribedAttributeHandleSet_var(); }\n<% } -%>\n",
    "cpp/classroot.cpp.ejs": "<% /*\nTHIS IS THE ROOT CLASS OF EITHER THE INTERACTION OR OBJECT-CLASS HEIRARCHY\n(i.e. \"InteractionRoot\" OR \"ObjectRoot\")\n\ninput properties\n----------------\nisinteraction boolean\n\nused in\n-------\nCppRTI.js\n\nThis also uses ejs, but apparently ejs is available without being passed in.\n*/\n-%>\n<% var rootname = isinteraction ? \"InteractionRoot\" : \"ObjectRoot\"; -%>\n<% var create = isinteraction ? \"create_interaction\" : \"create_object\"; -%>\n<% var field = isinteraction ? \"Parameter\" : \"Attribute\"; -%>\n#include <boost/lexical_cast.hpp>\n#include \"<%=rootname%>.hpp\"\n\nC2WLogger* <%=rootname%>::_logger = &C2W_RTI_LOGGER_CLS::get_singleton();\n\n<%- ejs.render(TEMPLATES[\"cpp/classcommon.cpp.ejs\"],\n    {isinteraction: isinteraction,\n     classname: rootname,\n     parentclassname: \"\",\n     hlaclassname: rootname,\n     datamembers: [],\n     alldatamembers: []\n}) %>\n\n<% if(!isinteraction){ %>\nvoid ObjectRoot::publish( const std::string &className, const std::string &attributeName ) {\n    NameStringVectorPtrMap::iterator camItr = getClassNamePublishAttributeNameVectorPtrMap().find( className );\n    if ( camItr == getClassNamePublishAttributeNameVectorPtrMap().end() ) {\n        std::cerr << \"ERROR:  ObjectRoot.publish:  could not publish class \\\"\" << className << \"\\\" \\\"\" << attributeName << \"\\\" attribute.\" << std::endl;\n        return;\n    }\n    NameStringVectorPtrMap::iterator dnsItr = getAllDatamemberClassNameVectorPtrMap().find( className );\n    if ( dnsItr == getAllDatamemberClassNameVectorPtrMap().end() ) {\n        std::cerr << \"ERROR:  ObjectRoot.publish:  unexpected error:  no datamember vector for class \\\"\" << className << \"\\\"\" << std::endl;\n        return;\n    }\n    if (  std::find ( dnsItr->second->begin(), dnsItr->second->end(), attributeName ) == dnsItr->second->end()  ) {\n        std::cerr << \"ERROR:  ObjectRoot.publish:  no datamember named \\\"\" << attributeName << \"\\\" in class \\\"\" << className << \"\\\"\" << std::endl;\n        return;\n    }\n    camItr->second->push_back( attributeName );\n}\n\nvoid ObjectRoot::subscribe( const std::string &className, const std::string &attributeName ) {\n    NameStringVectorPtrMap::iterator camItr = getClassNameSubscribeAttributeNameVectorPtrMap().find( className );\n    if ( camItr == getClassNameSubscribeAttributeNameVectorPtrMap().end() ) {\n        std::cerr << \"ERROR:  ObjectRoot.subscribe:  could not subscribe class \\\"\" << className << \"\\\" \\\"\" << attributeName << \"\\\" attribute.\" << std::endl;\n        return;\n    }\n    NameStringVectorPtrMap::iterator dnsItr = getAllDatamemberClassNameVectorPtrMap().find( className );\n    if ( dnsItr == getAllDatamemberClassNameVectorPtrMap().end() ) {\n        std::cerr << \"ERROR:  ObjectRoot.subscribe:  unexpected error:  no datamember vector for class \\\"\" << className << \"\\\"\" << std::endl;\n        return;\n    }\n    if (  std::find ( dnsItr->second->begin(), dnsItr->second->end(), attributeName ) == dnsItr->second->end()  ) {\n        std::cerr << \"ERROR:  ObjectRoot.subscribe:  no datamember named \\\"\" << attributeName << \"\\\" in class \\\"\" << className << \"\\\"\" << std::endl;\n        return;\n    }\n    camItr->second->push_back( attributeName );\n}\n\n<%}%>\n\n<%=rootname%>::SP <%=rootname>::<%=create%>( int classHandle, const RTI::<%=field%>HandleValuePairSet &datamemberMap ) {\n    IntegerStringMap::iterator ismItr = getClassHandleNameMap().find( classHandle );\n    if ( ismItr == getClassHandleNameMap().end() ) {\n        return SP( (<%=rootname%> *)0 );\n    }\n    ClassNameFactoryMap::iterator cfmItr = getClassNameFactoryMap().find( ismItr->second );\n    if ( cfmItr == getClassNameFactoryMap().end() ) {\n        return SP( (<%=rootname%> *)0 );\n    }\n    SP sp = (*cfmItr->second)();\n    sp->set<%=field%>s( datamemberMap );\n    return sp;\n}\n\n<%=rootname%>::SP <%=rootname%>::<%=create%>( int classHandle, const RTI::<%=field%>HandleValuePairSet &datamemberMap, const RTIfedTime &dlc13FedTime ) {\n    IntegerStringMap::iterator ismItr = getClassHandleNameMap().find( classHandle );\n    if ( ismItr == getClassHandleNameMap().end() ) {\n        return SP( (<%=rootname%> *)0 );\n    }\n    ClassNameFactoryMap::iterator cfmItr = getClassNameFactoryMap().find( ismItr->second );\n    if ( cfmItr == getClassNameFactoryMap().end() ) {\n        return SP( (<%=rootname%> *)0 );\n    }\n    SP sp = (*cfmItr->second)();\n    sp->set<%=field%>s( datamemberMap );\n    sp->setTime( dlc13FedTime.getTime() );\n    return sp;\n}\n\n<% if(!isinteraction){ %>\nvoid ObjectRoot::requestUpdate( RTI::RTIambassador *rti ) {\n    bool requestNotSubmitted = true;\n    while ( requestNotSubmitted ) {\n        try {        \n            rti->requestObjectAttributeValueUpdate( getObjectHandle(), getSubscribedAttributeHandleSet_var() );\n            requestNotSubmitted = false;\n        } catch ( RTI::FederateNotExecutionMember & ) {\n            std::cerr << \"ERROR: \" << getClassName() << \"request for update failed:  Federate Not Execution Member\" << std::endl;\n            return;\n        } catch ( RTI::ObjectNotKnown & ) {\n            std::cerr << \"ERROR: \" << getClassName() << \"request for update failed:  Object Not Known\" << std::endl;\n            return;\n        } catch ( RTI::AttributeNotDefined & ) {\n            std::cerr << \"ERROR: \" << getClassName() << \"request for update failed:  Name Not Found\" << std::endl;\n            return;\n        } catch ( ... ) {\n            std::cerr << \"ERROR: \" << getClassName() << \"request for update failed:  Unknown Exception\" << std::endl;\n        }\n    }\n}\n<%} -%>\n\nvoid <%=rootname%>::set<%=field%>s( const RTI::<%=field%>HandleValuePairSet &datamemberMap ) {\n    int size = datamemberMap.size();\n    for ( int ix = 0 ; ix < size ; ++ix ) {\n        try {\n            static RTI::ULong valueLength;\n            char *value = datamemberMap.getValuePointer( ix, valueLength );\n            set<%=field%>(  datamemberMap.getHandle( ix ), std::string( value, valueLength )  );\n        } catch ( ... ) {\n            std::cerr << \"set<%=field%>s: Exception caught!\" << std::endl;\n        }\n    }\n}\n\n<% if(isinteraction){ %>\nvoid InteractionRoot::sendInteraction( RTI::RTIambassador *rti, double time ) {\n    bool interactionNotSent = true;\n    while ( interactionNotSent ) {\n        try {\n            ParameterHandleValuePairSetSP datamembers = createDatamemberHandleValuePairSet( 0 );\n            rti->sendInteraction(  getClassHandle(), *datamembers, RTIfedTime( time ), 0  );\n            createLog( time, true );\n            interactionNotSent = false;\n        } catch ( RTI::InteractionClassNotDefined & ) {\n            std::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Interaction Class Not Defined\" << std::endl;\n            return;\n        } catch ( RTI::InteractionClassNotPublished & ) {\n            std::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Interaction Class Not Published\" << std::endl;\n            return;\n        } catch ( RTI::InteractionParameterNotDefined & ) {\n            std::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Interaction Parameter Not Defined\" << std::endl;\n            return;\n        } catch ( RTI::InvalidFederationTime & ) {\n            std::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Invalid Federation Time\" << std::endl;\n            return;\n        } catch ( RTI::FederateNotExecutionMember & ) {\n            std::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Federate Not Execution Member\" << std::endl;\n            return;\n        } catch ( RTI::ConcurrentAccessAttempted & ) {\n            std::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  ConcurrentAccessAttempted\" << std::endl;\n            return;\n        } catch ( ... ) {\n            std::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Exception caught ... retry\" << std::endl;\n#ifdef _WIN32\n            Sleep( 500 );\n#else\n            usleep( 500000 );\n#endif\n        }\n    }\n}\n\nvoid InteractionRoot::sendInteraction( RTI::RTIambassador *rti ) {\n    bool interactionNotSent = true;\n    while ( interactionNotSent ) {\n        try {\n            ParameterHandleValuePairSetSP datamembers = createDatamemberHandleValuePairSet( 0 );\n            rti->sendInteraction(  getClassHandle(), *datamembers, 0  );\n            createLog( 0, true );\n        } catch ( RTI::InteractionClassNotDefined & ) {\n            std::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Interaction Class Not Defined\" << std::endl;\n            return;\n        } catch ( RTI::InteractionClassNotPublished & ) {\n            std::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Interaction Class Not Published\" << std::endl;\n            return;\n        } catch ( RTI::InteractionParameterNotDefined & ) {\n            std::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Interaction Parameter Not Defined\" << std::endl;\n            return;\n        } catch ( RTI::FederateNotExecutionMember & ) {\n            std::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Federate Not Execution Member\" << std::endl;\n            return;\n        } catch ( RTI::ConcurrentAccessAttempted & ) {\n            std::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  ConcurrentAccessAttempted\" << std::endl;\n            return;\n        } catch ( ... ) {\n            std::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Exception caught ... retry\" << std::endl;\n#ifdef _WIN32\n            Sleep( 500 );\n#else\n            usleep( 500000 );\n#endif\n        }\n    }\n}\n\nstd::string InteractionRoot::fedName = \"\";\nbool InteractionRoot::enablePubLog = false;\nbool InteractionRoot::enableSubLog = false;\nstd::string InteractionRoot::pubLogLevel = \"\";\nstd::string InteractionRoot::subLogLevel = \"\";\n\nvoid InteractionRoot::enablePublishLog( const std::string &interaction, const std::string &fed, const std::string &thislevel, const std::string &globallevel ) {\n    if ( globallevel.empty() ) {\n        return;\n    }\n    if (  _logger->getLogLevel( thislevel ) > _logger->getLogLevel( globallevel )  ) {\n        return;\n    }\n    fedName = fed;\n    enablePubLog = true;\n    pubLogLevel = thislevel;\n    _logger->addLog(interaction, fedName, true);\n}\n\nvoid InteractionRoot::enableSubscribeLog( const std::string &interaction, const std::string &fed, const std::string &thislevel, const std::string &globallevel ) {\n    if ( globallevel.empty() ) {\n        return;\n    }\n    if (  _logger->getLogLevel( thislevel ) > _logger->getLogLevel( globallevel )  ) {\n        return;\n    }\n    fedName = fed;\n    enableSubLog = true;\n    subLogLevel = thislevel;\n    _logger->addLog( interaction, fedName, false );\n}\n\nvoid InteractionRoot::createLog( double time, bool isPub ) {\n    if (  ( isPub && !enablePubLog ) || ( !isPub && !enableSubLog )  ) {\n        return;\n    }\n    std::string interactionId;\n    if ( isPub ) {\n        interactionId = \"pub_\" + getClassName();\n        if ( !fedName.empty() ) {\n            interactionId = fedName + \"_\" + interactionId;\n        }\n    } else {\n        interactionId = getClassName() + \"_sub\";\n        if ( !fedName.empty() ) {\n            interactionId += \"_\" + fedName;\n        }\n    }\n    _logger->addLog( interactionId, *this, time, pubLogLevel );\n}\n\n<%}else{ -%>\nvoid ObjectRoot::registerObject( RTI::RTIambassador *rti ) {\n    \n    while ( !_isRegistered ) {\n        try {\n            _object_handle = rti->registerObjectInstance( getClassHandle() );\n            _isRegistered = true;\n        } catch ( RTI::ObjectClassNotDefined & ) {\n            std::cerr << \"ERROR:  InteractionRoot::registerObject:  Object Class Not Defined\" << std::endl;\n            return;\n        } catch ( RTI::ObjectClassNotPublished & ) {\n            std::cerr << \"ERROR:  InteractionRoot::registerObject:  Object Class Not Published\" << std::endl;\n            return;\n        } catch ( RTI::FederateNotExecutionMember & ) {\n            std::cerr << \"ERROR:  InteractionRoot::registerObject:  Federate Not Execution Member\" << std::endl;\n            return;\n        } catch ( ... ) {\n            std::cerr << \"InteractionRoot::registerObject:  Exception caught ... retry\" << std::endl;\n        }\n    }\n}\n\nvoid ObjectRoot::unregisterObject( RTI::RTIambassador *rti ) {\n    while ( _isRegistered ) {\n        try {\n            rti->deleteObjectInstance( getObjectHandle(), 0 );\n            _isRegistered = false;\n        } catch ( RTI::ObjectNotKnown & ) {\n            std::cerr << \"ERROR:  InteractionRoot::unregisterObject:  Object Not Known\" << std::endl;\n            return;\n        } catch ( RTI::DeletePrivilegeNotHeld & ) {\n            std::cerr << \"ERROR:  InteractionRoot::unregisterObject:  Delete Privilege Not Held\" << std::endl;\n            return;\n        } catch ( RTI::FederateNotExecutionMember & ) {\n            std::cerr << \"ERROR:  InteractionRoot::unregisterObject:  Federate Not Execution Member\" << std::endl;\n            return;\n        } catch ( ... ) {\n            std::cerr << \"InteractionRoot::unregisterObject:  Exception caught ... retry\" << std::endl;\n        }\n    }\n}\n\nvoid ObjectRoot::updateAttributeValues( RTI::RTIambassador *rti, double time, bool force ) {\n    AttributeHandleValuePairSetSP suppliedAttributesSP = createDatamemberHandleValuePairSet( force );\n    if ( suppliedAttributesSP->size() == 0 ) {\n        return;\n    }\n    try {\n        rti->updateAttributeValues(  getObjectHandle(), *suppliedAttributesSP, RTIfedTime( time ), 0  );\n        createLog( time, true );\n    } catch ( RTI::ObjectNotKnown & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Object Not Known\" << std::endl;\n        return;\n    } catch ( RTI::FederateNotExecutionMember & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Federate Not Execution Member\" << std::endl;\n        return;\n    } catch ( RTI::AttributeNotDefined & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Attribute Not Defined\" << std::endl;\n        return;\n    } catch ( RTI::AttributeNotOwned & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Attribute Not Owned\" << std::endl;\n        return;\n    } catch ( RTI::ConcurrentAccessAttempted & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Concurrent Access Attempted\" << std::endl;\n        return;\n    } catch ( RTI::InvalidFederationTime & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Invalid Federation Time\" << std::endl;\n        return;\n    } catch ( ... ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  exception caught\" << std::endl;\n    }\n}\n\nvoid ObjectRoot::updateAttributeValues( RTI::RTIambassador *rti, bool force ) {\n    AttributeHandleValuePairSetSP suppliedAttributesSP = createDatamemberHandleValuePairSet( force );\n    if ( suppliedAttributesSP->size() == 0 ) {\n        return;\n    }\n    try {\n        rti->updateAttributeValues( getObjectHandle(), *suppliedAttributesSP, 0 );\n        createLog( 0, true );\n    } catch ( RTI::ObjectNotKnown & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Object Not Known\" << std::endl;\n        return;\n    } catch ( RTI::FederateNotExecutionMember & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Federate Not Execution Member\" << std::endl;\n        return;\n    } catch ( RTI::AttributeNotDefined & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Attribute Not Defined\" << std::endl;\n        return;\n    } catch ( RTI::AttributeNotOwned & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Attribute Not Owned\" << std::endl;\n        return;\n    } catch ( RTI::ConcurrentAccessAttempted & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Concurrent Access Attempted\" << std::endl;\n        return;\n    } catch ( RTI::InvalidFederationTime & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Invalid Federation Time\" << std::endl;\n        return;\n    } catch ( ... ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  exception caught\" << std::endl;\n    }\n}\n\nstd::string ObjectRoot::fedName = \"\";\n\nvoid ObjectRoot::enablePublishLog(const std::string &object, const std::string &attribute, const std::string &fed, const std::string &thislevel, const std::string &globallevel) {\n    if ( globallevel.empty() ) {\n        return;\n    }\n    if (  _logger->getLogLevel( thislevel ) > _logger->getLogLevel( globallevel )  ) {\n        return;\n    }\n    fedName = fed;\n    getPubAttributeLogMap().insert(  make_pair( attribute, thislevel )  );\n    _logger->addLog( object, attribute, fed, true );\n}\n\nvoid ObjectRoot::enableSubscribeLog( const std::string &object, const std::string &attribute, const std::string &fed, const std::string &thislevel, const std::string &globallevel ) {\n    if ( globallevel.empty() ) {\n        return;\n    }\n    if (  _logger->getLogLevel( thislevel ) > _logger->getLogLevel( globallevel )  ) {\n        return;\n    }\n    fedName = fed;\n    getSubAttributeLogMap().insert(  make_pair( attribute, thislevel )  );\n    _logger->addLog( object, attribute, fed, false );\n}\n\nvoid ObjectRoot::createLog( double time, bool isPub ) {\n    if ( getPubAttributeLogMap().empty() ) {\n        return;\n    }\n    std::string id = isPub ? fedName + \"_pub_\" + getClassName() : getClassName() + \"_sub_\" + fedName;\n    _logger->addLog( id, *this, time );\n}\n<%} %>\n",
    "cpp/classroot.hpp.ejs": "<% /*\ninput properties used\n---------------------\nisinteraction\n\nused in\n-------\nCppRTI.js\n\nThis also uses ejs, but apparently ejs is available without being passed in.\n\n*/ -%>\n<%/* THIS IS THE ROOT CLASS OF EITHER THE INTERACTION OR OBJECT-CLASS HEIRARCHY\n(i.e. \"InteractionRoot\" OR \"ObjectRoot\") */\n/*\n * Copyright (c) 2008, Institute for Software Integrated Systems, Vanderbilt University\n * All rights reserved.\n *\n * Permission to use, copy, modify, and distribute this software and its\n * documentation for any purpose, without fee, and without written agreement is\n * hereby granted, provided that the above copyright notice, the following\n * two paragraphs and the author appear in all copies of this software.\n *\n * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\n * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT\n * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n * \n */\n\n/*\n *  NOTE:  ALL \"if\" STATEMENTS IN THIS CODE THAT HAD THE FORM:\n *\n *  if (condition) statement;\n *\n *  OR\n *\n *  if (condition) statement1;\n *  else           statement2;\n *\n *  HAVE BEEN CONVERTED TO THE FORMS:\n *\n *  if (condition) {\n *\t\tstatement;\n *\t}\n *\n *  AND\n *\n *  if (condition) {\n *\t\tstatement1;\n *\t} else {\n *\t\tstatement2;\n *\t}\n *\n *  RESPECTIVELY.  THIS IS BECAUSE THE OMNET DEBUGGER APPEARS TO HAVE A PROBLEM\n *  WITH THE NON-BRACED FORMS OF THE IF STATEMENT.  *PLEASE* DO NOT CHANGE IT BACK.\n *  -- H.S.N.\n *\n */\n\n<% var rootname = isinteraction ? \"InteractionRoot\" : \"ObjectRoot\"; -%>\n<% var IntOb = isinteraction ? \"Interaction\" : \"Object\"; -%>\n<% var Field = isinteraction ? \"Parameter\" : \"Attribute\"; -%>\n<% var intob = isinteraction ? \"interaction\" : \"object\"; -%>\n<% var field = isinteraction ? \"parameter\" : \"attribute\"; -%>\n<% var create = isinteraction ? \"create_interaction\" : \"create_object\"; -%>\n<% if(isinteraction){ %>\n#ifndef _INTERACTION_ROOT\n#define _INTERACTION_ROOT\n<% }else{ -%>\n#ifndef _OBJECT_ROOT\n#define _OBJECT_ROOT\n<%} -%>\n\n#ifndef _CRT_SECURE_NO_DEPRECATE\n#define _CRT_SECURE_NO_DEPRECATE\n#endif\n\n#ifndef RTI_USES_STD_FSTREAM\n#define RTI_USES_STD_FSTREAM\n#endif\n\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <set>\n#include <map>\n#include <list>\n#include <ctype.h>\n#include <stdlib.h>\n\n#include <boost/shared_ptr.hpp>\n\n#include <TypeMedley.hpp>\n#include <StringCollections.hpp>\n\n#include \"RTI.hh\"\n#include \"fedtime.hh\"\n\n#ifdef _WIN32\n#include <windows.h>\n#else\n#include <unistd.h>\n#endif\n\n#include \"RTILogger.hpp\"\n\n#ifndef C2W_RTI_LOGGER_CLS\n#define C2W_RTI_LOGGER_CLS C2WConsoleLogger\n#endif \n\n#include \"<%=IntOb%>If.hpp\"\n\nclass <%= rootname %> : public <%=IntOb%>If{\npublic:\n    typedef std::map< std::string, StringSet * > NameStringSetPtrMap;\n    typedef std::map< std::string, StringVector * > NameStringVectorPtrMap;\n    typedef std::map< std::string, int > StringIntegerMap;\n    typedef std::map< int, std::string > IntegerStringMap;\n    typedef boost::shared_ptr< <%= rootname %> > SP;\n    typedef boost::shared_ptr< RTI::<%= Field %>HandleValuePairSet > <%= Field %>HandleValuePairSetSP;\n    \n    typedef SP (*FactoryFunctionPtr)( void );\n    typedef std::map< std::string, FactoryFunctionPtr > ClassNameFactoryMap;\n\n    typedef void (*PubsubFunctionPtr)( RTI::RTIambassador * );\n    typedef std::map< std::string, PubsubFunctionPtr > ClassNamePubSubMap;\n    typedef std::map< std::string, std::string> DatamemberTypeMap;\n<% if(!isinteraction){ -%>\n    typedef std::map< std::string, RTI::AttributeHandleSet * > ClassNameAttributesPtrMap;\n    typedef std::map< int, SP > ObjectMap;\n<%} -%>\n    static DatamemberTypeMap &getDatamemberTypeMap( void ) {\n        static DatamemberTypeMap datamemberTypeMap;\n        return datamemberTypeMap;\n    }\n\nprotected:\n    static StringSet &getClassNameSet( void ) {\n        static StringSet classNameSet;\n        return classNameSet;\n    }\n\n    static ClassNameFactoryMap &getClassNameFactoryMap( void ) {\n        static ClassNameFactoryMap classNameFactoryMap;\n        return classNameFactoryMap;\n    }\n\n    static ClassNamePubSubMap &getClassNamePublishMap( void ) {\n        static ClassNamePubSubMap classNamePublishMap;\n        return classNamePublishMap;\n    }\n\n    static ClassNamePubSubMap &getClassNameUnpublishMap( void ) {\n        static ClassNamePubSubMap classNameUnpublishMap;\n        return classNameUnpublishMap;\n    }\n\n    static ClassNamePubSubMap &getClassNameSubscribeMap( void ) {\n        static ClassNamePubSubMap classNameSubscribeMap;\n        return classNameSubscribeMap;\n    }\n\n    static ClassNamePubSubMap &getClassNameUnsubscribeMap( void ) {\n        static ClassNamePubSubMap classNameUnsubscribeMap;\n        return classNameUnsubscribeMap;\n    }\n\n    static NameStringVectorPtrMap &getDatamemberClassNameVectorPtrMap( void ) {\n        static NameStringVectorPtrMap datamemberClassNameVectorPtrMap;\n        return datamemberClassNameVectorPtrMap;\n    }\n\n    static NameStringVectorPtrMap &getAllDatamemberClassNameVectorPtrMap( void ) {\n        static NameStringVectorPtrMap allDatamemberClassNameVectorPtrMap;\n        return allDatamemberClassNameVectorPtrMap;\n    }\n\n    static StringIntegerMap &getClassNameHandleMap( void ) {\n        static StringIntegerMap classNameHandleMap;\n        return classNameHandleMap;\n    }\n\n    static IntegerStringMap &getClassHandleNameMap( void ) {\n        static IntegerStringMap classHandleNameMap;\n        return classHandleNameMap;\n    }\n\n    static StringIntegerMap &getDatamemberNameHandleMap( void ) {\n        static StringIntegerMap datamemberNameHandleMap;\n        return datamemberNameHandleMap;\n    }\n\n    static IntegerStringMap &getDatamemberHandleNameMap( void ) {\n        static IntegerStringMap datamemberHandleNameMap;\n        return datamemberHandleNameMap;\n    }\n\n<% if(!isinteraction){ %>\n    static NameStringVectorPtrMap &getClassNamePublishAttributeNameVectorPtrMap( void ) {\n        static NameStringVectorPtrMap classNamePublishAttributeNameVectorPtrMap;\n        return classNamePublishAttributeNameVectorPtrMap;\n    }\n\n    static NameStringVectorPtrMap &getClassNameSubscribeAttributeNameVectorPtrMap( void ) {\n        static NameStringVectorPtrMap classNameSubscribeAttributeNameVectorPtrMap;\n        return classNameSubscribeAttributeNameVectorPtrMap;\n    }\n    \n    static ClassNameAttributesPtrMap &getClassNamePublishedAttributesPtrMap( void ) {\n        static ClassNameAttributesPtrMap classNamePublishedAttributesPtrMap;\n        return classNamePublishedAttributesPtrMap;\n    }\n\n    static ClassNameAttributesPtrMap &getClassNameSubscribedAttributesPtrMap( void ) {\n        static ClassNameAttributesPtrMap classNameSubscribedAttributesPtrMap;\n        return classNameSubscribedAttributesPtrMap;\n    }\n\n    static ObjectMap &getObjectMap( void ) {\n        static ObjectMap objectMap;\n        return objectMap;\n    }\n\n    template< typename S, typename T >\n    class Attribute {\n    private:\n        T _value;\n        T _oldValue;\n        bool _oldValueInit;\n        double _time;\n\n    public:\n\n        Attribute( void ) : _value( 0 ), _oldValueInit( false ), _time( -1 ) { }\n\n        T getValue( void ) const { return _value; }\n        void setValue( T value ) { _value = value; }\n\n        double getTime( void ) { return _time; }\n        void setTime( double time ) { _time = time; }\n\n        void setHasBeenUpdated( void ) {\n            _oldValue = _value;\n            _oldValueInit = true;\n        }\n\n        bool shouldBeUpdated( bool force ) { return force || !_oldValueInit || _oldValue != _value; }\n    };\n\n    template< typename S >\n    class Attribute< S, std::string > {\n    private:\n        std::string _value;\n        std::string _oldValue;\n        bool _oldValueInit;\n        double _time;\n\n    public:\n\n        Attribute( void ) : _oldValueInit( false ), _time( -1 ) { }\n\n        const std::string &getValue( void ) const { return _value; }\n        void setValue( const std::string &value ) { _value = value; }\n\n        double getTime( void ) { return _time; }\n        void setTime( double time ) { _time = time; }\n\n        void setHasBeenUpdated( void ) {\n            _oldValue = _value;\n            _oldValueInit = true;\n        }\n\n        bool shouldBeUpdated( bool force ) { return force || !_oldValueInit || _oldValue != _value; }\n    };\n\n<%}%>\n\n<%- ejs.render(\n    TEMPLATES[\"cpp/classcommon.hpp.ejs\"],{\n        alldatamembers: [],\n        classname: rootname,\n        datamembers: [],\n        isinteraction: isinteraction,\n        parentclassname: \"\"\n}) %>\npublic:\n    static StringSet get_<%=intob%>_names( void ) { return getClassNameSet(); }\n    static StringVector get_<%= field %>_names( const std::string &className ) {\n        NameStringVectorPtrMap::iterator nssItr = getDatamemberClassNameVectorPtrMap().find( className );\n        return nssItr == getDatamemberClassNameVectorPtrMap().end() ? StringVector() : *nssItr->second;\n    }\n\n    static StringVector get_all_<%= field %>_names( const std::string &className ) {\n        NameStringVectorPtrMap::iterator nssItr = getAllDatamemberClassNameVectorPtrMap().find( className );\n        return nssItr == getAllDatamemberClassNameVectorPtrMap().end() ? StringVector() : *nssItr->second;\n    }\n\n    static std::string get_class_name( int classHandle ) {\n        IntegerStringMap::iterator ismItr = getClassHandleNameMap().find( classHandle );\n        return ismItr == getClassHandleNameMap().end() ? std::string() : ismItr->second;\n    }\n\n    static int get_handle( const std::string &className ) {\n        StringIntegerMap::iterator simItr = getClassNameHandleMap().find( className );\n        if ( simItr == getClassNameHandleMap().end() ) {\n            std::cerr << \"Bad class name \\\"\" << className << \"\\\" on get_handle.\" << std::endl;\n            return -1;\n        }\n        return simItr->second;\n    }\n\n    static std::string get_<%= field %>_name( int datamemberHandle ) {\n        IntegerStringMap::iterator ismItr = getDatamemberHandleNameMap().find( datamemberHandle );\n        return ismItr == getDatamemberHandleNameMap().end() ? std::string() : ismItr->second;\n    }\n\n    static int get_<%=isinteraction?\"parameter\":\"attribute\"%>_handle( const std::string &className, const std::string &datamemberName ) {\n        StringIntegerMap::iterator simItr = getDatamemberNameHandleMap().find( className + \".\" + datamemberName );\n        if ( simItr == getDatamemberNameHandleMap().end() ) {\n            std::cerr << \"Bad <%=isinteraction?\"parameter\":\"attribute\"%> \\\"\" << datamemberName << \"\\\" for class \\\"\" << className << \"\\\" on get_<%=isinteraction?\"parameter\":\"attribute\"%>_handle.\" << std::endl;\n            return -1;\n        }\n        return simItr->second;\n    }\n\n    static void publish( const std::string &className, RTI::RTIambassador *rti ) {\n        ClassNamePubSubMap::iterator cpmItr = getClassNamePublishMap().find( className );\n        if ( cpmItr == getClassNamePublishMap().end() ) {\n            std::cerr << \"Bad class name \\\"\" << className << \"\\\" on publish.\" << std::endl;\n            return;\n        }\n        (*cpmItr->second)( rti );\n    }\n\n    static void unpublish( const std::string &className, RTI::RTIambassador *rti ) {\n        ClassNamePubSubMap::iterator cpmItr = getClassNameUnpublishMap().find( className );\n        if ( cpmItr == getClassNameUnpublishMap().end() ) {\n            std::cerr << \"Bad class name \\\"\" << className << \"\\\" on unpublish.\" << std::endl;\n            return;\n        }\n        (*cpmItr->second)( rti );\n    }\n\n    static void subscribe( const std::string &className, RTI::RTIambassador *rti ) {\n        ClassNamePubSubMap::iterator cpmItr = getClassNameSubscribeMap().find( className );\n        if ( cpmItr == getClassNameSubscribeMap().end() ) {\n            std::cerr << \"Bad class name \\\"\" << className << \"\\\" on subscribe.\" << std::endl;\n            return;\n        }\n        \n        (*cpmItr->second)( rti );\n    }\n\n    static void unsubscribe( const std::string &className, RTI::RTIambassador *rti ) {\n        ClassNamePubSubMap::iterator cpmItr = getClassNameUnsubscribeMap().find( className );\n        if ( cpmItr == getClassNameSubscribeMap().end() ) {\n            std::cerr << \"Bad class name \\\"\" << className << \"\\\" on unsubscribe.\" << std::endl;\n            return;\n        }\n        (*cpmItr->second)( rti );\n    }\n\n<% if(!isinteraction){ %>\n    static void publish( const std::string &className, const std::string &attributeName );\n    \n    static void unpublish( const std::string &className, const std::string &attributeName ) {\n        NameStringVectorPtrMap::iterator camItr = getClassNamePublishAttributeNameVectorPtrMap().find( className );\n        if ( camItr == getClassNamePublishAttributeNameVectorPtrMap().end() ) {\n            std::cerr << \"ERROR:  ObjectRoot.unpublish:  could not unpublish class \\\"\" << className << \"\\\" \\\"\" << attributeName << \"\\\" attribute.\" << std::endl;\n            return;\n        }\n        camItr->second->erase( std::remove( camItr->second->begin(), camItr->second->end(), attributeName ), camItr->second->end() );\n    }\n\n    static void subscribe( const std::string &className, const std::string &attributeName );\n\n    static void unsubscribe( const std::string &className, const std::string &attributeName ) {\n        NameStringVectorPtrMap::iterator camItr = getClassNameSubscribeAttributeNameVectorPtrMap().find( className );\n        if ( camItr == getClassNameSubscribeAttributeNameVectorPtrMap().end() ) {\n            std::cerr << \"ERROR:  ObjectRoot.unsubscribe:  could not unsubscribe class \\\"\" << className << \"\\\" \\\"\" << attributeName << \"\\\" attribute.\" << std::endl;\n            return;\n        }\n        camItr->second->erase( std::remove( camItr->second->begin(), camItr->second->end(), attributeName ), camItr->second->end() );\n    }\n<%}%>\n\npublic:\n    static SP create_<%=isinteraction?\"interaction\":\"object\"%>( const std::string &className ) {\n        ClassNameFactoryMap::iterator cfmItr = getClassNameFactoryMap().find( className );\n        return cfmItr == getClassNameFactoryMap().end() ? SP( (<%=rootname%> *)0 ) : (*cfmItr->second)();\n    }\n\n    static SP create_<%=isinteraction?\"interaction\":\"object\"%>( const std::string &className, const RTIfedTime &dlc13FedTime ) {\n        ClassNameFactoryMap::iterator cfmItr = getClassNameFactoryMap().find( className );\n        if ( cfmItr == getClassNameFactoryMap().end() ) {\n            return SP( (<%=rootname%> *)0 );\n        }\n        SP sp = (*cfmItr->second)();\n        sp->setTime( dlc13FedTime.getTime() );\n        return sp;\n    }\n\n    static SP <%=create%>( int classHandle ) {\n        IntegerStringMap::iterator ismItr = getClassHandleNameMap().find( classHandle );\n        return ismItr == getClassHandleNameMap().end() ? SP( (<%=rootname%> *)0 ) : <%=create%>( ismItr->second );\n    }\n\n    static SP <%=create%>( int classHandle, const RTIfedTime &dlc13FedTime ) {\n        IntegerStringMap::iterator ismItr = getClassHandleNameMap().find( classHandle );\n        return ismItr == getClassHandleNameMap().end() ? SP( (<%=rootname%> *)0 ) : <%=create%>( ismItr->second, dlc13FedTime );\n    }\n\n    static SP <%=create%>( int classHandle, const RTI::<%= Field %>HandleValuePairSet &datamemberMap );\n    static SP <%=create%>( int classHandle, const RTI::<%= Field %>HandleValuePairSet &datamemberMap, const RTIfedTime &dlc13FedTime );\n\n    static StringVector get_<%= field %>_names() {\n        return StringVector();\n    }\n\n    static StringVector get_all_<%= field %>_names() {\n        return StringVector();\n    }\n\n<% if(!isinteraction){ %>\n    static SP discover( int class_handle, int object_handle ) {\n        SP sp = create_object( class_handle );\n        if ( sp != 0 ) {\n            getObjectMap().insert(  std::make_pair( object_handle, sp )  );\n        }\n        return sp;\n    }\n\n    static SP reflect( int object_handle, const RTI::AttributeHandleValuePairSet &datamemberMap ) {\n        ObjectMap::iterator obmItr = getObjectMap().find( object_handle );\n        if ( obmItr == getObjectMap().end() ) {\n            return SP( (ObjectRoot *)0 );\n        }\n        \n        SP sp = obmItr->second;\n        sp->setTime( -1 );\n        sp->setAttributes( datamemberMap );\n        return sp;\n    }\n\n    static SP reflect(\n     int object_handle,\n     const RTI::AttributeHandleValuePairSet &datamemberMap,\n     double theTime) {\n        ObjectMap::iterator obmItr = getObjectMap().find( object_handle );\n        if ( obmItr == getObjectMap().end() ) {\n            return SP( (ObjectRoot *)0 );\n        }\n        SP sp = obmItr->second;\n        sp->setTime( theTime );\n        sp->setAttributes( datamemberMap );\n        return sp;\n    }\n\n    void requestUpdate( RTI::RTIambassador *rti );\n\n    static SP getObject( int object_handle ) {\n        ObjectMap::iterator obmItr = getObjectMap().find( object_handle );\n        return obmItr == getObjectMap().end() ? SP( (ObjectRoot *)0 ) : obmItr->second;\n    }\n\n    static SP removeObject( int object_handle ) {\n        ObjectMap::iterator obmItr = getObjectMap().find( object_handle );\n        if ( obmItr == getObjectMap().end() ) {\n            return SP( (ObjectRoot *)0 );\n        }\n        SP sp = obmItr->second;\n        getObjectMap().erase( obmItr );\n        return sp;\n    }\n\nprivate:\n    int _object_handle;\n\n    void setObjectHandle( int object_handle ) {\n        getObjectMap().erase( object_handle );\n        _object_handle = object_handle;\n        getObjectMap().insert(  std::make_pair( object_handle, this )  );\n    }\n\npublic:\n    int getObjectHandle( void ) const { return _object_handle; }\n<%} -%>\n\nprivate:\n    double _time;\n    static C2WLogger* _logger;\n\npublic:    \n    double getTime( void ) { return _time; }\n\n    void setTime( double time ) { _time = time; }\n    void setTime( const RTIfedTime &dlc13FedTime ) {\n        setTime( dlc13FedTime.getTime() );\n    }\n\n    <%=rootname%>( void ) : _time( -1 )<% if(!isinteraction){%>, _isRegistered( false )<%}%> { }\n    \n    <%=rootname%>( const RTI::<%= Field %>HandleValuePairSet &datamemberMap ) : _time( -1 )<% if(!isinteraction){%>, _isRegistered( false )<%}%> {\n        set<%= Field %>s( datamemberMap );\n    }\n\n    <%=rootname%>( const RTI::<%= Field %>HandleValuePairSet &datamemberMap, const RTIfedTime &dlc13FedTime ) : _time( dlc13FedTime.getTime() )<% if(!isinteraction){%>, _isRegistered( false )<%}%> {\n        set<%= Field %>s( datamemberMap );\n    }\n\n    static SP create( void ) { return SP( new <%=rootname%> ); }\n    static SP create( const RTI::<%= Field %>HandleValuePairSet &datamemberMap ) { return SP(  new <%=rootname%>( datamemberMap )  ); }\n    static SP create( const RTI::<%= Field %>HandleValuePairSet &datamemberMap, const RTIfedTime &dlc13FedTime ) {\n        return SP(  new <%=rootname%>( datamemberMap, dlc13FedTime )  );\n    }\n\n    virtual TypeMedley get<%= Field %>( const std::string &datamemberName ) const {\n        throw std::invalid_argument( getClassName() + \" class has no <%= field %> named \\\"\" + datamemberName + \"\\\"\" );\n    }\n\n    virtual TypeMedley get<%= Field %>( int datamemberHandle ) const {\n        throw std::invalid_argument(\n         getClassName() + \" class has no <%= field %> with handle (\" + boost::lexical_cast< std::string >( datamemberHandle ) + \")\"\n        );\n    }\n\n    void set<%= Field%>s( const RTI::<%= Field %>HandleValuePairSet &datamemberMap );\n\nprivate:\n    void set<%= Field %>( RTI::Handle handle, const std::string &val ) {\n        if (  !set<%= Field %>Aux( handle, val )  ) {\n            std::cerr << \"set:  bad <%= field %> handle in class \\\"\" + getClassName() + \"\\\"\" << std::endl;\n        }\n    }\n\npublic:\n    void set<%= Field%>( const std::string &datamemberName, TypeMedley value ) {\n        if (  !set<%= Field %>Aux( datamemberName, value )  ) {\n            std::cerr << \"Error:  class \\\"\" << getClassName() << \"\\\":  invalid <%= field %> \\\"\" + datamemberName + \"\\\"\" << std::endl;\n        }\n    }\n\nprotected:\n    virtual bool set<%= Field %>Aux( int param_handle, const std::string &val ) {\n        return false;\n    }\n\n    virtual bool set<%= Field %>Aux( const std::string &datamemberName, const std::string &value ) {\n        return false;\n    }\n\n    virtual bool set<%= Field %>Aux( const std::string &datamemberName, TypeMedley value ) {\n        return false;\n    }\n\n    virtual <%= Field %>HandleValuePairSetSP createDatamemberHandleValuePairSet( RTI::ULong count<% if(!isinteraction){%>, bool force<%}%> ) {\n        return <%= Field %>HandleValuePairSetSP(  RTI::<%= Field %>SetFactory::create( count )  );\n    }\n\n    virtual <%= Field %>HandleValuePairSetSP createDatamemberHandleValuePairSet( <% if(!isinteraction){%>bool force<%}%> ) {\n        return createDatamemberHandleValuePairSet( <% if(!isinteraction){%>force<%}%> );\n    }\n\n<% if(isinteraction){ %>\npublic:\n    void sendInteraction( RTI::RTIambassador *rti, double time );\n    void sendInteraction( RTI::RTIambassador *rti );\n\nprivate:\n    static std::string fedName;\n\npublic:\n    static bool enablePubLog;\n    static bool enableSubLog;\n    static std::string pubLogLevel;\n    static std::string subLogLevel;    \n\npublic:\n    static void enablePublishLog(const std::string &interaction, const std::string &fed, const std::string &thislevel, const std::string &globallevel);\n\n    static void enableSubscribeLog(const std::string &interaction, const std::string &fed, const std::string &thislevel, const std::string &globallevel);\n\n    void createLog( double time, bool isPub = true );\n\n<% }else{ %>\nprivate:\n    bool _isRegistered;\n\npublic:\n    void registerObject( RTI::RTIambassador *rti );\n\n    void unregisterObject( RTI::RTIambassador *rti );\n\n    void updateAttributeValues( RTI::RTIambassador *rti, double time, bool force );\n\n    void updateAttributeValues( RTI::RTIambassador *rti, double time ) {\n        updateAttributeValues( rti, time, false );\n    }\n\n    void updateAttributeValues( RTI::RTIambassador *rti, bool force );\n\n    void updateAttributeValues( RTI::RTIambassador *rti ) {\n        updateAttributeValues( rti, false );\n    }\n\nprivate:\n    static std::string fedName;\n\npublic:\n    static void enablePublishLog(const std::string &object, const std::string &attribute, const std::string &fed, const std::string &thislevel, const std::string &globallevel);\n\n    static void enableSubscribeLog(const std::string &object, const std::string &attribute, const std::string &fed, const std::string &thislevel, const std::string &globallevel);\n\n    static std::map<std::string, std::string> &getPubAttributeLogMap( void) {\n        static std::map<std::string, std::string> pubAttributeLogMap;\n        return pubAttributeLogMap;\n    }\n\n    static std::map<std::string, std::string> &getSubAttributeLogMap( void) {\n        static std::map<std::string, std::string> subAttributeLogMap;\n        return subAttributeLogMap;\n    }\n\n    void createLog( double time, bool isPub = true );\n<%} -%>\n};\n\ntypedef <%=rootname%>::SP <%=rootname%>SP;\n\nstatic bool call_<%=rootname%>_static_init = <%=rootname%>::static_init();\n\nstd::ostream &operator<<( std::ostream &os, <%=rootname%>::SP entitySP );\nstd::ostream &operator<<( std::ostream &os, const <%=rootname%> &entity );\n#endif\n",
    "cpp/cppfedbase_pom.xml.ejs": "<% /*\ninput properties\n----------------\nartifactId string\ngroupId    string\npackaging  string\nversion    string\n\nused in\n-------\nCppImplFederate.js\n\n*/ -%>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <groupId><%=groupId%></groupId>\n    <artifactId><%=artifactId%></artifactId>\n    <version><%=version%></version>\n    <packaging><%=packaging%></packaging>\n\n    <properties>\n        <boost.version>1.57.0+nar.10</boost.version>\n        <nar-plugin.version>3.3.0</nar-plugin.version>\n        <compiler-name>g++</compiler-name>\n        <linker-name>g++</linker-name>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.cpswt</groupId>\n            <artifactId>SynchronizedFederate</artifactId>\n            <version>0.6.0-SNAPSHOT</version>\n            <type>nar</type>\n        </dependency>\n        <dependency>\n            <groupId>org.cpswt</groupId>\n            <artifactId>rti-base-cpp</artifactId>\n            <version>0.6.0-SNAPSHOT</version>\n            <type>nar</type>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>com.github.maven-nar</groupId>\n                <artifactId>nar-maven-plugin</artifactId>\n                <version>${nar-plugin.version}</version>\n                <extensions>true</extensions>\n                <configuration>\n                    <libraries>\n                        <library> \n                            <type>executable</type>\n                        </library>\n                    </libraries>\n                    <cpp>\n                        <name>${compiler-name}</name>\n                        <debug>false</debug>\n                        <includes>\n                            <include>**/*.hpp</include>\n                            <include>**/*.h</include>\n                            <include>**/*.cpp</include>\n                            <include>**/*.c</include>\n                        </includes>\n                        <options combine.children=\"append\">\n                            <!--option>-std=c++11</option-->\n                            <option>-ftemplate-depth-128</option>\n                            <option>-fno-inline</option>\n                            <option>-Wall</option>\n                            <option>-pedantic</option>\n                            <option>-Wno-long-long</option>\n                            <option>-Wno-variadic-macros</option>\n                        </options>\n                        <defines>\n                            <!--define>USE_MYSQL_LOGGING</define-->\n                            <define>RTI_USES_STD_FSTREAM</define>\n                        </defines>\n                        <systemIncludePaths>\n                            <systemIncludePath>${build.BOOST_INC_DIR}</systemIncludePath>\n                            <systemIncludePath>${build.RTI_INC_DIR}</systemIncludePath>\n                        </systemIncludePaths>\n                    </cpp>\n                    <linker>\n                        <name>${linker-name}</name>\n                        <incremental>false</incremental>\n                        <libs>\n                            <lib>\n                                <name>RTI-NG_64d</name>\n                                <type>shared</type>\n                                <directory>${build.RTI_LIB_DIR}</directory>\n                            </lib>\n                            <lib>\n                                <name>FedTime_64d</name>\n                                <type>shared</type>\n                                <directory>${build.RTI_LIB_DIR}</directory>\n                            </lib>\n                            <lib>\n                                <name>boost_thread</name>\n                                <type>shared</type>\n                                <directory>${build.BOOST_LIB_DIR}</directory>\n                            </lib>\n                            <lib>\n                                <name>boost_system</name>\n                                <type>shared</type>\n                                <directory>${build.BOOST_LIB_DIR}</directory>\n                            </lib>\n                            <lib>\n                                <name>mysqlcppconn</name>\n                                <type>shared</type>\n                                <directory>${build.MYSQL_LIB_DIR}</directory>\n                            </lib>\n                            <lib>\n                                <name>jvm</name>\n                                <type>shared</type>\n                                <directory>${build.RTI_LIB_JVM_DIR}</directory>\n                            </lib>\n                        </libs>\n                    </linker>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n\n    <profiles>\n        <profile>\n            <id>windows-common</id>\n            <activation>\n                <os>\n                    <family>windows</family>\n                </os>\n            </activation>\n            <properties>\n              <build.RTI_LIB_DIR>${env.RTI_LIB_DIR}</build.RTI_LIB_DIR>\n              <build.RTI_INC_DIR>${env.RTI_HOME}/include/hla13</build.RTI_INC_DIR>\n              <build.BOOST_INC_DIR>${env.BOOST_INC_DIR}</build.BOOST_INC_DIR>\n              <build.BOOST_LIB_DIR>${env.BOOST_LIB_DIR}</build.BOOST_LIB_DIR>\n              <build.MYSQL_LIB_DIR>${env.MYSQL_LIB_DIR}</build.MYSQL_LIB_DIR>\n            </properties>\n            <build>\n                <plugins>\n                    <plugin>\n                        <groupId>com.github.maven-nar</groupId>\n                        <artifactId>nar-maven-plugin</artifactId>\n                        <extensions>true</extensions>\n                        <configuration>\n                            <cpp>\n                                <options combine.children=\"append\">\n                                    <option>-mthreads</option>\n                                </options>\n                            </cpp>\n                        </configuration>\n                    </plugin>\n                </plugins>\n            </build>\n        </profile>\n\n        <profile>\n            <id>linux-common</id>\n            <activation>\n                <os>\n                    <family>linux</family>\n                </os>\n            </activation>\n            <properties>\n              <build.RTI_LIB_JVM_DIR>${env.RTI_HOME}/jre/lib/amd64/server</build.RTI_LIB_JVM_DIR>\n              <build.RTI_LIB_DIR>${env.RTI_HOME}/lib/gcc4</build.RTI_LIB_DIR>\n              <build.RTI_INC_DIR>${env.RTI_HOME}/include/hla13</build.RTI_INC_DIR>\n              <build.BOOST_INC_DIR>/usr/include/boost</build.BOOST_INC_DIR>\n              <build.BOOST_LIB_DIR>/usr/lib/x86_64-linux-gnu</build.BOOST_LIB_DIR>\n              <build.MYSQL_LIB_DIR>/usr/lib/</build.MYSQL_LIB_DIR>\n            </properties>\n            <build>\n                <plugins>\n                    <plugin>\n                        <groupId>com.github.maven-nar</groupId>\n                        <artifactId>nar-maven-plugin</artifactId>\n                        <extensions>true</extensions>\n                        <configuration>\n                            <cpp>\n                                <options combine.children=\"append\">\n                                    <option>-pthread</option>\n                                </options>\n                            </cpp>\n                        </configuration>\n                    </plugin>\n                </plugins>\n            </build>\n        </profile>\n\n        <profile>\n            <id>mac-common</id>\n            <activation>\n                <os>\n                    <family>mac</family>\n                </os>\n            </activation>\n            <properties>\n              <build.RTI_LIB_DIR>${env.RTI_LIB_DIR}</build.RTI_LIB_DIR>\n              <build.RTI_INC_DIR>${env.RTI_HOME}/include/hla13</build.RTI_INC_DIR>\n              <build.BOOST_INC_DIR>${env.BOOST_INC_DIR}</build.BOOST_INC_DIR>\n              <build.BOOST_LIB_DIR>${env.BOOST_LIB_DIR}</build.BOOST_LIB_DIR>\n              <build.MYSQL_LIB_DIR>${env.MYSQL_LIB_DIR}</build.MYSQL_LIB_DIR>\n            </properties>\n            <build>\n                <plugins>\n                    <plugin>\n                        <groupId>com.github.maven-nar</groupId>\n                        <artifactId>nar-maven-plugin</artifactId>\n                        <extensions>true</extensions>\n                        <configuration>\n                            <cpp>\n                                <options combine.children=\"append\">\n                                    <option>-pthread</option>\n                                </options>\n                            </cpp>\n                        </configuration>\n                    </plugin>\n                </plugins>\n            </build>\n        </profile>\n    </profiles>\n</project>\n",
    "cpp/federate.cpp.ejs": "<%/*\ninput properties\n----------------\nasynchronousdelivery       boolean\nclassname                  string\npublishedinteractiondata   array\npublishedobjectdata        array\nsubscribedinteractiondata  array\nsubscribedobjectdata       array\ntimeconstrained            boolean\ntimeregulating             boolean\n\nused in\n-------\nCppFederate.js\n\n*/ -%>\n\n#include \"<%=classname%>Base.hpp\"\n\nvoid <%=classname%>Base::init() {\n    createRTI();\n    joinFederation();\n<% if (timeconstrained){ -%>\n    enableTimeConstrained();\n<%} -%>\n<% if (timeregulating){ -%>\n    enableTimeRegulation( getLookAhead() );\n<%} -%>\n<% if (asynchronousdelivery){ -%>\n    enableAsynchronousDelivery();\n<%} -%>\n<% if (publishedinteractiondata.length || subscribedinteractiondata.length) {-%>\n\n  // interaction pubsub\n<%} -%>\n<% publishedinteractiondata.forEach(function(interactiondata){ -%>\n  <%=interactiondata.codeNameOrName%>::publish( getRTI() );\n<%}); -%>\n<% subscribedinteractiondata.forEach(function(interactiondata){ -%>  \n    <%=interactiondata.codeNameOrName%>::subscribe( getRTI() );\n    _subscribedInteractionFilter.setFedFilters(\n        <%=interactiondata.codeNameOrName%>::get_handle(),\n        SubscribedInteractionFilter::<%=interactiondata.originFedFilter()%>,\n        SubscribedInteractionFilter::<%=interactiondata.srcFedFilter()%>);\n<%}); -%>\n<% if (publishedobjectdata.length || subscribedobjectdata.length) {-%>\n\n    // object pubsub\n<%} -%>\n<% publishedobjectdata.forEach(function(objectdata){ -%>\n<% objectdata.publishedAttributeData.forEach(function(attributedata){ -%>\n    <%=objectdata.codeNameOrName%>::publish_<%=attributedata.name%>();\n<%}); -%>\n    <%=objectdata.codeNameOrName%>::publish( getRTI() );\n<%}); -%>\n<% subscribedobjectdata.forEach(function(objectdata){ -%>\n<% objectdata.subscribedAttributeData.forEach(function(attributedata){ -%>\n    <%=objectdata.codeNameOrName%>::subscribe_<%=attributedata.name%>();\n<%}); -%>\n    <%=objectdata.codeNameOrName%>::subscribe( getRTI() );\n<%}); -%>\n}\n\n<%=classname%>Base::<%=classname%>Base(FederateConfig *fedconfig) : Super(fedconfig) {\n    init();\n}\n<% publishedinteractiondata.forEach(function(interactiondata){ -%>\n\n<%=interactiondata.codeNameOrName%>SP <%=classname%>Base::create_<%=interactiondata.codeNameOrName%>( void ) {\n    <%=interactiondata.codeNameOrName%>SP interactionSP = <%=interactiondata.codeNameOrName%>::create();\n    interactionSP->set_sourceFed( getFederateId() );\n    interactionSP->set_originFed( getFederateId() );\n    return interactionSP;\n}\n<%}); -%>\n\nvoid <%=classname%>Base::receiveInteraction(\n         RTI::InteractionClassHandle theInteraction,\n         const RTI::ParameterHandleValuePairSet& theParameters,\n         const RTI::FedTime& theTime,\n         const char *theTag,\n         RTI::EventRetractionHandle theHandle)\n  throw (RTI::InteractionClassNotKnown,\n         RTI::InteractionParameterNotKnown,\n         RTI::InvalidFederationTime,\n         RTI::FederateInternalError) {\n    if ( getMoreATRs() ) {\n        InteractionRoot::SP interactionRootSP =\n          InteractionRoot::create_interaction( theInteraction, theParameters, theTime );\n        C2WInteractionRootSP c2wInteractionRootSP =\n          boost::dynamic_pointer_cast<C2WInteractionRoot>( interactionRootSP );\n        if ( c2wInteractionRootSP != 0 ) { \n            // Filter interaction if src/origin fed requirements (if any) are not met\n            if ( _subscribedInteractionFilter.filterC2WInteraction( getFederateId(), c2wInteractionRootSP ) ) {\n                return;\n            }\n        }\n        Super::receiveInteraction( theInteraction, theParameters, theTime, theTag, theHandle );\n    }\n}\n\nvoid <%=classname%>Base::receiveInteraction(\n         RTI::InteractionClassHandle theInteraction,\n         const RTI::ParameterHandleValuePairSet& theParameters,\n         const char *theTag)\n  throw (RTI::InteractionClassNotKnown,\n         RTI::InteractionParameterNotKnown,\n         RTI::FederateInternalError) {\n    if ( getMoreATRs() ) {\n        InteractionRoot::SP interactionRootSP = InteractionRoot::create_interaction(theInteraction, theParameters);\n        C2WInteractionRootSP c2wInteractionRootSP =\n          boost::dynamic_pointer_cast<C2WInteractionRoot>(interactionRootSP);\n        if ( c2wInteractionRootSP != 0 ) {\n            // Filter interaction if src/origin fed requirements (if any) are not met\n            if ( _subscribedInteractionFilter.filterC2WInteraction(getFederateId(), c2wInteractionRootSP ) ) {\n              return;\n            }\n        }\n        Super::receiveInteraction( theInteraction, theParameters, theTag );\n    }\n}\n",
    "cpp/federate.hpp.ejs": "<%/*\ninput properties\n----------------\nallinteractiondata         array\nallobjectdata              array\nclassname                  string\nlookahead                  double\npublishedinteractiondata   array\n\nused in\n-------\nCppFederate.js\n\n*/ -%>\n#ifndef _<%=classname%>Base_\n#define _<%=classname%>Base_\n\n#include <vector>\n\n#include \"SynchronizedFederate.hpp\"\n#include \"SubscribedInteractionFilter.hpp\"\n\n<% allinteractiondata.forEach(function(interactiondata){ -%>\n#include \"rti/<%=interactiondata.codeNameOrName%>.hpp\"\n<%});-%>\n<% allobjectdata.forEach(function(objectdata){ -%>\n#include \"rti/<%=objectdata.codeNameOrName%>.hpp\"\n<%});-%>\n#include \"C2WLogger.hpp\"\n\n#include \"FederateConfig.h\"\n\nclass <%=classname%>Base : public SynchronizedFederate {\n\npublic:\n    typedef SynchronizedFederate Super;\n\n    typedef std::vector< std::string > ArgVector;\n\n    static double getLookAhead( void ) {\n        static double lookAhead = <%=lookahead%>;\n        return lookAhead;\n    }\n\n  virtual ~<%=classname%>Base( void )\n   throw (RTI::FederateInternalError) { }\n\nprivate:\n    SubscribedInteractionFilter _subscribedInteractionFilter;\n\nprotected:\n    void init();\n\npublic:\n    // constructor\n    <%=classname%>Base( FederateConfig *fedconfig );\n<% publishedinteractiondata.forEach(function(interactiondata){ -%>\n\n    <%=interactiondata.codeNameOrName%>SP create_<%=interactiondata.codeNameOrName%>( void );\n<%}); -%>\n\n    virtual void receiveInteraction(\n         RTI::InteractionClassHandle theInteraction,\n         const RTI::ParameterHandleValuePairSet& theParameters,\n         const RTI::FedTime& theTime,\n         const char *theTag,\n         RTI::EventRetractionHandle theHandle\n        )\n     throw (RTI::InteractionClassNotKnown,\n            RTI::InteractionParameterNotKnown,\n            RTI::InvalidFederationTime,\n            RTI::FederateInternalError);\n\n    virtual void receiveInteraction(\n         RTI::InteractionClassHandle theInteraction,\n         const RTI::ParameterHandleValuePairSet& theParameters,\n         const char *theTag\n        )\n     throw (RTI::InteractionClassNotKnown,\n            RTI::InteractionParameterNotKnown,\n            RTI::FederateInternalError);\n};\n\n#endif\n",
    "cpp/federate_ver.cpp.ejs": "<% /*\ninput properties\n----------------\nsimname  string\nversion  string\n\nused in\n-------\nCppImplFederate.js\n\n*/ -%>\n#include <string>\n\nstatic const std::string _<%=simname%>_base_version_ = \"<%=version%>\";",
    "cpp/federateimpl.cpp.ejs": "<% /*\ninput properties\n----------------\n   classname (string)\n   publishedinteractiondata (array of JavaScript objects)\n      name (string)\n      codeName (string)\n      codeNameOrName (string)\n      fullName (string)\n      lowerName (string)\n      parameters (array of JavaScript objects)\n      publishedLogLevel (string)\n   publishedobjectdata (array of JavaScript objects)\n      name (string)\n      codeName (string)\n      codeNameOrName (string)\n      fullName (string)\n      lowerName (string)\n      parameters (array of JavaScript objects)\n      publishedAttributeData (array JavaScript objects)\n      publishedLogLevel (string)\n   subscribedinteractiondata (array of JavaScript objects)\n      name (string)\n      codeName (string)\n      codeNameOrName (string)\n      fullName (string\n      lowerName (string)\n      originFedFilter (function)\n      parameters (array of JavaScript objects)\n      srcFedFilter (function)\n      subscribedLogLevel (string)\n   subscribedobjectdata (array of JavaScript objects)\n      name (string)\n      codeName (string)\n      codeNameOrName (string)\n      fullName (string)\n      lowerName (string)\n      parameters (array of JavaScript objects)\n      subscribedAttributeData (array JavaScript objects)\n      subscribedLogLevel (string)\n      logSubscribedAttributeData (array of JavaScript objects)\n\nused in\n-------\nCppImplFederate.js\n \n*/ -%>\n\n<% var codeNameobjects = {}; -%>\n<% var codeNameinteractions = {}; -%>\n<% var n = 0; -%>\n<% var m = 0; -%>\n<% publishedobjectdata.forEach(function(object_data){ -%>\n<% if (object_data.codeName) -%>\n<% {codeNameobjects[object_data.codeName] = object_data.name;}}); -%>\n<% subscribedobjectdata.forEach(function(object_data){ -%>\n<% if (object_data.codeName) -%>\n<% {codeNameobjects[object_data.codeName] = object_data.name;}}); -%>\n<% for (var prop in codeNameobjects) {if (prop && (prop != null)) n++;} -%>\n<% publishedinteractiondata.forEach(function(interact_data){ -%>\n<% if (interact_data.codeName) -%>\n<% {codeNameinteractions[interact_data.codeName] = interact_data.name;}}); -%>\n<% subscribedinteractiondata.forEach(function(interact_data){ -%>\n<% if (interact_data.codeName) -%>\n<% {codeNameinteractions[interact_data.codeName] = interact_data.name;}}); -%>\n<% for (var prop in codeNameobjects) {if (prop && (prop != null)) n++;} -%>\n<% for (var prop in codeNameinteractions) {if (prop && (prop != null)) m++;} -%>\n<% if (n + m) { -%>\n// CodeGeneratedName is used if necessary. Otherwise, name is used.\n<% } -%>\n<% if (n) { -%>\n// The following object classes have both CodeGeneratedName and name.\n<% for (var prop in codeNameobjects){ -%>\n<% if (prop && (prop != null)) { -%>\n// CodeGeneratedName = <%= prop %>   name = <%= codeNameobjects[prop] %>\n<% }}} -%>\n<% if (m) { -%>\n// The following interaction classes have both CodeGeneratedName and name.\n<% for (var prop in codeNameinteractions){ -%>\n<% if (prop && (prop != null)) { -%>\n// CodeGeneratedName = <%= prop %>   name = <%= codeNameinteractions[prop] %>\n<% }}} -%>\n\n\n<% /* federateimpl(classname) */ -%>\n#include \"<%=classname%>.hpp\"\n\nvoid <%=classname%>::initialize( void ) {\n    m_currentTime = 0;\n    if ( this->get_IsLateJoiner() ) {\n        m_currentTime = getLBTS() - getLookAhead();\n        disableTimeRegulation();\n    }\n    <%=classname%>ATRCallback advanceTimeRequest(*this);\n    putAdvanceTimeRequest(m_currentTime, advanceTimeRequest);\n    if ( !this->get_IsLateJoiner() ) {\n        readyToPopulate();\n<% if (publishedobjectdata.length > 0) { -%>\n        initObjectInstances();\n<% } -%>\n        readyToRun();\n    }\n<% if (publishedobjectdata.length > 0) { -%>\n    else {\n        initObjectInstances();\n    }\n<% } -%>\n}\n<% if (publishedobjectdata.length > 0) { -%>\n\nvoid <%=classname%>::initObjectInstances() {\n    // TODO register object instances and send initial values\n<% publishedobjectdata.forEach(function(object_data) { -%>\n    // v<%=object_data.codeNameOrName%>.registerObject(getRTI());\n<% }) -%>\n}\n<% } -%>\n<% if (subscribedobjectdata.length + subscribedinteractiondata.length > 0) { -%>\n\nvoid <%=classname%>::checkReceivedSubscriptions() {\n<% if (subscribedobjectdata.length > 0) { -%>\n\n    SynchronizedFederate::ObjectReflector objectReflector;\n    while ( !(objectReflector = getNextObjectReflector()).isNull() ) {\n        objectReflector.reflect();\n\n<% (subscribedobjectdata.sort(function(a, b){return b.fullName.length-a.fullName.length})).forEach(function(object_data){ -%>\n        boost::shared_ptr<<%=object_data.codeNameOrName%>> <%=object_data.lowerName%>_ptr =\n                boost::dynamic_pointer_cast<<%=object_data.codeNameOrName%>>(objectReflector.getObjectRootSP());\n        if ( <%=object_data.lowerName%>_ptr != NULL ) {\n            handleObjectClass(<%=object_data.lowerName%>_ptr);\n            continue;\n        }\n<% }) -%>\n        std::cerr << \"unhandled object reflection \" << objectReflector.getObjectRootSP()->getClassName() << std::endl;\n    }\n<% } -%>\n<% if (subscribedinteractiondata.length > 0) { -%>\n\n    InteractionRoot::SP interactionRootSP;\n    while ( ( interactionRootSP = getNextInteraction() ) != 0 ) {\n<% (subscribedinteractiondata.sort(function(a, b){return b.fullName.length-a.fullName.length})).forEach(function(interaction_data){ -%>\n        boost::shared_ptr<<%=interaction_data.codeNameOrName%>> <%=interaction_data.lowerName%>_ptr =\n                boost::dynamic_pointer_cast<<%=interaction_data.codeNameOrName%>>(interactionRootSP);\n        if ( <%=interaction_data.lowerName%>_ptr != NULL ) {\n            handleInteractionClass( <%=interaction_data.lowerName%>_ptr );\n            continue;\n        }\n<% }) -%>\n        std::cerr << \"unhandled interaction \" << interactionRootSP->getClassName() << std::endl;\n    }\n<% } -%>\n}\n<% } -%>\n\nvoid <%=classname%>::execute( void ) {\n<% if (subscribedobjectdata.length + subscribedinteractiondata.length > 0) { -%>\n    checkReceivedSubscriptions();\n<% } -%>\n<% if (publishedobjectdata.length > 0) { -%>\n\n    // TODO update registered object instances\n<% publishedobjectdata.forEach(function(object_data) { -%>\n\n<% object_data.parameters.forEach(function(parameter) { -%>\n    // v<%=object_data.codeNameOrName%>.set_<%=parameter.name%>( YOUR_VALUE_HERE );\n<% }) -%>\n    // v<%=object_data.codeNameOrName%>.updateAttributeValues( getRTI(), m_currentTime + getLookAhead() );\n<% }) -%>\n<% } -%>\n<% if (publishedinteractiondata.length > 0) { -%>\n\n    // TODO send interactions\n<% publishedinteractiondata.forEach(function(interaction_data) { -%>\n\n    // <%=interaction_data.codeNameOrName%>SP v<%=interaction_data.codeNameOrName%> = create_<%=interaction_data.codeNameOrName%>();\n<% interaction_data.parameters.forEach(function(parameter) { -%>\n    // v<%=interaction_data.codeNameOrName%>->set_<%=parameter.name%>( YOUR_VALUE_HERE );\n<% }) -%>\n    // v<%=interaction_data.codeNameOrName%>->sendInteraction( getRTI(), m_currentTime + getLookAhead() );\n<% }) -%>\n<% } -%>\n    \n    m_currentTime += 1;\n    <%=classname%>ATRCallback advanceTimeRequest( *this );\n    putAdvanceTimeRequest( m_currentTime, advanceTimeRequest );\n}\n<% subscribedobjectdata.forEach(function(object_data) { -%>\n\nvoid <%=classname%>::handleObjectClass(boost::shared_ptr<<%=object_data.codeNameOrName%>> object) {\n    // TODO implement how to handle received object update\n}\n<% }); -%>\n<% subscribedinteractiondata.forEach(function(interaction_data) { -%>\n\nvoid <%=classname%>::handleInteractionClass(boost::shared_ptr<<%=interaction_data.codeNameOrName%>> interaction) {\n    // TODO implement how to handle received interaction\n}\n<% }); -%>\n\nint main( int argc, char *argv[] ) {\n    FederateConfigParser *configParser = new FederateConfigParser();\n    FederateConfig *config = configParser->parseArgs( argc, argv );\n    std::cout << \"Creating <%=classname%> instance\" << std::endl;\n    <%=classname%> federateInstance( config );\n    federateInstance.initialize();\n    std::cout << \"Running <%=classname%> instance\" << std::endl;\n    federateInstance.run();\n    return 0;\n}\n",
    "cpp/federateimpl.hpp.ejs": "<% /*\n\ninput properties\n----------------\nclassname\ninteraction_data\nobject_data\npublishedinteractiondata\npublishedobjectdata\nsubscribedinteractiondata\nsubscribedobjectdata\n\nused in\n-------\nCppImplFederate.js\n\n*/ -%>\n#ifndef _<%=classname.toUpperCase()%>_CLASS\n#define _<%=classname.toUpperCase()%>_CLASS\n\n#include \"<%=classname%>Base.hpp\"\n#include \"FederateConfigParser.h\"\n#include \"FederateConfig.h\"\n\n\nclass <%=classname%> : public <%=classname%>Base {\n    private:\n        double m_currentTime;\n<% if (publishedobjectdata.length > 0) { -%>\n\n        // TODO declare all the published object instances\n<% publishedobjectdata.forEach(function(object_data) { -%>\n        // <%=object_data.codeNameOrName%> v<%=object_data.codeNameOrName%>;\n<% }) -%>\n\n        void initObjectInstances();\n<%} -%>\n<% subscribedobjectdata.forEach(function(object_data) { -%>\n\n        void handleObjectClass(boost::shared_ptr<<%=object_data.codeNameOrName%>> object);\n<% }); -%>\n<% subscribedinteractiondata.forEach(function(interaction_data) { -%>\n\n        void handleInteractionClass(boost::shared_ptr<<%=interaction_data.codeNameOrName%>> interaction);\n<% }); -%>\n\n<% if (subscribedobjectdata.length + subscribedinteractiondata.length > 0) { -%>\n        void checkReceivedSubscriptions();\n\n<% } -%>\n    public:\n        typedef <%=classname%>Base Super;\n\n        <%=classname%>(FederateConfig *configuration): Super(configuration) {}\n\n        virtual ~<%=classname%>( void ) throw (RTI::FederateInternalError) {}\n\n        class <%=classname%>ATRCallback : public ATRCallback {\n            private:\n                <%=classname%> &m_federateInstance;\n            public:\n                <%=classname%>ATRCallback(<%=classname%> &federateInstance): m_federateInstance(federateInstance) {}\n                \n                virtual void execute( void ) {\n                    m_federateInstance.execute();\n                }\n\n                virtual SP clone( void ) {\n                    return SP(new <%=classname%>ATRCallback(*this));\n                }\n        };\n\n        void initialize( void );\n        void execute( void );\n};\n\n#endif\n",
    "cpp/mvn-package-install.sh.ejs": "<% /*\ninput properties\n----------------\nnone\n\nused in\n-------\nCppImplFederate.js\n\n*/ -%>\n#!/bin/bash\nmvn clean package install -U\n",
    "cpp/omnetfilter.cpp.ejs": "<% /*\ninput properties used\n---------------------\nprojectname\nsubscribedinteractiondata\n\nused in\n-------\nOmnetFederate.js\n\n*/ -%>\n/*\n * Copyright (c) 2016, Institute for Software Integrated Systems, Vanderbilt University\n * All rights reserved.\n *\n * Permission to use, copy, modify, and distribute this software and its\n * documentation for any purpose, without fee, and without written agreement is\n * hereby granted, provided that the above copyright notice, the following\n * two paragraphs and the author appear in all copies of this software.\n *\n * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\n * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT\n * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n *\n * @author Himanshu Neema\n */\n\n#include \"<%=projectname%>FilterInit.h\"\n#include \"OmnetFOMInteractions.h\"\n//#include \"<%=projectname%>NonOmnetNonGenericSources.hpp\"\n\n<% /* TK note: \".name\" below may need to be \".codeNameOrName\" */ -%>\n\nvoid <%=projectname%>FilterInit::execute( SubscribedInteractionFilter &subscribedInteractionFilter ) {\n    <% /*subscribedinteractiondata:initInteractionFilter()*/ %>\n    <% subscribedinteractiondata.forEach(function(subscribedinteractiondata){%>\n    subscribedInteractionFilter.setFedFilters( <%=subscribedinteractiondata.name%>::get_handle(), SubscribedInteractionFilter::<%=subscribedinteractiondata.originFedFilter()%>, SubscribedInteractionFilter::<%=subscribedinteractiondata.srcFedFilter()%> );<%});%>\n\n}\n\nstatic bool init( void ) {\n    SubscribedInteractionFilter::get_singleton().setFilterInit( <%=projectname%>FilterInit::create() );\n    return true;\n}\n\nstatic bool static_init = init();\n\n\n",
    "cpp/omnetfilter.hpp.ejs": "<% /*\ninput properties used\n---------------------\nprojectname  string\n\nused in\n-------\nOmnetFederate.js\n\n*/ -%>\n/*\n * Copyright (c) 2016, Institute for Software Integrated Systems, Vanderbilt University\n * All rights reserved.\n *\n * Permission to use, copy, modify, and distribute this software and its\n * documentation for any purpose, without fee, and without written agreement is\n * hereby granted, provided that the above copyright notice, the following\n * two paragraphs and the author appear in all copies of this software.\n *\n * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\n * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT\n * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n *\n * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n *\n * @author Himanshu Neema\n */\n#ifndef _ISIS_<%=projectname%>_H_\n#define _ISIS_<%=projectname%>_H_\n\n#include \"SubscribedInteractionFilter.hpp\"\n\nstruct <%=projectname%>FilterInit : public SubscribedInteractionFilter::FilterInit {\n    static SP create( void ) { return SP( new <%=projectname%>FilterInit() ); }\n\n    virtual void execute( SubscribedInteractionFilter &subscribedInteractionFilter );\n};\n\n#endif\n",
    "cppEmacsFormat/federate.cpp.ejs": "<%/* group cppfederate;\n\nfederate(\n        simname,\n        classname,\n        isnonmapperfed,\n        timeconstrained,\n        timeregulating,\n        lookahead,\n        asynchronousdelivery,\n        allinteractiondata,\n        publishedinteractiondata,\n        subscribedinteractiondata,\n        allobjectdata,\n        publishedobjectdata,\n        subscribedobjectdata\n)\n*/ -%>\n\n#include \"<%=classname%>Base.hpp\"\n\nvoid <%=classname%>Base::init()\n{\n  createRTI();\n  joinFederation();\n<% if (timeconstrained){ -%>\n  enableTimeConstrained();\n<%} -%>\n<% if (timeregulating){ -%>\n  enableTimeRegulation(getLookAhead());\n<%} -%>\n<% if (asynchronousdelivery){ -%>\n  enableAsynchronousDelivery();\n<%} -%>\n<% if (publishedinteractiondata.length || subscribedinteractiondata.length) {-%>\n\n  // interaction pubsub\n<%} -%>\n<% publishedinteractiondata.forEach(function(interactiondata){ -%>\n  <%=interactiondata.name%>::publish(getRTI());\n<%}); -%>\n<% subscribedinteractiondata.forEach(function(interactiondata){ -%>  \n  <%=interactiondata.name%>::subscribe(getRTI());\n  _subscribedInteractionFilter.setFedFilters(\n    <%=interactiondata.name%>::get_handle(),\n    SubscribedInteractionFilter::<%=interactiondata.originFedFilter()%>,\n    SubscribedInteractionFilter::<%=interactiondata.srcFedFilter()%>);\n<%}); -%>\n<% if (publishedobjectdata.length || subscribedobjectdata.length) {-%>\n\n  // object pubsub\n<%} -%>\n<% publishedobjectdata.forEach(function(objectdata){ -%>\n<% objectdata.publishedAttributeData.forEach(function(attributedata){ -%>\n  <%=objectdata.name%>::publish_<%=attributedata.name%>();\n<%}); -%>\n  <%=objectdata.name%>::publish(getRTI());\n<%}); -%>\n<% subscribedobjectdata.forEach(function(objectdata){ -%>\n<% objectdata.subscribedAttributeData.forEach(function(attributedata){ -%>\n  <%=objectdata.name%>::subscribe_<%=attributedata.name%>();\n<%}); -%>\n  <%=objectdata.name%>::subscribe(getRTI());\n<%}); -%>\n}\n\n<%=classname%>Base::<%=classname%>Base(FederateConfig *fedconfig) :\n  Super(fedconfig)\n{\n  init();\n}\n<% publishedinteractiondata.forEach(function(interactiondata){ -%>\n\n<%=interactiondata.name%>SP <%=classname%>Base::create_<%=interactiondata.name%>(void)\n  {\n    <%=interactiondata.name%>SP interactionSP =\n      <%=interactiondata.name%>::create();\n    interactionSP->set_sourceFed(getFederateId());\n    interactionSP->set_originFed(getFederateId());\n    return interactionSP;\n  }\n<%}); -%>\n\nvoid <%=classname%>Base::receiveInteraction(\n         RTI::InteractionClassHandle theInteraction,\n         const RTI::ParameterHandleValuePairSet& theParameters,\n         const RTI::FedTime& theTime,\n         const char *theTag,\n         RTI::EventRetractionHandle theHandle)\n  throw (RTI::InteractionClassNotKnown,\n         RTI::InteractionParameterNotKnown,\n         RTI::InvalidFederationTime,\n         RTI::FederateInternalError)\n{\n  if (getMoreATRs())\n    {\n      InteractionRoot::SP interactionRootSP =\n        InteractionRoot::create_interaction(theInteraction, theParameters,\n                                            theTime);\n      C2WInteractionRootSP c2wInteractionRootSP =\n        boost::dynamic_pointer_cast<C2WInteractionRoot>(interactionRootSP);\n      if (c2wInteractionRootSP != 0)\n        { // Filter interaction if src/origin fed\n          // requirements (if any) are not met\n          if (_subscribedInteractionFilter.\n              filterC2WInteraction(getFederateId(), c2wInteractionRootSP))\n            {\n              return;\n            }\n        }\n      Super::receiveInteraction(theInteraction, theParameters, theTime,\n                                theTag, theHandle);\n    }\n}\n\nvoid <%=classname%>Base::receiveInteraction(\n         RTI::InteractionClassHandle theInteraction,\n         const RTI::ParameterHandleValuePairSet& theParameters,\n         const char *theTag)\n  throw (RTI::InteractionClassNotKnown,\n         RTI::InteractionParameterNotKnown,\n         RTI::FederateInternalError)\n{\n  if (getMoreATRs())\n    {\n      InteractionRoot::SP interactionRootSP =\n        InteractionRoot::create_interaction(theInteraction, theParameters);\n      C2WInteractionRootSP c2wInteractionRootSP =\n        boost::dynamic_pointer_cast<C2WInteractionRoot>(interactionRootSP);\n      if (c2wInteractionRootSP != 0)\n        { // Filter interaction if src/origin fed\n          // requirements (if any) are not met\n          if (_subscribedInteractionFilter.\n              filterC2WInteraction(getFederateId(), c2wInteractionRootSP))\n            {\n              return;\n            }\n        }\n      Super::receiveInteraction(theInteraction, theParameters, theTag);\n    }\n}\n",
    "cppEmacsFormat/federate.hpp.ejs": "<%/* group cppfederate;\n\nfederate(\n        simname,\n        classname,\n        isnonmapperfed,\n        timeconstrained,\n        timeregulating,\n        lookahead,\n        asynchronousdelivery,\n        allinteractiondata,\n        publishedinteractiondata,\n        subscribedinteractiondata,\n        allobjectdata,\n        publishedobjectdata,\n        subscribedobjectdata\n)\n*/ -%>\n#ifndef _<%=classname%>Base_\n#define _<%=classname%>Base_\n\n#include <vector>\n\n#include \"SynchronizedFederate.hpp\"\n#include \"SubscribedInteractionFilter.hpp\"\n\n<% allinteractiondata.forEach(function(interactiondata){ -%>\n#include \"rti/<%=interactiondata.name%>.hpp\"\n<%});-%>\n<% allobjectdata.forEach(function(objectdata){ -%>\n#include \"rti/<%=objectdata.name%>.hpp\"\n<%});-%>\n#include \"C2WLogger.hpp\"\n\n#include \"FederateConfig.h\"\n\nclass <%=classname%>Base : public SynchronizedFederate\n{\n\npublic:\n  typedef SynchronizedFederate Super;\n\n  typedef std::vector< std::string > ArgVector;\n\n  static double getLookAhead(void)\n  {\n    static double lookAhead = <%=lookahead%>;\n    return lookAhead;\n  }\n\n  virtual ~<%=classname%>Base(void)\n    throw (RTI::FederateInternalError) { }\n\nprivate:\n  SubscribedInteractionFilter _subscribedInteractionFilter;\n\nprotected:\n  void init();\n\npublic:\n  // constructor\n  <%=classname%>Base(FederateConfig *fedconfig);\n<% publishedinteractiondata.forEach(function(interactiondata){ -%>\n\n  <%=interactiondata.name%>SP create_<%=interactiondata.name%>(void);\n<%}); -%>\n\n  virtual void receiveInteraction(\n         RTI::InteractionClassHandle theInteraction,\n         const RTI::ParameterHandleValuePairSet& theParameters,\n         const RTI::FedTime& theTime,\n         const char *theTag,\n         RTI::EventRetractionHandle theHandle)\n    throw (RTI::InteractionClassNotKnown,\n           RTI::InteractionParameterNotKnown,\n           RTI::InvalidFederationTime,\n           RTI::FederateInternalError);\n\n  virtual void receiveInteraction(\n         RTI::InteractionClassHandle theInteraction,\n         const RTI::ParameterHandleValuePairSet& theParameters,\n         const char *theTag)\n    throw (RTI::InteractionClassNotKnown,\n           RTI::InteractionParameterNotKnown,\n           RTI::FederateInternalError);\n};\n\n#endif\n",
    "java/class.java.ejs": "<% /*\ninput properties\n----------------\nalldatamembers       array\nclassname            string\ncodeclassname        string\ndatamembers          array\nejs                  ejs\nhelpers              object\nhlaclassname         string\nisc2winteractionroot boolean\nisinteraction        boolean\nparentclassname      string\nsimname              string\nTEMPLATES            object\n\nused in\n-------\nJavaRTI.js\n\n*/ -%>\n\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.cpswt.utils.CpswtUtils;\n\n<% if(isinteraction){ -%>\nimport hla.rti.FederateNotExecutionMember;\nimport hla.rti.InteractionClassNotDefined;\nimport hla.rti.InteractionClassNotPublished;\nimport hla.rti.InteractionClassNotSubscribed;\nimport hla.rti.LogicalTime;\nimport hla.rti.NameNotFound;\nimport hla.rti.RTIambassador;\nimport hla.rti.ReceivedInteraction;\n<% } else { -%>\nimport hla.rti.AttributeHandleSet;\nimport hla.rti.FederateNotExecutionMember;\nimport hla.rti.LogicalTime;\nimport hla.rti.NameNotFound;\nimport hla.rti.ObjectClassNotDefined;\nimport hla.rti.ObjectClassNotPublished;\nimport hla.rti.ObjectClassNotSubscribed;\nimport hla.rti.RTIambassador;\nimport hla.rti.ReflectedAttributes;\nimport hla.rti.SuppliedAttributes;\n<% } -%>\n<% if(simname !== 'org.cpswt.hla'){ -%>\n\nimport org.cpswt.hla.*;\n<% } -%>\n\n/**\n* Implements <%=hlaclassname%>\n*/\npublic class <%=codeclassname%> extends <%=parentclassname%> {\n\n    private static final Logger logger = LogManager.getLogger();\n\n    /**\n    * Creates an instance of the <%=codeclassname%> <%=isinteraction?\"interaction\":\"object\"%> class with default <%=isinteraction?\"parameter\":\"attribute\"%> values.\n    */\n    public <%=codeclassname%>() {}\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\n\n<% /*alldatamembers:handle()*/ -%>\n<% alldatamembers.forEach(function(datamember){ -%>\n    private static int _<%=datamember.name%>_handle;\n<% }); -%>\n<% } -%>\n\n<% /*classcommon(...)*/ -%>\n<%- ejs.render(TEMPLATES[\"java/classcommon.java.ejs\"],\n    {alldatamembers: alldatamembers,\n     classname: classname,\n     codeclassname: codeclassname,\n     datamembers: datamembers,\n     hlaclassname: hlaclassname,\n     isinteraction: isinteraction,\n     parentclassname: parentclassname\n}) -%>\n<% if(isc2winteractionroot){ -%>\n\n    @Override\n    public void sendInteraction( RTIambassador rti, double time ) {\n        if (  get_sourceFed() == null || \"\".equals( get_sourceFed() ) || get_originFed() == null || \"\".equals( get_originFed() )  ) {\n            throw new Exception( \"source and/or origin federate not specified.\" );\n        }\n        super.sendInteraction( rti, time );\n    }\n\n    @Override\n    public void sendInteraction( RTIambassador rti ) {\n        if (  get_sourceFed() == null || \"\".equals( get_sourceFed() ) || get_originFed() == null || \"\".equals( get_originFed() )  ) {\n            throw new Exception( \"source and/or origin federate not specified.\" );\n        }\n        super.sendInteraction( rti );\n    }\n<% } -%>\n<% if(isinteraction){ -%>\n<% if(datamembers && datamembers.length > 0){ -%>\n\n<% datamembers.forEach(function(parameter){ -%>\n<% /*datamembers:interactionmembers()*/ -%>\n    private <%=parameter.parameterType%> _<%=parameter.name%> = <%-helpers.initialvalue(parameter.parameterType)%>;\n<% }); -%>\n\n<% datamembers.forEach(function(parameter){ -%>\n<% /*datamembers:interactionsetters()*/ -%>\n    /**\n    * Set the value of the \"<%=parameter.name%>\" parameter to \"value\" for this parameter.\n    *\n    * @param value the new value for the \"<%=parameter.name%>\" parameter\n    */\n    public void set_<%=parameter.name%>( <%=parameter.parameterType%> value ) {\n        _<%=parameter.name%> = value;\n    }\n\n<% /*datamembers:interactiongetters()*/ -%>\n    /**\n    * Returns the value of the \"<%=parameter.name%>\" parameter of this interaction.\n    *\n    * @return the value of the \"<%=parameter.name%>\" parameter\n    */\n    public <%=parameter.parameterType%> get_<%=parameter.name%>() {\n        return _<%=parameter.name%>;\n    }\n<% }); -%>\n<% } -%>\n<% }else{ %>\n<% alldatamembers.forEach(function(attribute){ -%>\n\n<% /* alldatamembers:{ a |<publish(attribute=a)> } */ -%>\n    /**\n    * Publishes the \"<%=attribute.name%>\" attribute of the attribute's containing object\n    * class for a federate.\n    * Note:  This method only marks the \"<%=attribute.name%>\" attribute for publication.\n    * To actually publish the attribute, the federate must (re)publish its containing\n    * object class.\n    * (using &lt;objectClassName&gt;.publish( RTIambassador rti ) ).\n    */\n    public static void publish_<%=attribute.name%>() {\n        _publishAttributeNameSet.add( \"<%=attribute.name%>\" );\n    }\n\n    /**\n    * Unpublishes the \"<%=attribute.name%>\" attribute of the attribute's containing object\n    * class for a federate.\n    * Note:  This method only marks the \"<%=attribute.name%>\" attribute for unpublication.\n    * To actually publish the attribute, the federate must (re)publish its containing\n    * object class.\n    * (using &lt;objectClassName&gt;.publish( RTIambassador rti ) ).\n    */\n    public static void unpublish_<%=attribute.name%>() {\n        _publishAttributeNameSet.remove( \"<%=attribute.name%>\" );\n    }\n\n<% /* alldatamembers:{ a |<subscribe(attribute=a)> } */ -%>\n    /**\n    * Subscribes a federate to the \"<%=attribute.name%>\" attribute of the attribute's\n    * containing object class.\n    * Note:  This method only marks the \"<%=attribute.name%>\" attribute for subscription.\n    * To actually subscribe to the attribute, the federate must (re)subscribe to its\n    * containing object class.\n    * (using &lt;objectClassName&gt;.subscribe( RTIambassador rti ) ).\n    */\n    public static void subscribe_<%=attribute.name%>() {\n        _subscribeAttributeNameSet.add( \"<%=attribute.name%>\" );\n    }\n\n    /**\n    * Unsubscribes a federate from the \"<%=attribute.name%>\" attribute of the attribute's\n    * containing object class.\n    * Note:  This method only marks the \"<%=attribute.name%>\" attribute for unsubscription.\n    * To actually unsubscribe to the attribute, the federate must (re)subscribe to its\n    * containing object class.\n    * (using &lt;objectClassName&gt;.subscribe( RTIambassador rti ) ).\n    */\n    public static void unsubscribe_<%=attribute.name%>() {\n        _subscribeAttributeNameSet.remove( \"<%=attribute.name%>\" );\n    }\n<% }); -%>\n<% datamembers.forEach(function(datamember){ -%>\n\n<% /*datamembers:objectmembers()*/ -%>\n    protected Attribute< <%= helpers.primitive2object(datamember.parameterType) %> > _<%=datamember.name%> =\n            new Attribute< <%= helpers.primitive2object(datamember.parameterType) %> >(  new <%= helpers.primitive2object(datamember.parameterType)%>( <%-helpers.initialvalue(datamember.parameterType)%> )  );\n\n<% /*datamembers:objectsetters()*/ -%>\n    /**\n    * Set the value of the \"<%=datamember.name%>\" attribute to \"value\" for this object.\n    *\n    * @param value the new value for the \"<%=datamember.name%>\" attribute\n    */\n    public void set_<%=datamember.name%>( <%=datamember.parameterType%> value ) {\n        _<%=datamember.name%>.setValue( value );\n        _<%=datamember.name%>.setTime( getTime() );\n    }\n\n<% /*datamembers:objectgetters()*/ -%>\n    /**\n    * Returns the value of the \"<%=datamember.name%>\" attribute of this object.\n    *\n    * @return the value of the \"<%=datamember.name%>\" attribute\n    */\n    public <%=datamember.parameterType%> get_<%=datamember.name%>() {\n        return _<%=datamember.name%>.getValue();\n    }\n\n<% /*datamembers:objecttimegetters()*/ -%>\n    /**\n    * Returns the current timestamp of the \"<%=datamember.name%>\" attribute of this object.\n    *\n    * @return the current timestamp of the \"<%=datamember.name%>\" attribute\n    */\n    public double get_<%=datamember.name%>_time() {\n        return _<%=datamember.name%>.getTime();\n    }\n<% }); -%>\n<% } -%>\n\n    protected <%=codeclassname%>( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, boolean initFlag ) {\n        super( datamemberMap, false );\n        if ( initFlag ) set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>s( datamemberMap );\n    }\n\n    protected <%=codeclassname%>( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, LogicalTime logicalTime, boolean initFlag ) {\n        super( datamemberMap, logicalTime, false );\n        if ( initFlag ) set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>s( datamemberMap );\n    }\n\n    /**\n    * Creates an instance of the <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class, using\n    * \"datamemberMap\" to initialize its <%=isinteraction?\"parameter\":\"attribute\"%> values.\n    * \"datamemberMap\" is usually acquired as an argument to an RTI federate\n    * callback method, such as \"receiveInteraction\".\n    *\n    * @param datamemberMap data structure containing initial values for the\n    * <%=isinteraction?\"parameter\":\"attribute\"%>s of this new <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class instance\n    */\n    public <%=codeclassname%>( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap ) {\n        this( datamemberMap, true );\n    }\n\n    /**\n    * Like {@link #<%=classname%>( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap )}, except this\n    * new <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class instance is given a timestamp of\n    * \"logicalTime\".\n    *\n    * @param datamemberMap data structure containing initial values for the\n    * <%=isinteraction?\"parameter\":\"attribute\"%>s of this new <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class instance\n    * @param logicalTime timestamp for this new <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class\n    * instance\n    */\n    public <%=codeclassname%>( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, LogicalTime logicalTime ) {\n        this( datamemberMap, logicalTime, true );\n    }\n\n    /**\n    * Creates a new <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class instance that is a duplicate\n    * of the instance referred to by <%=classname%>_var.\n    *\n    * @param <%=classname%>_var <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class instance of which\n    * this newly created <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class instance will be a\n    * duplicate\n    */\n    public <%=codeclassname%>( <%=codeclassname%> <%=classname%>_var ) {\n        super( <%=classname%>_var );\n<% if(datamembers && datamembers.length > 0){ -%>\n\n<% /*datamembers:{ d |<rticlasscopyvalue(classname=classname,datamember=d)>}*/ -%>\n<% datamembers.forEach(function(datamember){ -%>\n        set_<%=datamember.name%>( <%=classname%>_var.get_<%=datamember.name%>() );\n<% }); -%>\n<% } -%>\n    }\n<% if(datamembers && datamembers.length > 0){ -%>\n\n    /**\n    * Returns the value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose name is \"datamemberName\"\n    * for this <%=isinteraction?\"interaction\":\"object\"%>.\n    *\n    * @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%> whose value is to be\n    * returned\n    * @return value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose name is \"datamemberName\"\n    * for this <%=isinteraction?\"interaction\":\"object\"%>\n    */\n    public Object get<%= isinteraction ? \"Parameter\" : \"Attribute\" %>( String datamemberName ) {\n<% /*first(datamembers):startgetbyname()*/ -%>\n<% /*rest(datamembers):continuegetbyname()*/ -%>\n<% for(var i = 0; i<datamembers.length; i++ ){ -%>\n        <%= i == 0  ? 'if' : 'else if'%> ( \"<%=datamembers[i].name%>\".equals(datamemberName) ) return <%=helpers.get(datamembers[i].parameterType, datamembers[i].name)%>;\n<% } -%>\n        else return super.get<%= isinteraction ? \"Parameter\" : \"Attribute\" %>( datamemberName );\n    }\n\n    protected boolean set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>Aux( String datamemberName, String val ) {\n        boolean retval = true;\n<% /*first(datamembers):startifstring()*/ -%>\n<% /*rest(datamembers):continueifstring()*/ -%>\n<% for(var i = 0; i<datamembers.length; i++ ){ -%>\n        <%= i == 0  ? 'if' : 'else if'%> ( \"<%=datamembers[i].name%>\".equals( datamemberName) ) set_<%=datamembers[i].name%>( <%=helpers.set(datamembers[i].parameterType)%> );\n<% } -%>\n        else retval = super.set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>Aux( datamemberName, val );\n\n        return retval;\n    }\n\n    protected boolean set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>Aux( String datamemberName, Object val ) {\n        boolean retval = true;\n<% /*first(datamembers):startifname()*/ -%>\n<% /*rest(datamembers):continueifname()*/ -%>\n<% for(var i = 0; i<datamembers.length; i++ ){ -%>\n        <%= i == 0  ? 'if' : 'else if'%> ( \"<%=datamembers[i].name%>\".equals( datamemberName) ) set_<%=datamembers[i].name%>( (<%= helpers.primitive2object(datamembers[i].parameterType)%>)val );\n<% } -%>\n        else retval = super.set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>Aux( datamemberName, val );\n\n        return retval;\n    }\n<% } -%>\n<% if(!isinteraction){ -%>\n\n    @Override\n    protected SuppliedAttributes createSuppliedDatamembers(boolean force) {\n        SuppliedAttributes datamembers = _factory.createSuppliedAttributes();\n <% alldatamembers.forEach(function(datamember){ -%>\n\n        if (_publishAttributeNameSet.contains(\"<%=datamember.name%>\") && _<%=datamember.name%>.shouldBeUpdated(force)) {\n            datamembers.add( getAttributeHandle(\"<%=datamember.name%>\"), getAttribute(\"<%=datamember.name%>\").toString().getBytes() );\n            _<%=datamember.name%>.setHasBeenUpdated();\n        }\n<% }); -%>\n\n        return datamembers;\n    }\n<% } -%>\n\n    public void copyFrom( Object object ) {\n        super.copyFrom( object );\n        if ( object instanceof <%=codeclassname%> ) {\n            <%=codeclassname%> data = (<%=codeclassname%>)object;\n<% /*datamembers:copydatamember();separator = \"\\n\"*/ -%>\n<% datamembers.forEach(function(datamember){ -%>\n            _<%=datamember.name%> = data._<%=datamember.name%>;\n<% }); -%>\n        }\n    }\n}\n\n",
    "java/classcommon.java.ejs": "<% /*\ninput properties\n----------------\nalldatamembers\nclassname\ncodeclassname\ndatamembers\nhlaclassname\nisinteraction\nparentclassname\n\nused in\n-------\nclass.java.ejs\nclassroot.java.ejs\n\n*/ -%>\n<% var IntOb = isinteraction ? \"Interaction\" : \"Object\"; -%>\n<% var intob = isinteraction ? \"interaction\" : \"object\"; -%>\n<% var Field = isinteraction ? \"Parameter\" : \"Attribute\"; -%>\n<% var field = isinteraction ? \"parameter\" : \"attribute\"; -%>\n    private static boolean _isInitialized = false;\n\n    private static int _handle;\n\n    /**\n    * Returns the handle (RTI assigned) of the <%=classname%> <%=intob%> class.\n    * Note: As this is a static method, it is NOT polymorphic, and so, if called on\n    * a reference will return the handle of the class pertaining to the reference,\n    * rather than the handle of the class for the instance referred to by the reference.\n    * For the polymorphic version of this method, use {@link #getClassHandle()}.\n    *\n    * @return the RTI assigned integer handle that represents this <%=intob%> class\n    */\n    public static int get_handle() {\n        return _handle;\n    }\n\n    /**\n    * Returns the fully-qualified (dot-delimited) name of the <%=classname%> <%=intob%> class.\n    * Note: As this is a static method, it is NOT polymorphic, and so, if called on\n    * a reference will return the name of the class pertaining to the reference,\n    * rather than the name of the class for the instance referred to by the reference.\n    * For the polymorphic version of this method, use {@link #getClassName()}.\n    *\n    * @return the fully-qualified HLA class path for this <%=intob%> class\n    */\n    public static String get_class_name() {\n        return \"<%=hlaclassname%>\";\n    }\n\n    /**\n    * Returns the simple name (the last name in the dot-delimited fully-qualified\n    * class name) of the <%=classname%> <%=intob%> class.\n    *\n    * @return the name of this <%=intob%> class\n    */\n    public static String get_simple_class_name() {\n        return \"<%=classname%>\";\n    }\n\n    private static Set< String > _datamemberNames = new HashSet< String >();\n    private static Set< String > _allDatamemberNames = new HashSet< String >();\n\n    /**\n    * Returns a set containing the names of all of the non-hidden <%=field%>s in the\n    * <%=classname%> <%=intob%> class.\n    * Note: As this is a static method, it is NOT polymorphic, and so, if called on\n    * a reference will return a set of parameter names pertaining to the reference,\n    * rather than the parameter names of the class for the instance referred to by\n    * the reference.  For the polymorphic version of this method, use\n    * {@link #get<%=Field%>Names()}.\n    *\n    * @return a modifiable set of the non-hidden <%=field%> names for this <%=intob%> class\n    */\n    public static Set< String > get_<%=field%>_names() {\n        return new HashSet< String >(_datamemberNames);\n    }\n\n    /**\n    * Returns a set containing the names of all of the <%=field%>s in the\n    * <%=classname%> <%=intob%> class.\n    * Note: As this is a static method, it is NOT polymorphic, and so, if called on\n    * a reference will return a set of parameter names pertaining to the reference,\n    * rather than the parameter names of the class for the instance referred to by\n    * the reference.  For the polymorphic version of this method, use\n    * {@link #get<%=Field%>Names()}.\n    *\n    * @return a modifiable set of the <%=field%> names for this <%=intob%> class\n    */\n    public static Set< String > get_all_<%=field%>_names() {\n        return new HashSet< String >(_allDatamemberNames);\n    }\n<% if(!isinteraction){ -%>\n\n    private static Set< String > _publishAttributeNameSet = new HashSet< String >();\n    private static Set< String > _subscribeAttributeNameSet = new HashSet< String >();\n<% } -%>\n\n    static {\n        _classNameSet.add(\"<%= hlaclassname %>\");\n        _classNameClassMap.put(\"<%= hlaclassname %>\", <%= codeclassname %>.class);\n\n        _datamemberClassNameSetMap.put(\"<%= hlaclassname %>\", _datamemberNames);\n        _allDatamemberClassNameSetMap.put(\"<%= hlaclassname %>\", _allDatamemberNames);\n<% if(datamembers && datamembers.length > 0){ -%>\n\n<% /*datamembers:initDatamemberNameSet()*/ -%>\n<% datamembers.forEach(function(datamember){ -%>\n<% if(!datamember.hidden && !datamember.inherited){ -%>\n        _datamemberNames.add(\"<%=datamember.name%>\");\n<% } -%>\n<% }); -%>\n\n<% /*datamembers:initDatamemberTypeMap()*/ -%>\n<% datamembers.forEach(function(datamember){ -%>\n        _datamemberTypeMap.put(\"<%=datamember.name%>\", \"<%=datamember.parameterType%>\");\n<% }); -%>\n<% } -%>\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\n\n<% /*alldatamembers:initAllDatamemberNameSet()*/ -%>\n<% alldatamembers.forEach(function(datamember){ -%>\n        _allDatamemberNames.add(\"<%=datamember.name%>\");\n<% }); -%>\n<% } -%>\n<% if(!isinteraction){ -%>\n\n        _classNamePublishAttributeNameMap.put(\"<%= hlaclassname %>\", _publishAttributeNameSet);\n        _classNameSubscribeAttributeNameMap.put(\"<%= hlaclassname %>\", _subscribeAttributeNameSet);\n<% } -%>\n    }\n\n    protected static void init(RTIambassador rti) {\n        if (_isInitialized) return;\n        _isInitialized = true;\n\n        <% if(parentclassname){ %><%=parentclassname%>.init(rti);<%}%>\n\n        boolean isNotInitialized = true;\n        while(isNotInitialized) {\n            try {\n                _handle = rti.get<%=IntOb%>ClassHandle(\"<%= hlaclassname %>\");\n                isNotInitialized = false;\n            } catch (FederateNotExecutionMember e) {\n                logger.error(\"could not initialize: Federate Not Execution Member\", e);\n                return;\n            } catch (NameNotFound e) {\n                logger.error(\"could not initialize: Name Not Found\", e);\n                return;\n            } catch (Exception e) {\n                logger.error(e);\n                CpswtUtils.sleepDefault();\n            }\n        }\n\n        _classNameHandleMap.put(\"<%= hlaclassname %>\", get_handle());\n        _classHandleNameMap.put(get_handle(), \"<%= hlaclassname %>\");\n        _classHandleSimpleNameMap.put(get_handle(), \"<%=classname%>\");\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\n\n        isNotInitialized = true;\n        while(isNotInitialized) {\n            try {\n<% /*alldatamembers:handle_init()*/ -%>\n<% alldatamembers.forEach(function(datamember){ -%>\n                _<%=datamember.name%>_handle = rti.get<%=Field%>Handle(\"<%=datamember.name%>\", get_handle());\n<% }); -%>\n                isNotInitialized = false;\n            } catch (FederateNotExecutionMember e) {\n                logger.error(\"could not initialize: Federate Not Execution Member\", e);\n                return;\n            } catch (<%=IntOb%>ClassNotDefined e) {\n                logger.error(\"could not initialize: <%=IntOb%> Class Not Defined\", e);\n                return;\n            } catch (NameNotFound e) {\n                logger.error(\"could not initialize: Name Not Found\", e);\n                return;\n            } catch (Exception e) {\n                logger.error(e);\n                CpswtUtils.sleepDefault();\n            }\n        }\n\n<% /*alldatamembers: { d |<initDatamemberNameHandleMap(hlaclassname=hlaclassname,datamember=d)>}*/ -%>\n<% alldatamembers.forEach(function(datamember){ -%>\n        _datamemberNameHandleMap.put(\"<%=hlaclassname%>.<%=datamember.name%>\", _<%=datamember.name%>_handle);\n<% }); -%>\n\n<% /*alldatamembers:initDatamemberHandleNameMap()*/ -%>\n<% alldatamembers.forEach(function(datamember){ -%>\n        _datamemberHandleNameMap.put(_<%=datamember.name%>_handle, \"<%=datamember.name%>\");\n<% }); -%>\n<% } -%>\n    }\n\n    private static boolean _isPublished = false;\n\n    /**\n    * Publishes the <%=classname%> <%=intob%> class for a federate.\n    *\n    * @param rti handle to the Local RTI Component\n    */\n    public static void publish(RTIambassador rti) {\n        if (_isPublished) return;\n\n        init(rti);\n<% if(!isinteraction){ -%>\n\n        AttributeHandleSet publishedAttributeHandleSet = _factory.createAttributeHandleSet();\n        for(String attributeName : _publishAttributeNameSet) {\n            try {\n                publishedAttributeHandleSet.add(_datamemberNameHandleMap.get(\"<%= hlaclassname %>.\" + attributeName));\n                logger.trace(\"publish {}:{}\", get_class_name(), attributeName);\n            } catch (Exception e) {\n                logger.error(\"could not publish \\\"\" + attributeName + \"\\\" attribute.\", e);\n            }\n        }\n<% } -%>\n\n        synchronized(rti) {\n            boolean isNotPublished = true;\n            while(isNotPublished) {\n                try {\n                    rti.publish<%=IntOb%>Class(get_handle()<% if(!isinteraction){ %>, publishedAttributeHandleSet<%}%>);\n                    isNotPublished = false;\n                } catch (FederateNotExecutionMember e) {\n                    logger.error(\"could not publish: Federate Not Execution Member\", e);\n                    return;\n                } catch (<%=IntOb%>ClassNotDefined e) {\n                    logger.error(\"could not publish: <%=IntOb%> Class Not Defined\", e);\n                    return;\n                } catch (Exception e) {\n                    logger.error(e);\n                    CpswtUtils.sleepDefault();\n                }\n            }\n        }\n\n        _isPublished = true;\n        logger.debug(\"publish: {}\", get_class_name());\n    }\n\n    /**\n    * Unpublishes the <%=classname%> <%=intob%> class for a federate.\n    *\n    * @param rti handle to the Local RTI Component\n    */\n    public static void unpublish(RTIambassador rti) {\n        if (!_isPublished) return;\n\n        init(rti);\n\n        synchronized(rti) {\n            boolean isNotUnpublished = true;\n            while(isNotUnpublished) {\n                try {\n                    rti.unpublish<%=IntOb%>Class(get_handle());\n                    isNotUnpublished = false;\n                } catch (FederateNotExecutionMember e) {\n                    logger.error(\"could not unpublish: Federate Not Execution Member\", e);\n                    return;\n                } catch (<%=IntOb%>ClassNotDefined e) {\n                    logger.error(\"could not unpublish: <%=IntOb%> Class Not Defined\", e);\n                    return;\n                } catch (<%=IntOb%>ClassNotPublished e) {\n                    logger.error(\"could not unpublish: <%=IntOb%> Class Not Published\", e);\n                    return;\n                } catch (Exception e) {\n                    logger.error(e);\n                    CpswtUtils.sleepDefault();\n                }\n            }\n        }\n\n        _isPublished = false;\n        logger.debug(\"unpublish: {}\", get_class_name());\n    }\n\n    private static boolean _isSubscribed = false;\n\n    /**\n    * Subscribes a federate to the <%=classname%> <%=intob%> class.\n    *\n    * @param rti handle to the Local RTI Component\n    */\n    public static void subscribe(RTIambassador rti) {\n        if (_isSubscribed) return;\n\n        init(rti);\n<% if(!isinteraction){ -%>\n\n        AttributeHandleSet subscribedAttributeHandleSet = _factory.createAttributeHandleSet();\n        for(String attributeName : _subscribeAttributeNameSet) {\n            try {\n                subscribedAttributeHandleSet.add(_datamemberNameHandleMap.get(\"<%= hlaclassname %>.\" + attributeName));\n                logger.trace(\"subscribe {}:{}\", get_class_name(), attributeName);\n            } catch (Exception e) {\n                logger.error(\"could not subscribe to \\\"\" + attributeName + \"\\\" attribute.\", e);\n            }\n        }\n<% } -%>\n\n        synchronized(rti) {\n            boolean isNotSubscribed = true;\n            while(isNotSubscribed) {\n                try {\n                    rti.subscribe<% if(isinteraction){ %>InteractionClass(get_handle())<% }else{ %>ObjectClassAttributes(get_handle(), subscribedAttributeHandleSet)<%}%>;\n                    isNotSubscribed = false;\n                } catch (FederateNotExecutionMember e) {\n                    logger.error(\"could not subscribe: Federate Not Execution Member\", e);\n                    return;\n                } catch (<%=IntOb%>ClassNotDefined e) {\n                    logger.error(\"could not subscribe: <%=IntOb%> Class Not Defined\", e);\n                    return;\n                } catch (Exception e) {\n                    logger.error(e);\n                    CpswtUtils.sleepDefault();\n                }\n            }\n        }\n\n        _isSubscribed = true;\n        logger.debug(\"subscribe: {}\", get_class_name());\n    }\n\n    /**\n    * Unsubscribes a federate from the <%=classname%> <%=intob%> class.\n    *\n    * @param rti handle to the Local RTI Component\n    */\n    public static void unsubscribe(RTIambassador rti) {\n        if (!_isSubscribed) return;\n\n        init(rti);\n\n        synchronized(rti) {\n            boolean isNotUnsubscribed = true;\n            while(isNotUnsubscribed) {\n                try {\n                    rti.unsubscribe<%=IntOb%>Class(get_handle());\n                    isNotUnsubscribed = false;\n                } catch (FederateNotExecutionMember e) {\n                    logger.error(\"could not unsubscribe: Federate Not Execution Member\", e);\n                    return;\n                } catch (<%=IntOb%>ClassNotDefined e) {\n                    logger.error(\"could not unsubscribe: <%=IntOb%> Class Not Defined\", e);\n                    return;\n                } catch (<%=IntOb%>ClassNotSubscribed e) {\n                    logger.error(\"could not unsubscribe: <%=IntOb%> Class Not Subscribed\", e);\n                    return;\n                } catch (Exception e) {\n                    logger.error(e);\n                    CpswtUtils.sleepDefault();\n                }\n            }\n        }\n\n        _isSubscribed = false;\n        logger.debug(\"unsubscribe: {}\", get_class_name());\n    }\n\n    /**\n    * Return true if \"handle\" is equal to the handle (RTI assigned) of this class\n    * (that is, the <%=classname%> <%=intob%> class).\n    *\n    * @param handle handle to compare to the value of the handle (RTI assigned) of\n    * this class (the <%=classname%> <%=intob%> class).\n    * @return \"true\" if \"handle\" matches the value of the handle of this class\n    * (that is, the <%=classname%> <%=intob%> class).\n    */\n    public static boolean match(int handle) {\n        return handle == get_handle();\n    }\n\n    /**\n    * Returns the handle (RTI assigned) of this instance's <%=intob%> class .\n    *\n    * @return the handle (RTI assigned) if this instance's <%=intob%> class\n    */\n    public int getClassHandle() {\n        return get_handle();\n    }\n\n    /**\n    * Returns the fully-qualified (dot-delimited) name of this instance's <%=intob%> class.\n    *\n    * @return the fully-qualified (dot-delimited) name of this instance's <%=intob%> class\n    */\n    public String getClassName() {\n        return get_class_name();\n    }\n\n    /**\n    * Returns the simple name (last name in its fully-qualified dot-delimited name)\n    * of this instance's <%=intob%> class.\n    *\n    * @return the simple name of this instance's <%=intob%> class\n    */\n    public String getSimpleClassName() {\n        return get_simple_class_name();\n    }\n\n    /**\n    * Returns a set containing the names of all of the non-hidden<%=field%>s of an\n    * <%=intob%> class instance.\n    *\n    * @return set containing the names of all of the <%=field%>s of an\n    * <%=intob%> class instance\n    */\n    public Set< String > get<%=Field%>Names() {\n        return get_<%=field%>_names();\n    }\n\n    /**\n    * Returns a set containing the names of all of the <%=field%>s of an\n    * <%=intob%> class instance.\n    *\n    * @return set containing the names of all of the <%=field%>s of an\n    * <%=intob%> class instance\n    */\n    public Set< String > getAll<%=Field%>Names() {\n        return get_all_<%=field%>_names();\n    }\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\n\n    @Override\n    public String get<%=Field%>Name(int datamemberHandle) {\n<% for(var i = 0; i<alldatamembers.length; i++ ){ -%>\n        <%= i == 0 ? 'if' : 'else if'%> (datamemberHandle == _<%=alldatamembers[i].name%>_handle) return \"<%=alldatamembers[i].name%>\";\n<% } -%>\n        else return super.get<%=Field%>Name(datamemberHandle);\n    }\n<% } -%>\n\n    /**\n    * Publishes the <%=intob%> class of this instance of the class for a federate.\n    *\n    * @param rti handle to the Local RTI Component\n    */\n    public void publish<%=IntOb%>(RTIambassador rti) {\n        publish(rti);\n    }\n\n    /**\n    * Unpublishes the <%=intob%> class of this instance of this class for a federate.\n    *\n    * @param rti handle to the Local RTI Component\n    */\n    public void unpublish<%=IntOb%>(RTIambassador rti) {\n        unpublish(rti);\n    }\n\n    /**\n    * Subscribes a federate to the <%=intob%> class of this instance of this class.\n    *\n    * @param rti handle to the Local RTI Component\n    */\n    public void subscribe<%=IntOb%>(RTIambassador rti) {\n        subscribe(rti);\n    }\n\n    /**\n    * Unsubscribes a federate from the <%=intob%> class of this instance of this class.\n    *\n    * @param rti handle to the Local RTI Component\n    */\n    public void unsubscribe<%=IntOb%>(RTIambassador rti) {\n        unsubscribe(rti);\n    }\n\n    @Override\n    public String toString() {\n        return getClass().getName() + \"(\"\n<% /*alldatamembers:stringValue(); separator=\"+ \\\",\\\"\"*/ -%>\n<% var separator = false; alldatamembers.forEach(function(datamember){ -%>\n                <%if(separator){%>+ \",\" <%}else{separator=true;}%>+ \"<%=datamember.name%>:\" + get_<%=datamember.name%>()\n<% }); -%>\n                + \")\";\n    }\n",
    "java/classroot.java.ejs": "<% /*\ninput properties\n----------------\nisinteraction boolean\n\nused in\n-------\nJavaRTI.js\n\nThis also uses ejs, but apparently ejs is available without being passed in.\n*/ -%>\n/* THIS IS THE ROOT CLASS OF EITHER THE INTERACTION OR OBJECT-CLASS HEIRARCHY\n(i.e. \"InteractionRoot\" OR \"ObjectRoot\") */\n\n/*\n * Copyright (c) 2016, Institute for Software Integrated Systems, Vanderbilt University\n * All rights reserved.\n *\n * Permission to use, copy, modify, and distribute this software and its\n * documentation for any purpose, without fee, and without written agreement is\n * hereby granted, provided that the above copyright notice, the following\n * two paragraphs and the author appear in all copies of this software.\n *\n * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\n * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT\n * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n *\n * @author Himanshu Neema\n */\n<% var rootname = isinteraction ? \"InteractionRoot\" : \"ObjectRoot\"; -%>\n<% var create = isinteraction ? \"create_interaction\" : \"create_object\"; -%>\n<% var IntOb = isinteraction ? \"Interaction\" : \"Object\"; -%>\n<% var intob = isinteraction ? \"interaction\" : \"object\"; -%>\n<% var ParAtt = isinteraction ? \"Parameter\" : \"Attribute\"; -%>\n<% var paratt = isinteraction ? \"parameter\" : \"attribute\"; -%>\npackage org.cpswt.hla;\n\nimport hla.rti.*;\nimport hla.rti.jlc.RtiFactory;\nimport hla.rti.jlc.RtiFactoryFactory;\n\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n<% if(isinteraction){%>import java.util.concurrent.LinkedBlockingQueue;<%}%>\n\nimport org.portico.impl.hla13.types.DoubleTime;\n\n/**\n * <%=rootname%> is the base class for all <%= intob %>s\n * defined in a given federation.  As such, an <%=rootname%>\n * variable may refer to any type of interaction defined in the\n * federation.\n * <p/>\n * This <%=rootname%> class provides the following:\n * - methods for constructing any <%= intob %> in the federation, either from\n * data provided by the RTI (for example, see\n * {@link #<%=create%>( int classHandle )} or from a string argument\n * specifying the name of <%= intob %> to construct (see\n * {@link #<%=create%>( String className )}.\n * - methods for sending <% if(isinteraction){ %>an interaction<%}else{%>object updates<%}%> to the RTI (see\n * {@link <% if(isinteraction){ %>#sendInteraction( RTIambassador rti )<%}else{%>#updateAttributeValues( RTIambassador rti )<%}%>} for an example).\n * - methods for publishing/subscribing to any <% if(isinteraction){ %>interaction<%}else{%>object/object attribute<%}%> \n * defined in the federation (see\n * {@link #publish( String className, RTIambassador rti )} for example).\n * - methods for getting/setting any <%=  paratt  %> in the <%= intob %> to\n * which a given <%=rootname%> variable is referring\n * (see {@link #get<%=  paratt  %>( String datamemberName )} and\n * {@link #set<%= ParAtt %>( String datamemberName, Object value )}\n */\npublic class <%=rootname%> implements <%=rootname%>Interface {\n\n    private static int logId = 0;\n    private static int _globalUniqueID = 0;\n    \n    private static int generateUniqueID() {\n        return _globalUniqueID++;\n    }\n    \n    private int _uniqueID;\n    \n    public int getUniqueID() { return _uniqueID; }\n    \n    protected static RtiFactory _factory;\n    static {\n        boolean factoryNotAcquired = true;\n        while( factoryNotAcquired ) {\n            try {\n                _factory = RtiFactoryFactory.getRtiFactory( \"org.portico.dlc.HLA13RTIFactory\" );\n                factoryNotAcquired = false;\n            } catch ( Exception e ) {\n                System.err.println( \"ERROR: acquiring factory\" );\n                e.printStackTrace();\n                try { Thread.sleep( 100 ); } catch ( Exception e1 ) { }\n            }\n        }\n    }\n\n    protected static Set< String > _classNameSet = new HashSet< String >();\n    protected static Map< String, Class<?> > _classNameClassMap = new HashMap< String, Class<?> >();\n    protected static Map<  String, Set< String >  > _datamemberClassNameSetMap = new HashMap<  String, Set< String >  >();\n    protected static Map<  String, Set< String >  > _allDatamemberClassNameSetMap = new HashMap<  String, Set< String >  >();\n\n    protected static Map< String, Integer > _classNameHandleMap = new HashMap< String, Integer >();\n    protected static Map< Integer, String > _classHandleNameMap = new HashMap< Integer, String >();\n    protected static Map< Integer, String > _classHandleSimpleNameMap = new HashMap< Integer, String >();\n    \n    protected static Map< String, Integer > _datamemberNameHandleMap = new HashMap< String, Integer >();\n    protected static Map< Integer, String > _datamemberHandleNameMap = new HashMap< Integer, String >();\n    protected static Map< String, String > _datamemberTypeMap = new HashMap< String, String >();\n\n<% if(isinteraction){ %><%}else{%>\n    protected static Map<  String, Set< String >  > _classNamePublishAttributeNameMap = new HashMap<  String, Set< String >  >();\n    protected static Map<  String, Set< String >  > _classNameSubscribeAttributeNameMap = new HashMap<  String, Set< String >  >();\n\n    protected static Map< String, AttributeHandleSet > _classNamePublishedAttributeMap = new HashMap< String, AttributeHandleSet >();\n    protected static Map< String, AttributeHandleSet > _classNameSubscribedAttributeMap = new HashMap< String, AttributeHandleSet >();\n    \n    private static Map< Integer, ObjectRoot > _objectMap = new HashMap< Integer, ObjectRoot >();\n\n    protected static class Attribute<T> {                                                                                 // NOMELD\n        private T _value = null;                                                                                           // NOMELD\n        private T _oldValue = null;                                                                                        // NOMELD\n        private boolean _oldValueInit = false;                                                                             // NOMELD\n        private double _time = 0;                                                                                          // NOMELD\n                                                                                                                           // NOMELD\n        public Attribute( T init ) {                                                                                       // NOMELD\n            _value = init;                                                                                                 // NOMELD\n        }                                                                                                                  // NOMELD\n                                                                                                                           // NOMELD\n        public T getValue() { return _value; }                                                                             // NOMELD\n        public void setValue( T value ) {                                                                                  // NOMELD\n            if ( value == null ) return;                                                                                   // NOMELD\n            _value = value;                                                                                                // NOMELD\n        }                                                                                                                  // NOMELD\n                                                                                                                           // NOMELD\n        public double getTime() { return _time; }                                                                          // NOMELD\n        public void setTime( double time ) { _time = time; }                                                               // NOMELD\n                                                                                                                           // NOMELD\n        public void setHasBeenUpdated() {                                                                                  // NOMELD\n            _oldValue = _value;                                                                                            // NOMELD\n            _oldValueInit = true;                                                                                          // NOMELD\n        }                                                                                                                  // NOMELD\n                                                                                                                           // NOMELD\n        public boolean shouldBeUpdated( boolean force ) { return force || !_oldValueInit || !_oldValue.equals( _value ); } // NOMELD        \n    }                                                                                                                      // NOMELD\n<%}%>\n\n    <%- ejs.render(TEMPLATES[\"java/classcommon.java.ejs\"],\n        {\n            isinteraction: isinteraction,\n            classname: rootname,\n            codeclassname: rootname,\n            parentclassname: \"\",\n            hlaclassname: rootname,\n            datamembers: [],\n            alldatamembers: []\n    }) %>\n    /**\n    * Returns a set of strings containing the names of all of the <%= intob %>\n    * classes in the current federation.\n    *\n    * @return Set< String > containing the names of all <%= intob %> classes\n    * in the current federation\n    */\n    public static Set< String > get_<%= intob %>_names() { return new HashSet< String >( _classNameSet ); }\n\n    /**\n    * Returns a set of strings containing the names of all of the non-hidden <%= paratt %>s\n    * in the <%= intob %> class specified by className.\n    *\n    * @param className name of <%= intob %> class for which to retrieve the\n    * names of all of its <%= paratt %>s\n    * @return Set< String > containing the names of all <%= paratt %>s in the\n    * className <%= intob %> class\n    */\n    public static Set< String > get_<%= paratt %>_names( String className ) {\n        return new HashSet< String >(  _datamemberClassNameSetMap.get( className )  );\n    }\n    \n    /**\n    * Returns a set of strings containing the names of all of the <%= paratt %>s\n    * in the <%= intob %> class specified by className.\n    *\n    * @param className name of <%= intob %> class for which to retrieve the\n    * names of all of its <%= paratt %>s\n    * @return Set< String > containing the names of all <%= paratt %>s in the\n    * className <%= intob %> class\n    */\n    public static Set< String > get_all_<%= paratt %>_names( String className ) {\n        return new HashSet< String >(  _allDatamemberClassNameSetMap.get( className )  );\n    }\n    \n    /**\n    * Returns the fully-qualified name of the <%= intob %> class corresponding\n    * to the RTI-defined classHandle.\n    *\n    * @param classHandle handle (defined by RTI) of <%= intob %> class for\n    * which to retrieve the fully-qualified name\n    * @return the fully-qualified name of the <%= intob %> class that\n    * corresponds to the RTI-defined classHandle\n    */\n    public static String get_class_name( int classHandle ) {\n        return _classHandleNameMap.get( classHandle );\n    }\n\n    /**\n    * Returns the simple name of the <%= intob %> class corresponding to the\n    * RTI-defined classHandle.  The simple name of an <%= intob %> class is\n    * the last name in its (dot-delimited) fully-qualified name.\n    *\n    * @param classHandle handle (defined by RTI) of <%= intob %> class for which\n    * to retrieve the simple name\n    * @return the simple name of the <%= intob %> class that corresponds to\n    * the RTI-defined classHandle\n    */\n    public static String get_simple_class_name( int classHandle ) {\n        return _classHandleSimpleNameMap.get( classHandle );\n    }\n    \n    /**\n    * Returns the integer handle (RTI defined) of the <%= intob %> class\n    * corresponding to the fully-qualified <%= intob %> class name in className.\n    *\n    * @param className fully-qualified name of <%= intob %> class for which to\n    * retrieve the RTI-defined integer handle\n    * @return the RTI-defined handle of the <%= intob %> class\n    */\n    public static int get_handle( String className ) {\n    \n        Integer classHandle = _classNameHandleMap.get( className );\n        if ( classHandle == null ) {\n            System.err.println( \"Bad class name \\\"\" + className + \"\\\" on get_handle.\" );\n            return -1;\n        }\n        \n        return classHandle;        \n    }\n    \n    /**\n    * Returns the name of <% if(isinteraction){ %>a parameter<%}else{%>an attribute<%}%> corresponding to\n    * its handle (RTI assigned) in datamemberHandle.\n    *\n    * @param datamemberHandle handle of <% if(isinteraction){ %>parameter<%}else{%>attribute<%}%> (RTI assigned)\n    * for which to return the name\n    * @return the name of the <% if(isinteraction){ %>parameter<%}else{%>attribute<%}%> corresponding to datamemberHandle\n    */\n    public static String get_<%= paratt %>_name( int datamemberHandle ) {\n        return _datamemberHandleNameMap.get( datamemberHandle );\n    }\n    \n    /**\n    * Returns the handle of <% if(isinteraction){ %>a parameter<%}else{%>an attribute<%}%> (RTI assigned) given\n    * its <%= intob %> class name and <%= paratt %> name\n    *\n    * @param className name of <%= intob %> class\n    * @param datamemberName name of <%= paratt %>\n    * @return the handle (RTI assigned) of the <%= paratt %> \"datamemberName\" of <%= intob %> class \"className\"\n    */\n    public static int get_<%= paratt %>_handle( String className, String datamemberName ) {\n    \n        Integer datamemberHandle = _datamemberNameHandleMap.get( className + \",\" + datamemberName );\n        if ( datamemberHandle == null ) {\n            System.err.println( \"Bad <%= paratt %> \\\"\" + datamemberName + \"\\\" for class \\\"\" + className + \"\\\" on get_<%= paratt %>_handle.\" );\n            return -1;\n        }\n        \n        return datamemberHandle;\n    }\n    private static Class<?>[] pubsubArguments = new Class<?>[] { RTIambassador.class };\n    \n    \n    /**\n    * Publishes the <%= intob %> class named by \"className\" for a federate.\n    * This can also be performed by calling the publish( RTIambassador rti )\n    * method directly on the <%= intob %> class named by \"className\" (for\n    * example, to publish the <%=rootname%> class in particular,\n    * see {@link <%=rootname%>#publish( RTIambassador rti )}).\n    *\n    * @param className name of <%= intob %> class to be published for the federate\n    * @param rti handle to the RTI, usu. obtained through the\n    * {@link SynchronizedFederate#getRTI()} call\n    */\n    public static void publish( String className, RTIambassador rti ) {\n        Class<?> rtiClass = _classNameClassMap.get( className );\n        if ( rtiClass == null ) {\n            System.err.println( \"Bad class name \\\"\" + className + \"\\\" on publish.\" );\n            return;\n        }\n        try {\n            Method method = rtiClass.getMethod( \"publish\", pubsubArguments );\n            method.invoke( null, new Object[]{ rti } );\n        } catch ( Exception e ) {\n            System.err.println( \"Exception caught on publish!\" );\n            e.printStackTrace();\n        }\n    }\n\n    /**\n    * Unpublishes the <%= intob %> class named by \"className\" for a federate.\n    * This can also be performed by calling the unpublish( RTIambassador rti )\n    * method directly on the <%= intob %> class named by \"className\" (for\n    * example, to unpublish the <%=rootname%> class in particular,\n    * see {@link <%=rootname%>#unpublish( RTIambassador rti )}).\n    *\n    * @param className name of <%= intob %> class to be unpublished for the federate\n    * @param rti handle to the RTI, usu. obtained through the\n    * {@link SynchronizedFederate#getRTI()} call\n    */\n    public static void unpublish( String className, RTIambassador rti ) {\n        Class<?> rtiClass = _classNameClassMap.get( className );\n        if ( rtiClass == null ) {\n            System.err.println( \"Bad class name \\\"\" + className + \"\\\" on unpublish.\" );\n            return;\n        }\n        try {\n            Method method = rtiClass.getMethod( \"unpublish\", pubsubArguments );\n            method.invoke( null, new Object[]{ rti } );\n        } catch ( Exception e ) {\n            System.err.println( \"Exception caught on unpublish!\" );\n            e.printStackTrace();\n        }\n    }\n    \n    /**\n    * Subscribes federate to the <%= intob %> class names by \"className\"\n    * This can also be performed by calling the subscribe( RTIambassador rti )\n    * method directly on the <%= intob %> class named by \"className\" (for\n    * example, to subscribe a federate to the <%=rootname%> class\n    * in particular, see {@link <%=rootname%>#subscribe( RTIambassador rti )}).\n    *\n    * @param className name of <%= intob %> class to which to subscribe the federate\n    * @param rti handle to the RTI, usu. obtained through the\n    * {@link SynchronizedFederate#getRTI()} call\n    */\n    public static void subscribe( String className, RTIambassador rti ) {\n        Class<?> rtiClass = _classNameClassMap.get( className );\n        if ( rtiClass == null ) {\n            System.err.println( \"Bad class name \\\"\" + className + \"\\\" on subscribe.\" );\n            return;\n        }\n        try {\n            Method method = rtiClass.getMethod( \"subscribe\", pubsubArguments );\n            method.invoke( null, new Object[]{ rti } );\n        } catch ( Exception e ) {\n            System.err.println( \"Exception caught on subscribe!\" );\n            e.printStackTrace();\n        }\n    }\n    \n    /**\n    * Unsubscribes federate from the <%= intob %> class names by \"className\"\n    * This can also be performed by calling the unsubscribe( RTIambassador rti )\n    * method directly on the <%= intob %> class named by \"className\" (for\n    * example, to unsubscribe a federate to the <%=rootname%> class\n    * in particular, see {@link <%=rootname%>#unsubscribe( RTIambassador rti )}).\n    *\n    * @param className name of <%= intob %> class to which to unsubscribe the federate\n    * @param rti handle to the RTI, usu. obtained through the\n    * {@link SynchronizedFederate#getRTI()} call\n    */\n    public static void unsubscribe( String className, RTIambassador rti ) {\n        Class<?> rtiClass = _classNameClassMap.get( className );\n        try {\n            Method method = rtiClass.getMethod( \"unsubscribe\", pubsubArguments );\n            method.invoke( null, new Object[]{ rti } );\n        } catch ( Exception e ) {\n            System.err.println( \"Exception caught on unsubscribe!\" );\n            e.printStackTrace();\n        }\n    }\n\n<% if(isinteraction){ %><%}else{%>\n    /**\n    * Publishes the attribute named by \"attributeName\" of the object class named\n    * by \"className\" for a federate.  This can also be performed by calling the\n    * publish_<attributeName>() method directly on the object class named by\n    * \"className\".\n    *\n    * Note:  This method only marks the attribute named by \"attributeName\" for\n    * publication.  The attribute doesn't actually get published until the\n    * \"className\" object class, of which it is a member, is (re)published.  See\n    * {@link ObjectRoot#publish( String className, RTIambassador RTI )} and\n    * {@link ObjectRoot#publish( RTIambassador RTI )} for examples of how to\n    * publish the object class.\n    * \n    * @param className name of object class for which the attribute named by\n    * \"attributeName\" is to be published\n    * @param attributeName name of the attribute to be published\n    */\n    public static void publish( String className, String attributeName ) {\n        try {\n            _classNamePublishAttributeNameMap.get( className ).add( attributeName );\n        } catch ( Exception e ) {\n            System.err.println( \"ERROR:  ObjectRoot.publish:  could not publish class \\\"\" + className + \"\\\" \\\"\" + attributeName + \"\\\" attribute.\" );\n            e.printStackTrace();\n        }        \n    }\n\n    /**\n    * Unpublishes the attribute named by \"attributeName\" of the object class named\n    * by \"className\" for a federate.  This can also be performed by calling the\n    * unpublish_<attributeName>() method directly on the object class named by\n    * \"className\".\n    *\n    * Note:  This method only marks the attribute named by \"attributeName\" for\n    * un-publication. The attribute doesn't actually get unpublished until the\n    * \"className\" object class, of which it is a member, is (re)published.  See\n    * {@link ObjectRoot#publish( String className, RTIambassador RTI )} and\n    * {@link ObjectRoot#publish( RTIambassador RTI )} for examples of how to\n    * publish the object class.\n    * \n    * @param className name of object class for which the attribute named by\n    * \"attributeName\" is to be unpublished (by a federate)\n    * @param attributeName name of the attribute to be unpublished\n    */\n    public static void unpublish( String className, String attributeName ) {\n        try {\n            _classNamePublishAttributeNameMap.get( className ).remove( attributeName );\n        } catch ( Exception e ) {\n            System.err.println( \"ERROR:  ObjectRoot.unpublish:  could not unpublish class \\\"\" + className + \"\\\" \\\"\" + attributeName + \"\\\" attribute.\" );\n            e.printStackTrace();\n        }        \n    }\n\n    /**\n    * Subscribe a federate to the attribute named by \"attributeName\" of the\n    * object class named by \"className\".  This can also be performed by calling\n    * the subscribe_<attributeName>() method directly on the object class named\n    * by \"className\".\n    *\n    * Note:  This method only marks the attribute named by \"attributeName\" for\n    * subscription.  The attribute doesn't actually get subscribed to until the\n    * \"className\" object class, of which it is a member, is (re)subscribed to.\n    * See {@link ObjectRoot#subscribe( String className, RTIambassador RTI )} and\n    * {@link ObjectRoot#subscribe( RTIambassador RTI )} for examples of how to\n    * subscribe to the object class.\n    * \n    * @param className name of object class for which the attribute named by\n    * \"attributeName\" is to be subcribed\n    * @param attributeName name of the attribute to be published\n    */\n    public static void subscribe( String className, String attributeName ) {\n        try {\n            _classNameSubscribeAttributeNameMap.get( className ).add( attributeName );\n        } catch ( Exception e ) {\n            System.err.println( \"ERROR:  ObjectRoot.subscribe:  could not subscribe to class \\\"\" + className + \"\\\" \\\"\" + attributeName + \"\\\" attribute.\" );\n            e.printStackTrace();\n        }        \n    }\n\n    /**\n    * Unsubscribe a federate from the attribute named by \"attributeName\" of the\n    * object class named by \"className\".  This can also be performed by calling\n    * the unsubscribe_<attributeName>() method directly on the object class named\n    * by \"className\".\n    *\n    * Note:  This method only marks the attribute named by \"attributeName\" for\n    * unsubscription.  The attribute doesn't actually get unsubscribed from until the\n    * \"className\" object class, of which it is a member, is (re)subscribed to.\n    * See {@link ObjectRoot#subscribe( String className, RTIambassador RTI )} and\n    * {@link ObjectRoot#subscribe( RTIambassador RTI )} for examples of how to\n    * subscribe to the object class.\n    * \n    * @param className name of object class for which the attribute named by\n    * \"attributeName\" is to be subcribed\n    * @param attributeName name of the attribute to be published\n    */\n    public static void unsubscribe( String className, String attributeName ) {\n        try {\n            _classNameSubscribeAttributeNameMap.get( className ).remove( attributeName );\n        } catch ( Exception e ) {\n            System.err.println( \"ERROR:  ObjectRoot.unsubscribe:  could not unsubscribe class \\\"\" + className + \"\\\" \\\"\" + attributeName + \"\\\" attribute.\" );\n            e.printStackTrace();\n        }        \n    }\n<%}%>\n    \n    private static <%=rootname%> <%=create%>( Class<?> rtiClass ) {\n        <%=rootname%> classRoot = null;\n        try {\n            classRoot = (<%=rootname%>)rtiClass.newInstance();\n        } catch( Exception e ) {\n            System.err.println( \"ERROR:  <%=rootname%>:  <%=create%>:  could not create/cast new <%= IntOb %>\" );\n            e.printStackTrace();\n        }\n        \n        return classRoot;\n    }\n\n    private static <%=rootname%> <%=create%>( Class<?> rtiClass, LogicalTime logicalTime ) {    \n        <%=rootname%> classRoot = <%=create%>( rtiClass );\n        if ( classRoot != null ) classRoot.setTime( logicalTime );\n        return classRoot;\n    }\n\n    private static <%=rootname%> <%=create%>( Class<?> rtiClass, <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap ) {\n        <%=rootname%> classRoot = <%=create%>( rtiClass );\n        classRoot.set<%= ParAtt %>s( datamemberMap );\n        return classRoot;\n    }\n    \n    private static <%=rootname%> <%=create%>( Class<?> rtiClass, <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, LogicalTime logicalTime ) {\n        <%=rootname%> classRoot = <%=create%>( rtiClass );\n        classRoot.set<%= ParAtt %>s( datamemberMap );\n        classRoot.setTime( logicalTime );\n        return classRoot;\n    }\n    \n    /**\n    * Create an <%= intob %> that is in instance of <%= intob %> class\n    * \"className\". An <%=rootname%> reference is returned,\n    * so to refer to the instance using a reference to a \"className\" interaction,\n    * the returned reference must be cast down the <%= intob %> inheritance\n    * hierarchy.\n    * An instance of the \"className\" <%= intob %> class may also be created\n    * by using the \"new\" operator directory on the \"className\" <%= intob %>\n    * class.  For instance, two ways to create an <%=rootname%>\n    * instance are\n    * <%= IntOb %>.<%=create%>( \"<%=rootname%>\" ),\n    * and\n    * new <%=rootname%>()\n    *\n    * @param className fully-qualified (dot-delimited) name of the <%= intob %>\n    * class for which to create an instance\n    * @return instance of \"className\" <%= intob %> class\n    */\n    public static <%=rootname%> <%=create%>( String className ) {\n        Class<?> rtiClass = _classNameClassMap.get( className );\n        if ( rtiClass == null ) return null;\n\n        return <%=create%>( rtiClass );\n    }\n\n    /**\n    * Like {@link #<%=create%>( String className )}, but <%= intob %>\n    * is created with a timestamp based on \"logicalTime\".\n    *\n    * @param className fully-qualified (dot-delimited) name of the <%= intob %>\n    * class for which to create an instance\n    * @param logicalTime timestamp to place on the new <%= intob %> class instance\n    * @return instance of \"className\" <%= intob %> class with \"logicalTime\" time stamp.\n    */\n    public static <%=rootname%> <%=create%>( String className, LogicalTime logicalTime ) {\n        Class<?> rtiClass = _classNameClassMap.get( className );\n        if ( rtiClass == null ) return null;\n\n        return <%=create%>( rtiClass, logicalTime );\n    }\n\n    /**\n    * Create an <%= intob %> that is in instance of <%= intob %> class\n    * that corresponds to the \"classHandle\" handle (RTI assigned). An\n    * <%=rootname%> reference is returned, so to refer to the\n    * instance using a reference to a \"className\" interaction, the returned\n    * reference must be cast down the <%= intob %> inheritance hierarchy.\n    *\n    * @param classHandle handle of <%= intob %> class (RTI assigned) class for\n    * which to create an instance\n    * @return instance of <%= intob %> class corresponding to \"classHandle\"\n    */\n    public static <%=rootname%> <%=create%>( int classHandle ) {\n        Class<?> rtiClass = _classNameClassMap.get(  _classHandleNameMap.get( classHandle )  );\n        if ( rtiClass == null ) return null;\n\n        return <%=create%>( rtiClass );\n    }\n\n    /**\n    * Like {@link #<%=create%>( int classHandle )}, but the <%= intob %>\n    * is created with a timestamp based on \"logicalTime\".\n    *\n    * @param classHandle handle of <%= intob %> class (RTI assigned) class for\n    * which to create an instance\n    * @param logicalTime timestamp to place on the new <%= intob %> class instance\n    * @return instance of <%= intob %> class corresponding to \"classHandle\" with\n    * \"logicalTime\" time stamp\n    */\n    public static <%=rootname%> <%=create%>( int classHandle, LogicalTime logicalTime ) {\n        Class<?> rtiClass = _classNameClassMap.get(  _classHandleNameMap.get( classHandle )  );\n        if ( rtiClass == null ) return null;\n\n        return <%=create%>( rtiClass, logicalTime );\n    }\n\n    /**\n    * Like {@link #<%=create%>( int classHandle )}, but the <%= intob %>'s\n    * <%= paratt %>s are initialized using \"datamemberMap\".  The \"datamemberMap\"\n    * is usually acquired as an argument to an RTI callback method of a federate.\n    *\n    * @param classHandle handle of <%= intob %> class (RTI assigned) class for\n    * which to create an instance\n    * @param datamemberMap contains initializing values for the <%= paratt %>s\n    * of the <%= intob %> class instance\n    * @return instance of <%= intob %> class corresponding to \"classHandle\" with\n    * its <%= paratt %>s initialized with the \"datamemberMap\"\n    */\n    public static <%=rootname%> <%=create%>( int classHandle, <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap ) {\n        Class<?> rtiClass = _classNameClassMap.get(  _classHandleNameMap.get( classHandle )  );\n        if ( rtiClass == null ) return null;\n\n        return <%=create%>( rtiClass, datamemberMap );\n    }\n\n    /**\n    * Like {@link #<%=create%>( int classHandle, <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap )},\n    * but the <%= intob %> is given a timestamp based on \"logicalTime\".\n    *\n    * @param classHandle handle of <%= intob %> class (RTI assigned) class for\n    * which to create an instance\n    * @param datamemberMap initializing values for the <%= paratt %>s of the\n    * <%= intob %> class instance\n    * @param logicalTime timestamp to place on the new <%= intob %> class instance\n    * @return instance of <%= intob %> class corresponding to \"classHandle\" with\n    * its <%= paratt %>s initialized with the \"datamemberMap\" and with\n    * \"logicalTime\" timestamp\n    */\n    public static <%=rootname%> <%=create%>( int classHandle, <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, LogicalTime logicalTime ) {\n        Class<?> rtiClass = _classNameClassMap.get(  _classHandleNameMap.get( classHandle )  );\n        if ( rtiClass == null ) return null;\n\n        return <%=create%>( rtiClass, datamemberMap, logicalTime );\n    }\n\n<% if(isinteraction){ %><%}else{%>\n    /**\n    * Creates a new instance of the object class corresponding to \"class_handle\",\n    * registers it in an map internal to the ObjectRoot class using \"object_handle\"\n    * as a key, and returns a reference to the instance.  Though the created\n    * instance is of the object class corresponding to \"class_handle\" (which is\n    * a handle assigned by the RTI), it is referred to, via the return value, by\n    * an ObjectRoot reference.  Thus, to refer to it as an instance of the object\n    * class corresponding to \"class_handle\", the ObjectRoot reference needs to be\n    * cast down through the inheritance hierarchy.\n    * <p/>\n    * class_handle and object_handle are usually acquired as arguments of the\n    * \"discoverObjectInstance\" RTI callback method of a federate.\n    *\n    * @param class_handle handle of object class (RTI assigned) for which to create\n    * an instance\n    * @param object_handle handle (also RTI assigned) of this instance as it is\n    * known to the RTI.  Any updates to the instance attributes provided by the\n    * RTI (via a \"reflectAttributeValues\" federate callback) will be identified\n    * with this object_handle.\n    * @return new instance of the object class corresponding to class_handle\n    */\n    public static ObjectRoot discover( int class_handle, int object_handle ) {\n        Class<?> hlaObjectClass = _classNameClassMap.get(  _classHandleNameMap.get( class_handle )  );\n        ObjectRoot objectRoot = null;\n        try {\n            objectRoot = (ObjectRoot)hlaObjectClass.newInstance();\n            objectRoot.setObjectHandle( object_handle );\n            _objectMap.put( object_handle, objectRoot );\n        } catch( Exception e ) {\n            System.err.println( \"ERROR:  ObjectRoot:  discover:  could not discover object\" );\n            e.printStackTrace();\n        }\n        return objectRoot;\n    }\n    \n    /**\n    * Retrieves the object instance corresponding to \"object_handle\" from an\n    * internal table in the ObjectRoot class, updates its attribute values using\n    * \"reflectedAttributes\", and returns the instance.  Both \"object_handle\" and\n    * \"reflectedAttributes\" are usually acquired as arguments of the\n    * \"reflectAttributeValues\" RTI callback of a federate.\n    * The return value is an ObjectRoot reference to the instance.  So, to refer\n    * to the instance as an instance of its actual class, this reference will\n    * have to be cast down the inheritance hierarchy.\n    *\n    * @param object_handle handle (RTI assigned) of object instance for which the\n    * attributes are to be updated.\n    * @param reflectedAttributes set of updated values for the attributes of the\n    * object instance corresponding to object_handle.\n    * @return the object instance with updated attribute values\n    */\n    public static ObjectRoot reflect( int object_handle, ReflectedAttributes reflectedAttributes ) {\n        ObjectRoot objectRoot = _objectMap.get( object_handle );\n        if ( objectRoot == null ) return null;\n        objectRoot.setTime( -1 );\n        objectRoot.setAttributes( reflectedAttributes );\n        return objectRoot;\n    }\n\n    /**\n    * Like {@link #reflect( int object_handle, ReflectedAttributes reflectedAttributes )},\n    * except the updated attributes of the object instance have their timestamps\n    * updated to \"logicalTime\".\n    *\n    * @param object_handle handle (RTI assigned) of object instance for which the\n    * attributes are to be updated.\n    * @param reflectedAttributes set of updated values for the attributes of the\n    * object instance corresponding to object_handle.\n    * @param logicalTime new time stamp for attributes that are updated\n    * @return the object instance with updated attribute values\n    */\n    public static ObjectRoot reflect( int object_handle, ReflectedAttributes reflectedAttributes, LogicalTime logicalTime ) {\n        ObjectRoot objectRoot = _objectMap.get( object_handle );\n        if ( objectRoot == null ) return null;\n        objectRoot.setTime( logicalTime );\n        objectRoot.setAttributes( reflectedAttributes );\n        return objectRoot;\n    }\n\n    /**\n    * Like {@link #reflect( int object_handle, ReflectedAttributes reflectedAttributes )},\n    * except the updated attributes of the object instance have their timestamps\n    * updated to \"time\".\n    *\n    * @param object_handle handle (RTI assigned) of object instance for which the\n    * attributes are to be updated.\n    * @param reflectedAttributes set of updated values for the attributes of the\n    * object instance corresponding to object_handle.\n    * @param time new time stamp for attributes that are updated\n    * @return the object instance with updated attribute values\n    */\n    public static ObjectRoot reflect( int object_handle, ReflectedAttributes reflectedAttributes, double time ) {\n        ObjectRoot objectRoot = _objectMap.get( object_handle );\n        if ( objectRoot == null ) return null;\n        objectRoot.setTime( time );\n        objectRoot.setAttributes( reflectedAttributes );\n        return objectRoot;\n    }\n\n    /**\n    * Requests an attribute update for this object instance from the federate that\n    * has modification rights on these attributes.\n    *\n    * @param rti handle to the RTI, usu. obtained through the\n    * {@link SynchronizedFederate#getRTI()} call\n    */\n    public void requestUpdate( RTIambassador rti ) {\n        boolean requestNotSubmitted = true;\n        while( requestNotSubmitted ) {\n            try {        \n                rti.requestObjectAttributeValueUpdate( getObjectHandle(), getSubscribedAttributeHandleSet() );\n                requestNotSubmitted = false;\n            } catch ( FederateNotExecutionMember f ) {\n                System.err.println( \"ERROR: \" + getClassName() + \"request for update failed:  Federate Not Execution Member\" );\n                f.printStackTrace();\n                return;                \n            } catch ( ObjectNotKnown o ) {\n                System.err.println( \"ERROR: \" + getClassName() + \"request for update failed:  Object Not Known\" );\n                o.printStackTrace();\n                return;                \n            } catch ( AttributeNotDefined a ) {\n                System.err.println( \"ERROR: \" + getClassName() + \"request for update failed:  Name Not Found\" );\n                a.printStackTrace();\n                return;                \n            } catch ( Exception e ) {\n                e.printStackTrace();\n                try { Thread.sleep( 50 ); } catch( Exception e1 ) { }                    \n            }\n        }\n    }\n\n    /**\n    * Returns the object instance corresponding to the \"object_handle\" (RTI\n    * assigned) from a map internal to the ObjectRoot class.\n    * The object instance is referred to, via the return value, using an\n    * an ObjectRoot reference.  To reference to it using a reference of its\n    * actual class, the returned reference must be cast down through the\n    * inhertance hierarchy.\n    *\n    * @param object_handle handle (RTI assigned) of object instance to retrieve\n    * from the map internal to the ObjectRoot class.\n    * @return object instance corresponding to the object_handle (RTI assigned)\n    * in the map that is internal to the ObjectRoot class.\n    */\n    public static ObjectRoot getObject( int object_handle ) {\n        return _objectMap.get( object_handle );\n    }\n    \n    \n    /**\n    * Returns the object instance corresponding to the \"object_handle\" (RTI\n    * assigned) from a map internal to the ObjectRoot class AND REMOVES IT\n    * FROM THIS MAP.\n    * The object instance is referred to, via the return value, using an\n    * an ObjectRoot reference.  To reference to it using a reference of its\n    * actual class, the returned reference must be cast down through the\n    * inhertance hierarchy.\n    *\n    * @param object_handle handle (RTI assigned) of object instance to retrieve\n    * from the map internal to the ObjectRoot class.\n    * @return object instance corresponding to the object_handle (RTI assigned)\n    * in the map that is internal to the ObjectRoot class.\n    */\n    public static ObjectRoot removeObject( int object_handle ) {\n        return _objectMap.remove( object_handle );\n    }\n    \n\n    private int _object_handle;\n\n    private void setObjectHandle( int object_handle ) {\n        _objectMap.remove( object_handle );\n        _object_handle = object_handle;\n        _objectMap.put( object_handle, this );\n    }\n\n    /**\n    * Returns the handle (RTI assigned) the corresponds to this object class\n    * instance.  This handle is the instance's unique identifier to the RTI.\n    *\n    * @return the handle (RTI assigned) of this object class instance.\n    */\n    public int getObjectHandle() { return _object_handle; }\n    \n<%}%>\n\n    private double _time = -1;\n    \n    /**\n    * Returns the timestamp for this <%= intob %>.  \"receive order\" <%= intob %>s\n    * should have a timestamp of -1.\n    *\n    * @return timestamp for this <%= intob %>\n    */\n    public double getTime() { return _time; }\n    \n    /**\n    * Sets the timestamp of this <%= intob %> to \"time\".\n    *\n    * @param time new timestamp for this <%= intob %>\n    */\n    public void setTime( double time ) { _time = time; }\n\n    /**\n    * Sets the timestamp of this <%= intob %> to \"logicalTime\".\n    *\n    * @param logicalTime new timestamp for this <%= intob %>\n    */\n    public void setTime( LogicalTime logicalTime ) {\n        DoubleTime doubleTime = new DoubleTime();\n        doubleTime.setTo( logicalTime );\n        setTime( doubleTime.getTime() );\n    }\n\n\n    /**\n    * Creates a new <%=rootname%> instance.\n    */\n    public <%=rootname%>() {\n        _uniqueID = generateUniqueID();\n    }\n    \n    /**\n    * Creates a copy of an <%=rootname%> instance.  As an\n    * <%=rootname%> instance contains no <%= paratt %>s,\n    * this has the same effect as the default constructor.\n    */\n    public <%=rootname%>( <%=rootname%> <%= intob %>Root ) {\n        this();\n    }\n\n    protected <%=rootname%>( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, boolean initFlag ) {\n        this();\n        if ( initFlag ) set<%= ParAtt %>s( datamemberMap );\n    }\n    \n    protected <%=rootname%>( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, LogicalTime logicalTime, boolean initFlag ) {\n        this();\n        setTime( logicalTime );\n        if ( initFlag ) set<%= ParAtt %>s( datamemberMap );\n    }\n\n\n    /**\n    * Creates a new <%= intob %> instance and initializes its <%= paratt %>s\n    * using the \"datamemberMap\" -- this constructor is usually called as a\n    * super-class constructor to create and initialize an instance of an\n    * <%= intob %> further down in the inheritance hierarchy.  \"datamemberMap\"\n    * is usually acquired as an argument to an RTI federate callback method, such\n    * as \"receiveInteraction\".\n    *\n    * @param datamemberMap contains <%= paratt %> values for the newly created\n    * <%= intob %>\n    */\n    public <%=rootname%>( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap ) {\n        this( datamemberMap, true );\n    }\n\n    /**\n    * Like {@link #<%=rootname%>( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap )},\n    * except the new instance has an initial timestamp of \"logicalTime\".\n    *\n    * @param datamemberMap contains <%= paratt %> values for the newly created\n    * <%= intob %>\n    * @param logicalTime initial timestamp for newly created <%= intob %> instance\n    */    \n    public <%=rootname%>( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, LogicalTime logicalTime ) {\n        this( datamemberMap, logicalTime, true );\n    }\n\n    /**\n    * Returns the value of the <%= paratt %> named \"datamemberName\" for this\n    * <%= intob %>.\n    *\n    * @param datamemberName name of <%= paratt %> whose value to retrieve\n    * @return the value of the <%= paratt %> whose name is \"datamemberName\"\n    */\n    public Object get<%= ParAtt %>( String datamemberName ) {\n        return null;\n    }\n\n    /**\n    * Returns the value of the <%= paratt %> whose handle is \"datamemberHandle\"\n    * (RTI assigned) for this <%= intob %>.\n    *\n    * @param datamemberHandle handle (RTI assigned) of <%= paratt %> whose\n    * value to retrieve\n    * @return the value of the <%= paratt %> whose handle is \"datamemberHandle\"\n    */\n    public Object get<%= ParAtt %>( int datamemberHandle ) {\n        return null;\n    }\n        \n    /**\n    * Set the values of the <%= paratt %>s in this <%= intob %> using\n    * \"datamemberMap\".  \"datamemberMap\" is usually acquired as an argument to\n    * an RTI federate callback method such as \"receiveInteraction\".\n    *\n    * @param datamemberMap  contains new values for the <%= paratt %>s of\n    * this <%= intob %>\n    */\n    public void set<%= ParAtt %>s( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap ) {\n        int size = datamemberMap.size();\n        for( int ix = 0 ; ix < size ; ++ix ) {\n            try {\n                set<%= ParAtt %>(  datamemberMap.get<%= ParAtt %>Handle( ix ), datamemberMap.getValue( ix )  );\n            } catch ( Exception e ) {\n                System.err.println( \"set<%= ParAtt %>s: Exception caught!\" );\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void set<%= ParAtt %>( int handle, byte[] val ) {\n        if ( val == null ) {\n            System.err.println( \"set:  Attempt to set null value in class \\\"\" + getClass().getName() + \"\\\"\" );\n        }\n        String valAsString = new String( val, 0, val.length );\n        if (valAsString != null && valAsString.length() > 0 && valAsString.charAt(valAsString.length() - 1) == '\\0') {\n            valAsString = valAsString.substring(0, valAsString.length() - 1);\n        }\n        if (   !set<%= ParAtt %>Aux(  handle, valAsString  )   ) {\n            System.err.println( \"set:  bad <%= paratt %> handle in class \\\"\" + getClass().getName() + \"\\\"\" );\n        }\n    }\n    \n    /**\n    * Sets the value of the <%= paratt %> named \"datamemberName\" to \"value\"\n    * in this <%= intob %>.  \"value\" is converted to data type of \"datamemberName\"\n    * if needed.\n    * This action can also be affected by calling the set_<datamemberName>( value )\n    * method on the <%= intob %> using a reference to the <%= intob %>'s actual\n    * class.\n    *\n    * @param datamemberName name of <%= paratt %> whose value is to be set\n    * to \"value\"\n    * @param value new value of <%= paratt %> called \"datamemberName\"\n    */\n    public void set<%= ParAtt %>( String datamemberName, String value ) {\n        if (  !set<%= ParAtt %>Aux( datamemberName, value )  ) {\n            System.err.println( \"Error:  <%= intob %>Root:  invalid <%= paratt %> \\\"\" + datamemberName + \"\\\"\" );\n        }\n    }\n\n    /**\n    * Sets the value of the <%= paratt %> named \"datamemberName\" to \"value\"\n    * in this <%= intob %>.  \"value\" should have the same data type as that of\n    * the \"datamemberName\" <%= paratt %>.\n    * This action can also be affected by calling the set_<datamemberName>( value )\n    * method on the <%= intob %> using a reference to the <%= intob %>'s actual\n    * class.\n    *\n    * @param datamemberName name of <%= paratt %> whose value is to be set\n    * to \"value\"\n    * @param value new value of <%= paratt %> called \"datamemberName\"\n    */\n    public void set<%= ParAtt %>( String datamemberName, Object value ) {\n        if (  !set<%= ParAtt %>Aux( datamemberName, value )  ) {\n            System.err.println( \"Error:  <%= intob %>Root:  invalid <%= paratt %> \\\"\" + datamemberName + \"\\\"\" );\n        }\n    }\n\n    protected boolean set<%= ParAtt %>Aux( int param_handle, String val ) {\n        return false;\n    }\n\n    protected boolean set<%= ParAtt %>Aux( String datamemberName, String value ) {\n        return false;\n    }\n\n    protected boolean set<%= ParAtt %>Aux( String datamemberName, Object value ) {\n        return false;\n    }\n\n    protected Supplied<%= ParAtt %>s createSuppliedDatamembers(<% if(isinteraction){ %><%}else{%>boolean force<%}%>) {\n        return _factory.createSupplied<%= ParAtt %>s();\n    }\n    \n<% if(isinteraction){ %>\n    /**\n    * Sends this interaction to the RTI, with the specified timestamp \"time\".\n    * This method should be used to send interactions that have \"timestamp\"\n    * ordering.\n    *\n    * @param rti handle to the RTI, usu. obtained through the\n    * {@link SynchronizedFederate#getRTI()} call\n    * @param time timestamp for this interaction.  The timestamp should be no\n    * less than the current federation time + the LOOKAHEAD value of the federate\n    * sending this interaction.\n    */\n    public void sendInteraction( RTIambassador rti, double time ) throws Exception {\n        synchronized( rti ) {\n            try {\n                SuppliedParameters datamembers = createSuppliedDatamembers();\n                rti.sendInteraction(  getClassHandle(), datamembers, null, new DoubleTime( time )  );\n                createLog(datamembers,time);\n            } catch ( Exception e ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not send interaction\" );\n                e.printStackTrace();\n            }\n        }\n    }\n\n    /**\n    * Sends this interaction to the RTI (without a timestamp).\n    * This method should be used to send interactions that have \"receive\"\n    * ordering.\n    *\n    * @param rti handle to the RTI, usu. obtained through the\n    * {@link SynchronizedFederate#getRTI()} call\n    */\n    public void sendInteraction( RTIambassador rti ) throws Exception {\n        synchronized( rti ) {\n            try {\n                SuppliedParameters datamembers = createSuppliedDatamembers();\n                rti.sendInteraction( getClassHandle(), datamembers, null );\n                createLog(datamembers,0);\n            } catch ( Exception e ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not send interaction\" );\n                e.printStackTrace();\n            }\n        }\n    }\n    \n    protected static String fedName = null;\n    public static Boolean enablePubLog = false;\n    public static Boolean enableSubLog = false;\n    public static String pubLogLevel = null;\n    public static String subLogLevel = null;\n    \n    public static void enablePublishLog(String interaction, String fed, String thislevel, String globallevel){\n        if(globallevel == null || \"\".equals(globallevel)) return;\n        if(C2WLogger.getLogLevel(thislevel)> C2WLogger.getLogLevel(globallevel)) return;\n        fedName = fed;\n        enablePubLog = true;\n        pubLogLevel = thislevel;\n        C2WLogger.addLog(interaction, fedName, true);\n    }\n    \n    public static void enableSubscribeLog(String interaction, String fed, String thislevel, String globallevel){\n        if(globallevel == null || \"\".equals(globallevel)) return;\n        if(C2WLogger.getLogLevel(thislevel)> C2WLogger.getLogLevel(globallevel)) return;\n        fedName = fed;\n        enableSubLog = true;\n        subLogLevel = thislevel;\n        C2WLogger.addLog(interaction, fedName, false);\n    }\n    \n    protected void createLog(final SuppliedParameters datamembers, final double time) {\n        if(!enablePubLog) return;\n        Thread t = new Thread(new Runnable() {                                                                                 // NOMELD\n            public void run() {                                                                                                // NOMELD\n                try {\n                    String interactionId = fedName != null ? fedName + \"_pub_\"+ getSimpleClassName() :getSimpleClassName() + \"_pub\";\n\n                    // First just record the interaction event as a log\n                    C2WLogger.addEventLog(time, interactionId);\n\n                    // Now, log detailed simulation data of the interaction\n                    String logIdLocal = null;\n                    synchronized( <%=rootname%>.class ) {\n                        logIdLocal = Integer.toString( logId++ );\n                    }\n\n                    int noDatamembers = datamembers.size();\n                    if ( noDatamembers == 0 ) {\n                        C2WLogger.addLog( interactionId, time, null, null, null, pubLogLevel, logIdLocal );\n                    } else {\n                        for(int ix =0; ix < datamembers.size();ix++){\n                            String parameter = get_parameter_name(datamembers.getHandle( ix ) );\n                            String value = new String(datamembers.getValue(ix));    \n                            String type = new String(_datamemberTypeMap.get(parameter));\n                            C2WLogger.addLog( interactionId, time, parameter, value, type, pubLogLevel, logIdLocal );\n                        }\n                    }\n                } catch ( Exception e ) {\n                    System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not send interaction\" );\n                    e.printStackTrace();\n                }\n            }\n        });\n        t.start();\n    }\n\n<%}else{%>\n    private boolean _isRegistered = false;\n\n    /**\n    * Registers this object with the RTI.  This method is usually called by a\n    * federate who \"owns\" this object, i.e. the federate that created it and\n    * has write-privileges to its attributes (so, it is responsible for updating\n    * these attribute and conveying their updated values to the RTI).\n    *\n    * @param rti handle to the RTI, usu. obtained through the\n    * {@link SynchronizedFederate#getRTI()} call\n    */ \n    public void registerObject( RTIambassador rti ) {\n        \n        while( !_isRegistered ) {\n            try {\n                synchronized( rti ) {\n                    _object_handle = rti.registerObjectInstance( getClassHandle() );\n                }\n                _isRegistered = true;\n                _objectMap.put( getObjectHandle(), this );\n                \n            } catch ( ObjectClassNotDefined o ) {\n                o.printStackTrace();\n                return;\n            } catch ( ObjectClassNotPublished o ) {\n                o.printStackTrace();\n                return;\n            } catch ( FederateNotExecutionMember f ) {\n                f.printStackTrace();\n                return;\n            } catch ( Exception e ) {\n                try {\n                    Thread.sleep( 500 );\n                } catch ( InterruptedException e1 ) {\n                    e1.printStackTrace();\n                } \n            }\n        }\n\n    }\n    \n    /**\n    * Unregisters this object with the RTI.  The RTI will destroy all information\n    * it contains regarding this object as a result.  This method is usually\n    * called by a federate who \"owns\" this object, i.e. the federate that created\n    * it and has write-privileges to its attributes.\n    *\n    * @param rti handle to the RTI, usu. obtained through the\n    * {@link SynchronizedFederate#getRTI()} call\n    */ \n    public void unregisterObject( RTIambassador rti ) {\n        \n        while( _isRegistered ) {\n            try {\n                synchronized( rti ) {\n                    rti.deleteObjectInstance( _object_handle, null );\n                }\n                _isRegistered = false;\n                _objectMap.remove( getObjectHandle() );\n                \n            } catch ( ObjectNotKnown o ) {\n                o.printStackTrace();\n                return;\n            } catch ( DeletePrivilegeNotHeld d ) {\n                d.printStackTrace();\n                return;\n            } catch ( FederateNotExecutionMember f ) {\n                f.printStackTrace();\n                return;\n            } catch ( Exception e ) {\n                try {\n                    Thread.sleep( 500 );\n                } catch ( InterruptedException e1 ) {\n                    e1.printStackTrace();\n                } \n            }\n        }\n    }\n\n    /**\n    * Broadcasts the attributes of this object and their values to the RTI, where\n    * the values have \"time\" as their timestamp.  This call should be used for\n    * objects whose attributes have \"timestamp\" ordering.\n    *\n    * @param rti handle to the RTI, usu. obtained through the\n    * {@link SynchronizedFederate#getRTI()} call\n    * @param time timestamp on attribute values of this object\n    * @param force if \"false\", only the attributes whose values have changed since\n    * the last call to \"updateAttributeValues\" will be broadcast to the RTI.  If\n    * \"true\", all attributes and their values are broadcast to the RTI.\n    */\n    public void updateAttributeValues( RTIambassador rti, double time, boolean force ) {\n\n        SuppliedAttributes suppliedAttributes = createSuppliedDatamembers( force );\n        if ( suppliedAttributes.size() == 0 ) return;\n\n        synchronized( rti ) {\n            try {\n                rti.updateAttributeValues(  getObjectHandle(), suppliedAttributes, null, new DoubleTime( time )  );\n                createLog(suppliedAttributes, time);\n            } catch ( ObjectNotKnown o ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Object Not Known\" );\n                o.printStackTrace();\n                return;\n            } catch ( FederateNotExecutionMember f ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Federate Not Execution Member\" );\n                f.printStackTrace();\n                return;\n            } catch ( AttributeNotDefined a ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Attribute Not Defined\" );\n                a.printStackTrace();\n                return;\n            } catch ( AttributeNotOwned a ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Attribute Not Owned\" );\n                a.printStackTrace();\n                return;\n            } catch ( ConcurrentAccessAttempted c ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Concurrent Access Attempted\" );\n                c.printStackTrace();\n                return;\n            } catch ( InvalidFederationTime i ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Invalid Federation Time\" );\n                i.printStackTrace();\n                return;\n            } catch ( Exception e ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes\" );\n                e.printStackTrace();\n            }\n        }\n    }\n\n    /**\n    * Like {@link #updateAttributeValues( RTIambassador rti, double time, boolean force )},\n    * except \"force\" is always false.\n    *\n    * @param rti handle to the RTI, usu. obtained through the\n    * {@link SynchronizedFederate#getRTI()} call\n    * @param time timestamp on attribute values of this object\n    */\n    public void updateAttributeValues( RTIambassador rti, double time ) {\n        updateAttributeValues( rti, time, false );\n    }\n\n    /**\n    * Broadcasts the attributes of this object and their values to the RTI (with\n    * no timestamp).  This call should be used for objects whose attributes have\n    * \"receive\" ordering.\n    *\n    * @param rti handle to the RTI, usu. obtained through the\n    * {@link SynchronizedFederate#getRTI()} call\n    * @param force if \"false\", only the attributes whose values have changed since\n    * the last call to \"updateAttributeValues\" will be broadcast to the RTI.  If\n    * \"true\", all attributes and their values are broadcast to the RTI.\n    */\n    public void updateAttributeValues( RTIambassador rti, boolean force ) {\n\n        SuppliedAttributes suppliedAttributes = createSuppliedDatamembers( force );\n        if ( suppliedAttributes.size() == 0 ) return;\n\n        synchronized( rti ) {\n            try {\n                rti.updateAttributeValues( getObjectHandle(), suppliedAttributes, null );\n                createLog(suppliedAttributes, 0);\n            } catch ( ObjectNotKnown o ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Object Not Known\" );\n                o.printStackTrace();\n                return;\n            } catch ( FederateNotExecutionMember f ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Federate Not Execution Member\" );\n                f.printStackTrace();\n                return;\n            } catch ( AttributeNotDefined a ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Attribute Not Defined\" );\n                a.printStackTrace();\n                return;\n            } catch ( AttributeNotOwned a ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Attribute Not Owned\" );\n                a.printStackTrace();\n                return;\n            } catch ( ConcurrentAccessAttempted c ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Concurrent Access Attempted\" );\n                c.printStackTrace();\n                return;\n            } catch ( Exception e ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes\" );\n                e.printStackTrace();\n            }\n        }\n    }\n\n    /**\n    * Like {@link #updateAttributeValues( RTIambassador rti, boolean force )},\n    * except \"force\" is always false.\n    *\n    * @param rti handle to the RTI, usu. obtained through the\n    * {@link SynchronizedFederate#getRTI()} call\n    */\n    public void updateAttributeValues( RTIambassador rti ) {\n        updateAttributeValues( rti, false );\n    }\n\n    protected static String _fedName = null;\n    protected static Map< String, String > _pubAttributeLogMap = new HashMap< String, String >();\n    protected static Map< String, String > _subAttributeLogMap = new HashMap< String, String >();\n    \n    public static void enablePublishLog(String object, String attribute, String fed, String thislevel, String globallevel){\n        if(globallevel == null || \"\".equals(globallevel)) return;\n        if(C2WLogger.getLogLevel(thislevel)> C2WLogger.getLogLevel(globallevel)) return;\n        _fedName = fed;\n        _pubAttributeLogMap.put(attribute, thislevel);\n        C2WLogger.addLog(object, attribute, fed, true);\n    }\n    \n    public static void enableSubscribeLog(String object, String attribute, String fed, String thislevel, String globallevel){\n        if(globallevel == null || \"\".equals(globallevel)) return;\n        if(C2WLogger.getLogLevel(thislevel)> C2WLogger.getLogLevel(globallevel)) return;\n        _fedName = fed;\n        _subAttributeLogMap.put(attribute, thislevel);\n        C2WLogger.addLog(object, attribute, fed, true);\n    }\n    \n    protected void createLog(final SuppliedAttributes suppliedAttributes, final double time) {\n        if(_pubAttributeLogMap.isEmpty()) return;\n        Thread t = new Thread(new Runnable() {                                                       // NOMELD\n            public void run() {                                                                      // NOMELD\n                try {\n                    String eventName = _fedName+\"_pub_\"+getSimpleClassName();\n\n                    // First just record the interaction event as a log\n                    C2WLogger.addEventLog(time, eventName);\n\n                    // Now, log detailed simulation data of the object update\n                    String logIdLocal = null;\n                    synchronized( <%=rootname%>.class ) {\n                        logIdLocal = Integer.toString( logId++ );\n                    }\n                    for(int ix =0; ix < suppliedAttributes.size();ix++){                            \n                        String attribute = get_attribute_name(suppliedAttributes.getHandle( ix ) );            \n                        if(!_pubAttributeLogMap.containsKey(attribute)) continue;\n                        String id = _fedName+\"_pub_\"+getSimpleClassName()+\"_\"+attribute;\n                        String value = new String(suppliedAttributes.getValue(ix));    \n                        String type = new String(_datamemberTypeMap.get(attribute));\n                        String loglevel = _pubAttributeLogMap.get(attribute);\n                        C2WLogger.addLog( id, time, attribute, value, type, loglevel, logIdLocal );                \n                    }\n                } catch ( Exception e ) {\n                    System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not send interaction\" );\n                    e.printStackTrace();\n                }\n            }\n        });\n        t.start();\n    }\n    \n<%}%>\n\n    /**\n    * For use with the melding API -- this method is used to cast\n    * <%=rootname%> instance reference into the\n    * <%=rootname%>Interface interface.\n    *\n    * @param rootInstance <%=rootname%> instance reference to be\n    * cast into the <%=rootname%>Interface interface\n    * @return <%=rootname%>Interface reference to the instance\n    */\n    public <%=rootname%>Interface cast( <%=rootname%> rootInstance ) {\n        return rootInstance;\n    }        \n\n    /**\n    * For use with the melding API -- this method creates a new\n    * <%=rootname%> instance and returns a\n    * <%=rootname%>Interface reference to it.\n    *\n    * @return <%=rootname%>Interface reference to a newly created\n    * <%=rootname%> instance\n    */\n    public <%=rootname%>Interface create() {\n        return new <%=rootname%>();\n    }        \n\n    public void copyFrom( Object object ) { }\n}\n",
    "java/federate-config.json.ejs": "<% /*\ninput properties\n----------------\nclassname   string\nlookahead   number\nprojectName string\nstep        number\n\nused in\n-------\nJavaImplFederate.js\n\n*/ -%>\n{\n  \"federateRTIInitWaitTimeMs\": 200,\n  \"federateType\": \"<%=classname%>\",\n  \"federationId\": \"<%=projectName%>\",\n  \"isLateJoiner\": false,\n  \"lookAhead\": <%=lookahead%>,\n  \"stepSize\": <%=step%>\n}\n",
    "java/federate.java.ejs": "<%/* \ninput properties used\n---------------------\nallinteractiondata         object\nallobjectdata              object\nasynchronousdelivery\nclassname                  string\nmelderpackagename          string\npublishedinteractiondata\npublishedobjectdata\ntimeconstrained\ntimeregulating\nsimname                    string\nsubscribedinteractiondata\nsubscribedobjectdata\n    \nused in\n-------\nNOT USED - MIGHT DELETE\n\n*/ -%>\n\npackage <%= simname %>;\n\nimport hla.rti.EventRetractionHandle;\nimport hla.rti.LogicalTime;\nimport hla.rti.ReceivedInteraction;\n\nimport org.cpswt.hla.C2WInteractionRoot;\nimport org.cpswt.hla.InteractionRoot;\nimport org.cpswt.hla.SubscribedInteractionFilter;\nimport org.cpswt.hla.SynchronizedFederate;\n\nimport org.cpswt.config.FederateConfig;\n\nimport org.cpswt.hla.*;\n<% if(melderpackagename){ -%>\nimport <%= melderpackagename %>.<%= classname %>;\nimport <%= melderpackagename %>.<%= classname %>RTIFactory;\n<% } -%>\n\npublic class <%= classname %>Base extends <% if(melderpackagename) { %><%= classname %><% }else{ %>SynchronizedFederate<% } %> {\n\n<% if(melderpackagename){ -%>\n    static {\n        <%= classname %>RTIFactory rtiFactory = new <%= classname %>RTIFactory();\n<% /*allinteractiondata:setfactoryvar()*/ -%>\n        <% allinteractiondata.forEach(function(rticlass){ %>\n        rtiFactory.set_<%= rticlass.name %>Interface( new <%= rticlass.name %>Melder() );<%});%>\n<% /*allobjectdata:setfactoryvar()*/ -%>\n        <% allobjectdata.forEach(function(rticlass){ %>\n        rtiFactory.set_<%= rticlass.name %>Interface( new <%= rticlass.name %>Melder() );<%});%>\n        <%= classname %>.set<%= classname %>RTIFactory( rtiFactory );\n    }\n<% } -%>\n    private SubscribedInteractionFilter _subscribedInteractionFilter = new SubscribedInteractionFilter();\n\n    // constructor\n    public <%= classname %>Base(FederateConfig config) throws Exception {\n        super(config);\n        super.createLRC();\n        super.joinFederation();\n\n<% if(timeconstrained){ -%>\n        enableTimeConstrained();\n<% } %>\n<% if(timeregulating){ -%>\n        enableTimeRegulation(getLookAhead());\n<% } -%>\n<% if(asynchronousdelivery){ -%>\n        enableAsynchronousDelivery();\n<% } -%>\n        // interaction pubsub\n<% /* publishedinteractiondata:pubinter() */ -%>\n        <% publishedinteractiondata.forEach(function(interactiondata){ %>\n        <%= interactiondata.name %>.publish(getLRC());<%});%>\n<% /* subscribedinteractiondata:subinter() */ -%>\n        <% subscribedinteractiondata.forEach(function(interactiondata){ %>\n        <%= interactiondata.name %>.subscribe(getLRC());\n        _subscribedInteractionFilter.setFedFilters( \n            <%= interactiondata.name %>.get_handle(), \n            SubscribedInteractionFilter.OriginFedFilter.<%= interactiondata.originFedFilter() %>, \n            SubscribedInteractionFilter.SourceFedFilter.<%= interactiondata.srcFedFilter() %> \n        );<%}); -%>\n        \n        // object pubsub\n<%/* publishedobjectdata:pubobjectdata() */ -%>\n        <% publishedobjectdata.forEach(function(objectdata){ %>\n            <% objectdata.publishedAttributeData.forEach(function(a){ %>\n        <%= objectdata.name %>.publish_<%= a.name %>();<%});%>\n        <%= objectdata.name %>.publish(getLRC());\n        <%}); -%>\n<%/* subscribedobjectdata:subobjectdata() */ -%>\n        <% subscribedobjectdata.forEach(function(objectdata){ %>\n            <% objectdata.subscribedAttributeData.forEach(function(a){ %>\n        <%= objectdata.name %>.subscribe_<%= a.name %>();<%});%>\n        <%= objectdata.name %>.subscribe(getLRC());\n        <%}); -%>\n        }\n\n<%/* publishedinteractiondata:create_interaction() */ -%>\n    <%publishedinteractiondata.forEach(function(interaction_data){%>\n    public <%= interaction_data.name %> create_<%= interaction_data.name %>() {\n       <%= interaction_data.name%> interaction = new <%= interaction_data.name %>();\n       interaction.set_sourceFed( getFederateId() );\n       interaction.set_originFed( getFederateId() );\n       return interaction;\n    }<%}); %>\n<%/* filter_interaction() */ -%>\n    @Override\n    public void receiveInteraction(\n     int interactionClass, ReceivedInteraction theInteraction, byte[] userSuppliedTag\n    ) {\n        InteractionRoot interactionRoot = InteractionRoot.create_interaction( interactionClass, theInteraction );\n        if ( interactionRoot instanceof C2WInteractionRoot ) {\n            \n            C2WInteractionRoot c2wInteractionRoot = (C2WInteractionRoot)interactionRoot;\n\n            // Filter interaction if src/origin fed requirements (if any) are not met\n            if (  _subscribedInteractionFilter.filterC2WInteraction( getFederateId(), c2wInteractionRoot )  ) {\n                return;\n            }\n        }\n\n        super.receiveInteraction( interactionClass, theInteraction, userSuppliedTag );\n    }\n\n    @Override\n    public void receiveInteraction(\n     int interactionClass,\n     ReceivedInteraction theInteraction,\n     byte[] userSuppliedTag,\n     LogicalTime theTime,\n     EventRetractionHandle retractionHandle\n    ) {\n        InteractionRoot interactionRoot = InteractionRoot.create_interaction( interactionClass, theInteraction, theTime );\n        if ( interactionRoot instanceof C2WInteractionRoot ) {\n\n            C2WInteractionRoot c2wInteractionRoot = (C2WInteractionRoot)interactionRoot;\n\n            // Filter interaction if src/origin fed requirements (if any) are not met\n            if (  _subscribedInteractionFilter.filterC2WInteraction( getFederateId(), c2wInteractionRoot )  ) {\n                return;\n            }\n        }\n\n        super.receiveInteraction( interactionClass, theInteraction, userSuppliedTag, theTime, retractionHandle );\n    }\n}\n",
    "java/federatebase.java.ejs": "<% /*\ninput properties\n----------------\nallinteractiondata\nallobjectdata\nasynchronousdelivery\nclassname\nmelderpackagename\npublishedinteractiondata\npublishedobjectdata\nsubscribedinteractiondata\nsubscribedobjectdata\ntimeconstrained\ntimeregulating\n(and others not used)\n\nused in\n-------\nJavaImplFederate.js\n\n*/ -%>\npackage <%= groupId %>.<%= classname.toLowerCase() %>;\n\n<% if(publishedinteractiondata.length || subscribedinteractiondata.length || publishedobjectdata.length || subscribedobjectdata.length) { -%>\nimport <%= groupId %>.<%= classname.toLowerCase() %>.rti.*;\n<% } -%>\n\nimport hla.rti.EventRetractionHandle;\nimport hla.rti.LogicalTime;\nimport hla.rti.ReceivedInteraction;\n\nimport org.cpswt.hla.C2WInteractionRoot;\nimport org.cpswt.hla.InteractionRoot;\nimport org.cpswt.hla.SubscribedInteractionFilter;\nimport org.cpswt.hla.SynchronizedFederate;\n\nimport org.cpswt.config.FederateConfig;\nimport org.cpswt.utils.CpswtDefaults;\n\nimport org.cpswt.*;\n\n<% if(melderpackagename){ -%>\nimport <%= melderpackagename %>.<%= classname %>;\nimport <%= melderpackagename %>.<%= classname %>RTIFactory;\n<% } -%>\n\npublic class <%= classname %>Base extends <% if(melderpackagename) { %><%= classname %><% }else{ %>SynchronizedFederate<% } %> {\n<% if(melderpackagename){ -%>\n        static {\n                <%= classname %>RTIFactory rtiFactory = new <%= classname %>RTIFactory();\n<% /*allinteractiondata:setfactoryvar()*/ -%>\n                <% allinteractiondata.forEach(function(rticlass){ %>\n                rtiFactory.set_<%= rticlass.name %>Interface( new <%= rticlass.name %>Melder() );<%});%>\n<% /*allobjectdata:setfactoryvar()*/ -%>\n                <% allobjectdata.forEach(function(rticlass){ %>\n                rtiFactory.set_<%= rticlass.name %>Interface( new <%= rticlass.name %>Melder() );<%});%>\n\n                <%= classname %>.set<%= classname %>RTIFactory( rtiFactory );\n        }\n<% } -%>\n    private SubscribedInteractionFilter _subscribedInteractionFilter =\n        new SubscribedInteractionFilter();\n\n    // constructor\n    public <%= classname %>Base(FederateConfig config) throws Exception {\n        super(config);\n        super.createLRC();\n        super.joinFederation();\n<% if(timeconstrained){ -%>\n        enableTimeConstrained();\n<% } -%>\n<% if(timeregulating){ -%>\n        enableTimeRegulation(getLookAhead());\n<% } -%>\n<% if(asynchronousdelivery){ -%>\n        enableAsynchronousDelivery();\n<% } -%>\n\n        // interaction pubsub\n<% /* publishedinteractiondata:pubinter() */ -%>\n<% publishedinteractiondata.forEach(function(interactiondata){ -%>\n        <%= interactiondata.name %>.publish(getLRC());\n<% }); -%>\n<% /* subscribedinteractiondata:subinter() */ -%>\n<% subscribedinteractiondata.forEach(function(interactiondata){ -%>\n        <%= interactiondata.codeNameOrName %>.subscribe(getLRC());\n        _subscribedInteractionFilter.setFedFilters( \n           <%= interactiondata.codeNameOrName %>.get_handle(),\n           SubscribedInteractionFilter.OriginFedFilter.<%= interactiondata.originFedFilter() %>,\n           SubscribedInteractionFilter.SourceFedFilter.<%= interactiondata.srcFedFilter() %>);\n<% }); -%>\n\n        // object pubsub\n<%/* publishedobjectdata:pubobjectdata() */ -%>\n<% publishedobjectdata.forEach(function(objectdata){ -%>\n<% objectdata.publishedAttributeData.forEach(function(a){ -%>\n        <%= objectdata.codeNameOrName %>.publish_<%= a.name %>();\n<% }); -%>\n        <%= objectdata.codeNameOrName %>.publish(getLRC());\n<% }); -%>\n<%/* subscribedobjectdata:subobjectdata() */ -%>\n<% subscribedobjectdata.forEach(function(objectdata){ -%>\n<% objectdata.subscribedAttributeData.forEach(function(a){ -%>\n        <%= objectdata.codeNameOrName %>.subscribe_<%= a.name %>();\n<% }); -%>\n        <%= objectdata.codeNameOrName %>.subscribe(getLRC());\n<% }); -%>\n    }\n\n<%/* publishedinteractiondata:create_interaction() */ -%>\n<%publishedinteractiondata.forEach(function(interaction_data){ -%>\n    public <%= interaction_data.codeNameOrName %> create_<%= interaction_data.codeNameOrName %>() {\n        <%= interaction_data.codeNameOrName%> interaction = new <%= interaction_data.codeNameOrName %>();\n        interaction.set_sourceFed(getFederateId());\n        interaction.set_originFed(getFederateId());\n        return interaction;\n    }\n<% }); -%>\n\n<%/* filter_interaction() */ -%>\n    @Override\n    public void receiveInteraction(int interactionClass,\n                                   ReceivedInteraction theInteraction,\n                                   byte[] userSuppliedTag) {\n        InteractionRoot interactionRoot =\n            InteractionRoot.create_interaction(interactionClass,\n                                               theInteraction);\n        if (interactionRoot instanceof C2WInteractionRoot) {\n            C2WInteractionRoot c2wInteractionRoot =\n                (C2WInteractionRoot)interactionRoot;\n\n            // Filter interaction if src/origin fed requirements (if any)\n            // are not met\n            if (_subscribedInteractionFilter.filterC2WInteraction\n                (getFederateId(), c2wInteractionRoot)) {\n                return;\n            }\n        }\n        super.receiveInteraction(interactionClass, theInteraction,\n                                 userSuppliedTag);\n    }\n\n    @Override\n    public void receiveInteraction(int interactionClass,\n                                   ReceivedInteraction theInteraction,\n                                   byte[] userSuppliedTag,\n                                   LogicalTime theTime,\n                                   EventRetractionHandle retractionHandle) {\n        InteractionRoot interactionRoot =\n            InteractionRoot.create_interaction(interactionClass,\n                                               theInteraction, theTime);\n        if (interactionRoot instanceof C2WInteractionRoot) {\n            C2WInteractionRoot c2wInteractionRoot =\n                (C2WInteractionRoot)interactionRoot;\n\n            // Filter interaction if src/origin fed requirements (if any)\n            // are not met\n            if (_subscribedInteractionFilter.filterC2WInteraction\n                (getFederateId(), c2wInteractionRoot)) {\n                return;\n            }\n        }\n        super.receiveInteraction(interactionClass, theInteraction,\n                                 userSuppliedTag, theTime, retractionHandle);\n    }\n}\n",
    "java/federateimpl.java.ejs": "<% /*\n\ninput properties\n----------------\n   classname (string)\n   groupId (string)\n   publishedinteractiondata (array of JavaScript objects)\n      [details omitted]\n   publishedobjectdata (array of JavaScript objects)\n      name (string)\n      codeNameOrName (string)\n      fullName (string)\n      lowerName (string)\n      parameters (array of JavaScript objects)\n      publishedAttributeData (array JavaScript objects)\n      publishedLogLevel (string)\n      logPublishedAttributeData (array of JavaScript objects)\n   subscribedinteractiondata (array of JavaScript objects)\n      name (string)\n      codeNameOrName (string)\n      fullName (string\n      lowerName (string)\n      originFedFilter (function)\n      parameters (array of JavaScript objects)\n      sourceFedFilter (function)\n      subscribedLogLevel (string)\n   subscribedobjectdata (array of JavaScript objects)\n      name (string)\n      codeNameOrName (string)\n      fullName (string)\n      lowerName (string)\n      parameters (array of JavaScript objects)\n      subscribedAttributeData (array JavaScript objects)\n      subscribedLogLevel (string)\n      logSubscribedAttributeData (array of JavaScript objects)\n   (and others not used)\n\nused in\n-------\nJavaImplFederate.js\n \n*/ -%>\npackage <%= groupId %>.<%= classname.toLowerCase() %>;\n\n<% if(publishedinteractiondata.length || subscribedinteractiondata.length || publishedobjectdata.length || subscribedobjectdata.length) { -%>\nimport <%= groupId %>.<%= classname.toLowerCase() %>.rti.*;\n<% } -%>\n\nimport org.cpswt.config.FederateConfig;\nimport org.cpswt.config.FederateConfigParser;\n<%if (subscribedobjectdata.length > 0) { -%>\nimport org.cpswt.hla.base.ObjectReflector;\nimport org.cpswt.hla.ObjectRoot;\n<% } -%>\n<% if (subscribedinteractiondata.length > 0) { -%>\nimport org.cpswt.hla.InteractionRoot;\n<% } -%>\nimport org.cpswt.hla.base.AdvanceTimeRequest;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\n<% var codeNameobjects = {}; -%>\n<% var codeNameinteractions = {}; -%>\n<% var n = 0; -%>\n<% var m = 0; -%>\n<% publishedobjectdata.forEach(function(object_data){ -%>\n<% if (object_data.codeName) -%>\n<% {codeNameobjects[object_data.codeName] = object_data.name;}}); -%>\n<% subscribedobjectdata.forEach(function(object_data){ -%>\n<% if (object_data.codeName) -%>\n<% {codeNameobjects[object_data.codeName] = object_data.name;}}); -%>\n<% for (var prop in codeNameobjects) {if (prop && (prop != null)) n++;} -%>\n<% publishedinteractiondata.forEach(function(interact_data){ -%>\n<% if (interact_data.codeName) -%>\n<% {codeNameinteractions[interact_data.codeName] = interact_data.name;}}); -%>\n<% subscribedinteractiondata.forEach(function(interact_data){ -%>\n<% if (interact_data.codeName) -%>\n<% {codeNameinteractions[interact_data.codeName] = interact_data.name;}}); -%>\n<% for (var prop in codeNameobjects) {if (prop && (prop != null)) n++;} -%>\n<% for (var prop in codeNameinteractions) {if (prop && (prop != null)) m++;} -%>\n<% if (n + m) { -%>\n// CodeGeneratedName is used if necessary. Otherwise, name is used.\n<% } -%>\n<% if (n) { -%>\n// The following object classes have both CodeGeneratedName and name.\n<% for (var prop in codeNameobjects){ -%>\n<% if (prop && (prop != null)) { -%>\n// CodeGeneratedName = <%= prop %>   name = <%= codeNameobjects[prop] %>\n<% }}} -%>\n<% if (m) { -%>\n// The following interaction classes have both CodeGeneratedName and name.\n<% for (var prop in codeNameinteractions){ -%>\n<% if (prop && (prop != null)) { -%>\n// CodeGeneratedName = <%= prop %>   name = <%= codeNameinteractions[prop] %>\n<% }}} -%>\n\n\n// Define the <%= classname %> type of federate for the federation.\n\npublic class <%= classname %> extends <%= classname %>Base {\n    private final static Logger log = LogManager.getLogger();\n\n    private double currentTime = 0;\n<% if (publishedobjectdata.length > 0) { -%>\n\n    ////////////////////////////////////////////////////////////////////////\n    // TODO instantiate objects that must be sent every logical time step //\n    ////////////////////////////////////////////////////////////////////////\n<% publishedobjectdata.forEach(function(object_data){ -%>\n    // <%=object_data.codeNameOrName%> <%=object_data.lowerName%> =\n    //     new <%=object_data.codeNameOrName%>();\n<% }); -%>\n<% } -%>\n\n    public <%= classname %>(FederateConfig params) throws Exception {\n        super(params);\n<% if (publishedobjectdata.length > 0) { -%>\n\n        //////////////////////////////////////////////////////\n        // TODO register object instances after super(args) //\n        //////////////////////////////////////////////////////\n<% publishedobjectdata.forEach(function(object_data){ -%>\n        // <%=object_data.lowerName%>.registerObject(getLRC());\n<% }); -%>\n<% } -%>\n    }\n<% if (subscribedinteractiondata.length + subscribedobjectdata.length > 0) { -%>\n<% var conditional = \"if\"; -%>\n\n    private void checkReceivedSubscriptions() {\n<% if (subscribedinteractiondata.length > 0) { -%>\n<% conditional = \"if\"; -%>\n        InteractionRoot interaction = null;\n        while ((interaction = getNextInteractionNoWait()) != null) {\n<% (subscribedinteractiondata.sort(function(a, b){return b.fullName.length-a.fullName.length})).forEach(function(interaction_data){ -%>\n            <%= conditional %> (interaction instanceof <%= interaction_data.codeNameOrName %>) {\n                handleInteractionClass((<%= interaction_data.codeNameOrName %>) interaction);\n            }\n<% conditional = \"else if\"; -%>\n<% }); -%>\n            else {\n                log.debug(\"unhandled interaction: {}\", interaction.getClassName());\n            }\n        }\n<% } -%>\n<%if (subscribedobjectdata.length > 0) { -%>\n<% conditional = \"if\"; -%>\n\n        ObjectReflector reflector = null;\n        while ((reflector = getNextObjectReflectorNoWait()) != null) {\n            reflector.reflect();\n            ObjectRoot object = reflector.getObjectRoot();\n<% (subscribedobjectdata.sort(function(a, b){return b.fullName.length-a.fullName.length})).forEach(function(object_data){ -%>\n            <%= conditional %> (object instanceof <%= object_data.codeNameOrName %>) {\n                handleObjectClass((<%= object_data.codeNameOrName %>) object);\n            }\n<% conditional = \"else if\"; -%>\n<%}) -%>\n            else {\n                log.debug(\"unhandled object reflection: {}\", object.getClassName());\n            }\n        }\n<% } -%>\n    }\n<% } -%>\n\n    private void execute() throws Exception {\n        if(super.isLateJoiner()) {\n            log.info(\"turning off time regulation (late joiner)\");\n            currentTime = super.getLBTS() - super.getLookAhead();\n            super.disableTimeRegulation();\n        }\n\n        /////////////////////////////////////////////\n        // TODO perform basic initialization below //\n        /////////////////////////////////////////////\n\n        AdvanceTimeRequest atr = new AdvanceTimeRequest(currentTime);\n        putAdvanceTimeRequest(atr);\n\n        if(!super.isLateJoiner()) {\n            log.info(\"waiting on readyToPopulate...\");\n            readyToPopulate();\n            log.info(\"...synchronized on readyToPopulate\");\n        }\n\n        ///////////////////////////////////////////////////////////////////////\n        // TODO perform initialization that depends on other federates below //\n        ///////////////////////////////////////////////////////////////////////\n\n        if(!super.isLateJoiner()) {\n            log.info(\"waiting on readyToRun...\");\n            readyToRun();\n            log.info(\"...synchronized on readyToRun\");\n        }\n\n        startAdvanceTimeThread();\n        log.info(\"started logical time progression\");\n\n        while (!exitCondition) {\n            atr.requestSyncStart();\n            enteredTimeGrantedState();\n<% if (publishedinteractiondata.length > 0) { -%>\n\n            ////////////////////////////////////////////////////////////\n            // TODO send interactions that must be sent every logical //\n            // time step below                                        //\n            ////////////////////////////////////////////////////////////\n\n            // Set the interaction's parameters.\n            //\n<% publishedinteractiondata.forEach(function(interaction_data){ -%>\n            //    <%= interaction_data.codeNameOrName %> <%= interaction_data.lowerName %> = create_<%= interaction_data.codeNameOrName %>();\n<% interaction_data.parameters.forEach(function(parameter) { -%>\n            //    <%= interaction_data.lowerName %>.set_<%= parameter.name %>( < YOUR VALUE HERE > );\n<% }) -%>\n            //    <%= interaction_data.lowerName %>.sendInteraction(getLRC(), currentTime + getLookAhead());\n<% }) -%>\n<% } -%>\n<% if (publishedobjectdata.length > 0) { -%>\n\n            ////////////////////////////////////////////////////////////\n            // TODO objects that must be sent every logical time step //\n            ////////////////////////////////////////////////////////////\n<% publishedobjectdata.forEach(function(object_data){ -%>\n<% if (object_data.parameters.length > 0) { -%>\n<% object_data.parameters.forEach(function(parameter) { -%>\n            //    <%= object_data.lowerName %>.set_<%= parameter.name %>(<YOUR VALUE HERE >);\n<% }) -%>\n<% } -%>\n            //    <%= object_data.lowerName %>.updateAttributeValues(getLRC(), currentTime + getLookAhead());\n<% }) -%>\n<% } -%>\n<% if (subscribedinteractiondata.length + subscribedobjectdata.length > 0) { -%>\n\n            checkReceivedSubscriptions();\n<% } -%>\n\n            ////////////////////////////////////////////////////////////////////\n            // TODO break here if ready to resign and break out of while loop //\n            ////////////////////////////////////////////////////////////////////\n\n            if (!exitCondition) {\n                currentTime += super.getStepSize();\n                AdvanceTimeRequest newATR =\n                    new AdvanceTimeRequest(currentTime);\n                putAdvanceTimeRequest(newATR);\n                atr.requestSyncEnd();\n                atr = newATR;\n            }\n        }\n\n        // call exitGracefully to shut down federate\n        exitGracefully();\n\n        //////////////////////////////////////////////////////////////////////\n        // TODO Perform whatever cleanups are needed before exiting the app //\n        //////////////////////////////////////////////////////////////////////\n    }\n<%/* allinteractiondata:createInteraction() */ -%>\n<%subscribedinteractiondata.forEach(function(interaction_data){ -%>\n\n    private void handleInteractionClass(<%= interaction_data.codeNameOrName %> interaction) {\n        ///////////////////////////////////////////////////////////////\n        // TODO implement how to handle reception of the interaction //\n        ///////////////////////////////////////////////////////////////\n    }\n<%}); -%>\n<%/* allobjectdata:createObject() */ -%>\n<%subscribedobjectdata.forEach(function(object_data){ -%>\n\n    private void handleObjectClass(<%= object_data.codeNameOrName %> object) {\n        //////////////////////////////////////////////////////////\n        // TODO implement how to handle reception of the object //\n        //////////////////////////////////////////////////////////\n    }\n<%}); -%>\n\n    public static void main(String[] args) {\n        try {\n            FederateConfigParser federateConfigParser =\n                new FederateConfigParser();\n            FederateConfig federateConfig =\n                federateConfigParser.parseArgs(args, FederateConfig.class);\n            <%= classname %> federate =\n                new <%= classname %>(federateConfig);\n            federate.execute();\n            log.info(\"Done.\");\n            System.exit(0);\n        }\n        catch (Exception e) {\n            log.error(e);\n            System.exit(1);\n        }\n    }\n}\n",
    "java/federateimpl_uberpom.xml.ejs": "<% /*\ninput properties\n----------------\nclassname\nconfigFile\ncpswtVersion\ngroupId\nporticoPOM\nprojectName\nprojectVersion\nreleaseUrl\nsnapshotUrl\n(and others not used)\n\nused in\n-------\nJavaImplFederate.js\n\n*/ -%>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\n    <modelVersion>4.0.0</modelVersion>\n    <groupId><%= groupId + \".\" + classname.toLowerCase() %></groupId>\n    <artifactId><%= classname %></artifactId>\n    <version><%= projectVersion %></version>\n    <packaging>jar</packaging>\n\n    <properties>\n        <federation.name><%= projectName %></federation.name>\n        <package.name><%= groupId + \".\" + classname.toLowerCase() %></package.name>\n        <federate.name><%= classname %></federate.name>\n        <federation.version><%= projectVersion %></federation.version>\n        <cpswt.version><%= cpswtVersion %></cpswt.version>\n        <nar.version>3.3.0</nar.version>\n        <configFile><%= configFile %></configFile>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.cpswt</groupId>\n            <artifactId>federate-base</artifactId>\n            <version><%= cpswtVersion %></version>\n        </dependency>\n        <dependency>\n            <groupId>org.cpswt</groupId>\n            <artifactId>base-events</artifactId>\n            <version><%= cpswtVersion %></version>\n        </dependency>\n        <dependency>\n            <groupId><%= porticoPOM.groupId %></groupId>\n            <artifactId><%= porticoPOM.artifactId %></artifactId>\n            <version><%= porticoPOM.version %></version>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.logging.log4j</groupId>\n            <artifactId>log4j-api</artifactId>\n            <version>2.8.2</version>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.logging.log4j</groupId>\n            <artifactId>log4j-core</artifactId>\n            <version>2.8.2</version>\n        </dependency>\n        <dependency>\n            <groupId>com.lmax</groupId>\n            <artifactId>disruptor</artifactId>\n            <version>3.3.6</version>\n        </dependency>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.7</version>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n    <repositories>\n        <repository>\n            <id>archiva.internal</id>\n            <name>Internal Release Repository</name>\n            <url><%= releaseUrl %></url>\n        </repository>\n        <repository>\n            <id>archiva.snapshots</id>\n            <name>Internal Snapshot Repository</name>\n            <url><%= snapshotUrl %></url>\n        </repository>\n    </repositories>\n    <distributionManagement>\n        <repository>\n            <id>archiva.internal</id>\n            <name>Internal Release Repository</name>\n            <url><%= releaseUrl %></url>\n        </repository>\n        <snapshotRepository>\n            <id>archiva.snapshots</id>\n            <name>Internal Snapshot Repository</name>\n            <url><%= snapshotUrl %></url>\n        </snapshotRepository>\n    </distributionManagement>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>2.4.3</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <transformers>\n                                <transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\">\n                                <mainClass>${package.name}.${federate.name}</mainClass>\n                                </transformer>\n                            </transformers>\n                            <filters>\n                                <filter>\n                                    <artifact>*:*</artifact>\n                                    <excludes>\n                                        <exclude>META-INF/*.SF</exclude>\n                                        <exclude>META-INF/*.DSA</exclude>\n                                        <exclude>META-INF/*.RSA</exclude>\n                                    </excludes>\n                                </filter>\n                            </filters>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-surefire-plugin</artifactId>\n                <version>2.19.1</version>\n                <configuration>\n                    <forkMode>once</forkMode>\n                    <argLine>-Djava.library.path=${project.basedir}/target/nar/processid-${cpswt.version}-amd64-Linux-gpp-jni/lib/amd64-Linux-gpp/jni/</argLine>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-antrun-plugin</artifactId>\n                <version>1.8</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>run</goal>\n                        </goals>\n                        <configuration>\n                            <tasks>\n                                <copy todir=\"${basedir}/target/conf\" overwrite=\"true\">\n                                    <fileset dir=\"${basedir}/conf\" />\n                                </copy>\n                                <copy todir=\"${basedir}/target\" overwrite=\"true\">\n                                    <fileset file=\"${basedir}/RTI.rid\" />\n                                </copy>\n                            </tasks>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.5.1</version>\n                <configuration>\n                    <source>1.8</source>\n                    <target>1.8</target>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n        <profiles>\n        <profile>\n            <id>${federate.name}</id>\n        </profile>\n        <profile>\n            <id>JavaFed</id>\n            <build>\n                <plugins>\n                    <plugin>\n                        <groupId>org.codehaus.mojo</groupId>\n                        <artifactId>exec-maven-plugin</artifactId>\n                        <version>1.5.0</version>\n                        <goals>\n                            <goal>java</goal>\n                        </goals>\n                        <configuration>\n                            <systemProperties>\n                                <systemProperty>\n                                    <key>java.net.preferIPv4Stack</key>\n                                    <value>true</value>\n                                </systemProperty>\n                            </systemProperties>\n                            <classpathScope>runtime</classpathScope>\n                            <mainClass>${package.name}.${federate.name}</mainClass>\n                            <arguments>\n                                <argument>-configFile</argument>\n                                <argument>${configFile}</argument>\n                            </arguments>\n                        </configuration>\n                    </plugin>\n                </plugins>\n            </build>\n        </profile>\n    </profiles>\n</project>\n",
    "java/federatertifactory.java.ejs": "<% /*federatertifactory( melderpackagename, classname, allinteractiondata, allobjectdata ) ::= <<*/%>\npackage <%= melderpackagename %>;\n\npublic class <%=classname %> {\n\n    <%/* allinteractiondata:interfacemember() */%>\n    private <%=allinteractiondata.name %>Interface _<%=allinteractiondata.name %>_var;\n\n    <%/*  allobjectdata:interfacemember() */%>\n    private <%=allobjectdata.name %>Interface _<%=allobjectdata.name %>_var;\n\n    <%/*  allinteractiondata:setinterfacemember() */%>\n    public void set_<%= allinteractiondata.name  %>Interface( <%= allinteractiondata.name  %>Interface interface_var ) {\n        _<%= allinteractiondata.name %>_var = interface_var;\n    }\n\n    <%/*  allobjectdata:setinterfacemember() */%>\n    public void set_<%= allobjectdata.name  %>Interface( <%= allobjectdata.name  %>Interface interface_var ) {\n        _<%= allobjectdata.name %>_var = interface_var;\n    }\n\n    <%/*  allinteractiondata:getinterfacemember() */%>\n    public <%= allinteractiondata.name %>Interface get_<%= allinteractiondata.name %>Interface() {\n        return _<%= allinteractiondata.name %>_var;\n    }\n\n    <%/*  allobjectdata:getinterfacemember() */%>\n    public <%= allobjectdata.name %>Interface get_<%= allobjectdata.name %>Interface() {\n        return _<%= allobjectdata.name %>_var;\n    }\n}",
    "java/gridlabd-config.json.ejs": "<% /*\ninput properties\n----------------\nclassname    string\nlookahead    number\nprojectName  string\nstep         number\n\nused in\n-------\nGridLabDFederate.js\n\n*/ -%>\n{\n    \"federateName\": \"<%=classname%>\",\n    \"federationId\": \"<%=projectName%>\",\n    \"fomFilepath\": \"conf/<%=classname%>.xml\",\n    \"maxReconnectAttempts\": 12,\n    \"waitReconnectMs\": 5000,\n    \"isLateJoiner\": false,\n    \"stepSize\": <%=step%>,\n    \"lookAhead\": <%=lookahead%>,\n    \"workingDirectory\": \".\",\n    \"modelFilePath\": \"model.glm\"\n}\n",
    "java/gridlabd-runNOTUSED.sh.ejs": "#!/bin/bash\nconfigFile=conf/<%=classname%>.json\nif [ $# -eq 1 ] && [ -f $1 ]; then\n    configFile=$1\nfi\n\necho using the file $configFile\njava -Djava.net.preferIPv4Stack=true -Dlog4j.configurationFile=conf/log4j2.xml -jar <%=jarfile%> $configFile\n\n",
    "java/interfacecommon.java.ejs": "<% /*\ninput properties\n----------------\nisinteraction  boolean\n\nused in\n-------\ninterfaceroot.java.ejs\n\n*/ %>\n<% var IntOb = isinteraction ? \"Interaction\" : \"Object\"; -%>\n<% var intob = isinteraction ? \"interaction\" : \"object\"; -%>\n<% var ParAtt = isinteraction ? \"Parameter\" : \"Attribute\"; -%>\n<% var paratt = isinteraction ? \"parameter\" : \"attribute\"; -%>\n\n/**\n* Returns the handle (RTI assigned) of this instance's <%=intob%> class .\n* \n* @return the handle (RTI assigned) if this instance's <%=intob%> class\n*/\npublic int getClassHandle();\n\n/**\n* Returns the fully-qualified (dot-delimited) name of this instance's <%=intob%> class.\n* \n* @return the fully-qualified (dot-delimited) name of this instance's <%=intob%> class\n*/\npublic String getClassName();\n\n/**\n* Returns the simple name (last name in its fully-qualified dot-delimited name)\n* of this instance's <%=intob%> class.\n* \n* @return the simple name of this instance's <%=intob%> class \n*/\npublic String getSimpleClassName();\n\n/**\n* Returns a set containing the names of all of the non-hidden<%=paratt%>s of an\n* <%=intob%> class instance.\n*\n* @return set containing the names of all of the <%=paratt%>s of an\n* <%=intob%> class instance\n*/\npublic Set< String > get<%ParAtt%>Names();\n\n/**\n* Returns a set containing the names of all of the <%=paratt%>s of an\n* <%=intob%> class instance.\n*\n* @return set containing the names of all of the <%=paratt%>s of an\n* <%=intob%> class instance\n*/\npublic Set< String > getAll<%ParAtt%>Names();\n\n/**\n* Publishes the <%=intob%> class of this instance of the class for a federate.\n*\n* @param rti handle to the Local RTI Component\n*/\npublic void publish<%=IntOb%>( RTIambassador rti );\n\n/**\n* Unpublishes the <%=intob%> class of this instance of this class for a federate.\n*\n* @param rti handle to the Local RTI Component\n*/\npublic void unpublish<%=IntOb%>( RTIambassador rti );\n\n/**\n* Subscribes a federate to the <%=intob%> class of this instance of this class.\n*\n* @param rti handle to the Local RTI Component\n*/\npublic void subscribe<%=IntOb%>( RTIambassador rti );\n\n/**\n* Unsubscribes a federate from the <%=intob%> class of this instance of this class.\n*\n* @param rti handle to the Local RTI Component\n*/\npublic void unsubscribe<%=IntOb%>( RTIambassador rti );\n\n<% if(isinteraction){ %><% }else{ %>\n/**\n* Returns a data structure containing the handles of all attributes for this object\n* class that are currently marked for subscription.  To actually subscribe to these\n* attributes, a federate must call <objectclassname>.subscribe( RTIambassador rti ).\n*\n* @return data structure containing the handles of all attributes for this object\n* class that are currently marked for subscription\n*/\npublic AttributeHandleSet getSubscribedAttributeHandleSet();\n<%}%>",
    "java/interfaceroot.java.ejs": "<% /*\ninput properties\n----------------\nisinteraction boolean\n\nused in\n-------\nJavaRTI.js\n\nThis also uses ejs, but apparently ejs is available without being passed in.\n*/ -%>\n<% var IntOb = isinteraction ? \"Interaction\" : \"Object\"; -%>\n<% var intob = isinteraction ? \"interaction\" : \"object\"; -%>\n<% var ParAtt = isinteraction ? \"Parameter\" : \"Attribute\"; -%>\n<% var paratt = isinteraction ? \"parameter\" : \"attribute\"; -%>\npackage org.cpswt.hla;\n\nimport java.util.*;\nimport hla.rti.*;\n\npublic interface <%=IntOb%>RootInterface\n{\n    public int getUniqueID();\n\n    <%-ejs.render(TEMPLATES[\"java/interfacecommon.java.ejs\"],\n\t          {isinteraction: isinteraction,});%>\n\n    \n<% if(isinteraction){ %><%}else{%>\n    /**\n    * Requests an attribute update for this object instance from the federate that\n    * has modification rights on these attributes.\n    *\n    * @param rti handle to the Local RTI Component\n    */\n    public void requestUpdate( RTIambassador rti );\n\n    /**\n    * Returns the handle (RTI assigned) the corresponds to this object class\n    * instance.  This handle is the instance's unique identifier to the RTI.\n    *\n    * @return the handle (RTI assigned) of this object class instance.\n    */\n    public int getObjectHandle();\n<%}%>\n\n    /**\n    * Returns the timestamp for this <%=intob%>.  \"receive order\" <%=intob%>s\n    * should have a timestamp of -1.\n    *\n    * @return timestamp for this <%=intob%>\n    */\n    public double getTime();\n    \n    /**\n    * Sets the timestamp of this <%=intob%> to \"time\".\n    *\n    * @param time new timestamp for this <%=intob%>\n    */\n    public void setTime( double time );\n\n    /**\n    * Sets the timestamp of this <%=intob%> to \"logicalTime\".\n    *\n    * @param logicalTime new timestamp for this <%=intob%>\n    */\n    public void setTime( LogicalTime logicalTime );\n\n    /**\n    * Returns the value of the <%=paratt%> named \"datamemberName\" for this\n    * <%=intob%>.\n    *\n    * @param datamemberName name of <%=paratt%> whose value to retrieve\n    * @return the value of the <%=paratt%> whose name is \"datamemberName\"\n    */\n    public Object get<%=ParAtt%>( String datamemberName );\n\n    /**\n    * Returns the value of the <%=paratt%> whose handle is \"datamemberHandle\"\n    * (RTI assigned) for this <%=intob%>.\n    *\n    * @param datamemberHandle handle (RTI assigned) of <%=paratt%> whose\n    * value to retrieve\n    * @return the value of the <%=paratt%> whose handle is \"datamemberHandle\"\n    */\n    public Object get<%=ParAtt%>( int datamemberHandle );\n        \n    /**\n    * Set the values of the <%=paratt%>s in this <%=intob%> using\n    * \"datamemberMap\".  \"datamemberMap\" is usually acquired as an argument to\n    * an RTI federate callback method such as \"receiveInteraction\".\n    *\n    * @param datamemberMap  contains new values for the <%=paratt%>s of\n    * this <%=intob%>\n    */\n    public void set<%=ParAtt%>s( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap );\n\n    /**\n    * Sets the value of the <%=paratt%> named \"datamemberName\" to \"value\"\n    * in this <%=intob%>.  \"value\" is converted to data type of \"datamemberName\"\n    * if needed.\n    * This action can also be affected by calling the set_<datamemberName>( value )\n    * method on the <%=intob%> using a reference to the <%=intob%>'s actual\n    * class.\n    *\n    * @param datamemberName name of <%=paratt%> whose value is to be set\n    * to \"value\"\n    * @param value new value of <%=paratt%> called \"datamemberName\"\n    */\n    public void set<%=ParAtt%>( String datamemberName, String value );\n\n    /**\n    * Sets the value of the <%=paratt%> named \"datamemberName\" to \"value\"\n    * in this <%=intob%>.  \"value\" should have the same data type as that of\n    * the \"datamemberName\" <%=paratt%>.\n    * This action can also be affected by calling the set_<datamemberName>( value )\n    * method on the <%=intob%> using a reference to the <%=intob%>'s actual\n    * class.\n    *\n    * @param datamemberName name of <%=paratt%> whose value is to be set\n    * to \"value\"\n    * @param value new value of <%=paratt%> called \"datamemberName\"\n    */\n    public void set<%=ParAtt%>( String datamemberName, Object value );\n\n<% if(isinteraction){ %>\n    /**\n    * Sends this interaction to the RTI, with the specified timestamp \"time\".\n    * This method should be used to send interactions that have \"timestamp\"\n    * ordering.\n    *\n    * @param rti handle to the Local RTI Component\n    * @param time timestamp for this interaction.  The timestamp should be no\n    * less than the current federation time + the LOOKAHEAD value of the federate\n    * sending this interaction.\n    */\n    public void sendInteraction( RTIambassador rti, double time ) throws Exception;\n\n    /**\n    * Sends this interaction to the RTI (without a timestamp).\n    * This method should be used to send interactions that have \"receive\"\n    * ordering.\n    *\n    * @param rti handle to the Local RTI Component\n    */\n    public void sendInteraction( RTIambassador rti ) throws Exception ;\n<%}else{%>\n    /**\n    * Registers this object with the RTI.  This method is usually called by a\n    * federate who \"owns\" this object, i.e. the federate that created it and\n    * has write-privileges to its attributes (so, it is responsible for updating\n    * these attribute and conveying their updated values to the RTI).\n    *\n    * @param rti handle to the Local RTI Component\n    */ \n    public void registerObject( RTIambassador rti );\n    \n    /**\n    * Unregisters this object with the RTI.  The RTI will destroy all information\n    * it contains regarding this object as a result.  This method is usually\n    * called by a federate who \"owns\" this object, i.e. the federate that created\n    * it and has write-privileges to its attributes.\n    *\n    * @param rti handle to the Local RTI Component\n    */ \n    public void unregisterObject( RTIambassador rti );\n\n    /**\n    * Broadcasts the attributes of this object and their values to the RTI, where\n    * the values have \"time\" as their timestamp.  This call should be used for\n    * objects whose attributes have \"timestamp\" ordering.\n    *\n    * @param rti handle to the Local RTI Component\n    * @param time timestamp on attribute values of this object\n    * @param force if \"false\", only the attributes whose values have changed since\n    * the last call to \"updateAttributeValues\" will be broadcast to the RTI.  If\n    * \"true\", all attributes and their values are broadcast to the RTI.\n    */\n    public void updateAttributeValues( RTIambassador rti, double time, boolean force );\n\n    /**\n    * Like {@link #updateAttributeValues( RTIambassador rti, double time, boolean force )},\n    * except \"force\" is always false.\n    *\n    * @param rti handle to the Local RTI Component\n    * @param time timestamp on attribute values of this object\n    */\n    public void updateAttributeValues( RTIambassador rti, double time );\n\n    /**\n    * Broadcasts the attributes of this object and their values to the RTI (with\n    * no timestamp).  This call should be used for objects whose attributes have\n    * \"receive\" ordering.\n    *\n    * @param rti handle to the Local RTI Component\n    * @param force if \"false\", only the attributes whose values have changed since\n    * the last call to \"updateAttributeValues\" will be broadcast to the RTI.  If\n    * \"true\", all attributes and their values are broadcast to the RTI.\n    */\n    public void updateAttributeValues( RTIambassador rti, boolean force );\n\n    /**\n    * Like {@link #updateAttributeValues( RTIambassador rti, boolean force )},\n    * except \"force\" is always false.\n    *\n    * @param rti handle to the Local RTI Component\n    */\n    public void updateAttributeValues( RTIambassador rti );    \n<%}%>    \n}",
    "java/java-run.sh.ejs": "<% /*\ninput properties\n----------------\nclassname\njarfile\n\nused in\n-------\nJavaImplFederate.js\n\n*/ -%>\n#!/bin/bash\nconfigFile=conf/<%=classname%>.json\nif [ $# -eq 1 ] && [ -f $1 ]; then\n    configFile=$1\nfi\n\necho using the file $configFile\njava -Djava.net.preferIPv4Stack=true -Dlog4j.configurationFile=conf/log4j2.xml -jar target/<%=jarfile%> -configFile $configFile\n\n",
    "java/mapperfederate.java.ejs": "<%/* \ninput properties used\n---------------------\nclassname\nsimname\nstep_size\nmappingconnsdata\nmappingobjectsdata\n    \nused in\n-------\nMapperFederate.js\n\n*/ -%>\n\npackage <%=simname%>;\n\nimport java.util.StringTokenizer;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\nimport hla.rti.EventRetractionHandle;\nimport hla.rti.LogicalTime;\nimport hla.rti.ReceivedInteraction;\nimport org.cpswt.hla.*;\n\npublic class <%=classname%> extends <%=classname%>Base {\n\n    private static Pattern pattern = Pattern.compile( \"[^#]\" );\n\n    public <%=classname%>(String federationId, String federateId)\n            throws Exception {\n        super(federationId, federateId);\n    }\n\n    public <%=classname%>( String[] args ) throws Exception {\n        super( args );\n    }\n    \n    private static double STEP_EPSILON = 0.000001;\n    \n    public boolean isMapperFederate() {\n        return true;\n    }\n\n    <% /*mappingconnsdata:mappingconnections()*/ %>\n    <% mappingconnsdata.forEach(function(mappingconnectiondata){ %>\n    ///////////////////////////////////////////////////////////////////////////////////////\n    //\n    // For <% if(mappingconnectiondata.isSimpleConn){ %>Simple<% }else{ %>Complex<% } %>MappingConnection (ID: <%=mappingconnectiondata.uniqueId%>) between interactions:\n    //\n    //         <%=mappingconnectiondata.lHSInteractionName%> --to--> <%=mappingconnectiondata.rHSInteractionName%>\n    //\n    // This <% if(mappingconnectiondata.isSimpleConn){ %>Simple<% }else{ %>Complex<% } %>MappingConnection is located at:\n    //\n    //         <%=mappingconnectiondata.parentPath%>\n    //\n    ///////////////////////////////////////////////////////////////////////////////////////\n    public boolean isGuardConditionMet_<%=mappingconnectiondata.lHSInteractionName%>_to_<%=mappingconnectiondata.rHSInteractionName%>_<%=mappingconnectiondata.uniqueId%>(<%=mappingconnectiondata.lHSInteractionName%> i1) {\n        <%-mappingconnectiondata.guardCondition%>\n        <% if(mappingconnectiondata.guardConditionInvalid){ %>return true;<% } %>\n    }\n\n\n    public <%=mappingconnectiondata.rHSInteractionName%> map_<%=mappingconnectiondata.lHSInteractionName%>_to_<%=mappingconnectiondata.rHSInteractionName%>_<%=mappingconnectiondata.uniqueId%>(<%=mappingconnectiondata.lHSInteractionName%> i1) {\n        <%=mappingconnectiondata.rHSInteractionName%> o1 = create_<%=mappingconnectiondata.rHSInteractionName%>();\n        InteractionRoot o1IR = (InteractionRoot) o1;\n        <% if(mappingconnectiondata.isMappedInteractionANetworkPacket){ %>\n        boolean __NETWORK_PACKET_CORRUPT__ = false;\n        InteractionRoot __I1__ = (InteractionRoot) i1;\n        if(__I1__ instanceof NetworkPacket ) {\n            int numParams = o1.getParameterNames().size();\n            String __DATA__ = ((NetworkPacket) __I1__).get_data();\n            if(numParams > 0) {\n                Matcher matcher = pattern.matcher( __DATA__ );\n                if ( !matcher.find() ) {\n                    __NETWORK_PACKET_CORRUPT__ = true;\n                    if(o1IR instanceof NetworkPacket && __DATA__.length() == 0 ) {\n                        __NETWORK_PACKET_CORRUPT__ = false;\n                    }\n                }\n            } else {\n                if(__DATA__.length() > 0) {\n                    __NETWORK_PACKET_CORRUPT__ = true;\n                }\n            }\n        }\n        if(!__NETWORK_PACKET_CORRUPT__) {\n            <% if(mappingconnectiondata.isMappingSpecsNotEmpty){ %>\n            <%-mappingconnectiondata.mappingSpecs%><%}%>\n        }\n        <% }else{ %>\n        <% if(mappingconnectiondata.isMappingSpecsNotEmpty){ %>\n        <%-mappingconnectiondata.mappingSpecs%><%}%>\n        <%}%>\n\n        o1.set_originFed(i1.get_originFed());\n        o1.set_actualLogicalGenerationTime(i1.get_actualLogicalGenerationTime());\n\n        return o1;\n    }\n    <%/*EMPTY*/});%>\n    \n    <% /*mappingobjectsdata:mappingobjects()*/ %>\n    <% mappingobjectsdata.forEach(function(mappingobjectdata){ %><%/*EMPTY*/});%>\n    \n\n    <% /*execute_method()*/ %>\n    public void execute() throws Exception {\n        double currentTime = 0;\n\n        AdvanceTimeRequest atr = new AdvanceTimeRequest( currentTime );\n        putAdvanceTimeRequest( atr );\n\n        readyToPopulate();\n        readyToRun();\n\n        startAdvanceTimeThread(TIME_ADVANCE_MODE.NEXT_EVENT_REQUEST_AVAILABLE);\n\n        while( true ) {\n            System.out.print( \"<%=classname%>: Requesting RTI to proceed to (\" + currentTime + \")...\" );\n            \n            atr.requestSyncStart();\n            currentTime = atr.getCurrentTime();\n\n            System.out.println( \"granted!\" );\n\n            InteractionRoot interactionRoot;\n\n            System.out.println(\"Now waiting to receive an interaction...\");\n            while(  ( interactionRoot = getNextInteractionNoWait() ) != null ) {\n                    \n                System.out.println( \"<%=classname%>: received interaction: \\\"\" + interactionRoot + \"\\\" at time: \" + getCurrentTime() );\n\n                boolean interactionMapped = false;\n                <% /*mappingconnsdata:mappingCheck()*/ %>\n                <% mappingconnsdata.forEach(function(mappingconnectiondata){%>\n                if( interactionRoot instanceof <%=mappingconnectiondata.lHSInteractionName%> ) {\n                    <%=mappingconnectiondata.lHSInteractionName%> i1 = (<%=mappingconnectiondata.lHSInteractionName%>) interactionRoot;\n                    \n                        if(  !(interactionRoot instanceof NetworkPacket) || \"<%=mappingconnectiondata.rHSInteractionName%>\".equals(((NetworkPacket) interactionRoot).get_packetType())  ) {\n    \n                            if( isGuardConditionMet_<%=mappingconnectiondata.lHSInteractionName%>_to_<%=mappingconnectiondata.rHSInteractionName%>_<%=mappingconnectiondata.uniqueId%>(i1) ) {\n                                <%=mappingconnectiondata.rHSInteractionName%> o1 = map_<%=mappingconnectiondata.lHSInteractionName%>_to_<%=mappingconnectiondata.rHSInteractionName%>_<%=mappingconnectiondata.uniqueId%>(i1);\n                                System.out.println( \"<%=classname%>: Sending interaction: \" + o1 );\n                                o1.sendInteraction( getRTI(), getMinTSOTimestamp() );\n                            }\n                            \n                            interactionMapped = true;\n                        }\n                        \n                        <% if(mappingconnectiondata.areBothEndsOfMappingANetworkPacket){ %>\n                        // Or, if it is a mapping from an interaction type to itself then only check the guard condition\n                        if ( interactionRoot instanceof NetworkPacket && \"<%=mappingconnectiondata.lHSInteractionName%>\".equals(\"<%=mappingconnectiondata.rHSInteractionName%>\") ) {\n                            if( isGuardConditionMet_NetworkPacket_to_NetworkPacket_<%=mappingconnectiondata.uniqueId%>(i1) ) {\n                                NetworkPacket o1 = map_NetworkPacket_to_NetworkPacket_<%=mappingconnectiondata.uniqueId%>(i1);\n                                System.out.println( \"<%=classname%>: Sending interaction: \" + o1 );\n                                o1.sendInteraction( getRTI(), getMinTSOTimestamp() );\n                            }\n                            \n                            interactionMapped = true;\n                        }\n                        <% } %>\n                }<%});%>\n\n                if( !interactionMapped ) {\n                      System.out.println( \"<%=classname%>: Received unknown interaction: \" + interactionRoot );\n                   }\n            }\n\n            currentTime = getCurrentTime() + <%=step_size%> + STEP_EPSILON;\n            AdvanceTimeRequest newATR = new AdvanceTimeRequest( currentTime );\n            putAdvanceTimeRequest( newATR );\n            \n            atr.requestSyncEnd();\n            atr = newATR;\n        }\n    }\n\n    <% /*main_method()*/ %>\n    /**\n     * @param args\n     */\n    public static void main(String[] args) {\n        System.out.println( \"<%=classname%> federate starting\" );\n        try {\n            <%=classname%> mapperFed = new <%=classname%>( args );\n            mapperFed.execute();\n        } catch ( Exception e ) {\n            System.err.println( \"Exception caught: \" + e.getMessage() );\n            e.printStackTrace();\n        }\n    }\n\n}\n",
    "labview/labview-config.json.ejs": "<% /*\ninput properties\n----------------\nclassname       string\nlookahead       number\nprojectName     string\nstep            number\n\nused in\n-------\nLabVIEWFederate.js\n\n*/ -%>\n{\n    \"federateName\": \"<%=classname%>\",\n    \"federationId\": \"<%=projectName%>\",\n    \"fomFilepath\": \"conf/<%=classname%>.xml\",\n    \"maxReconnectAttempts\": 12,\n    \"waitReconnectMs\": 5000,\n    \"isLateJoiner\": false,\n    \"stepSize\": <%=step%>,\n    \"lookAhead\": <%=lookahead%>,\n    \"hostAddress\": \"localhost\",\n    \"outgoingPort\": 1234,\n    \"incomingPort\": 9119\n}\n",
    "labview/labview-pom.xml.ejs": "<% /*\ninput properties\n----------------\ngroupId              string\nlabviewPOMartifactId string\nlabviewPOMgroupId    string\nlabviewPOMversion    string\nprojectVersion       string\nrootdir              string\n\nused in\n-------\nLabVIEWFederate.js\n\n\n*/ -%>\n<?xml version=\"1.0\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <groupId><%= groupId %></groupId>\n    <version><%= projectVersion %></version>\n    <artifactId>LabView</artifactId>\n    <dependencies>\n        <dependency>\n            <groupId><%= labviewPOMgroupId %></groupId>\n            <artifactId><%= labviewPOMartifactId %></artifactId>\n            <version><%= labviewPOMversion %></version>\n        </dependency>\n    </dependencies>\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-dependency-plugin</artifactId>\n                <version>3.1.1</version>\n                <executions>\n                    <execution>\n                        <id>copy-dependencies</id>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>copy-dependencies</goal>\n                        </goals>\n                        <configuration>\n                            <outputDirectory>${project.basedir}</outputDirectory>\n                            <overWriteReleases>true</overWriteReleases>\n                            <overWriteSnapshots>true</overWriteSnapshots>\n                            <overWriteIfNewer>true</overWriteIfNewer>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-resources-plugin</artifactId>\n                <version>3.1.0</version>\n                <executions>\n                    <execution>\n                        <id>copy-resources</id>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>copy-resources</goal>\n                        </goals>\n                        <configuration>\n                            <outputDirectory>${basedir}/project</outputDirectory>\n                            <resources>\n                                <resource>\n                                    <directory><%= rootdir %>/ucef-wrappers/labview/base-project</directory>\n                                </resource>\n                            </resources>\n                            <overwrite>false</overwrite>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n\n",
    "trnsys/trnsys-config.json.ejs": "<% /*\ninput properties\n----------------\nclassname       string\nlookahead       number\nprojectName     string\nstep            number\n\nused in\n-------\nTRNSYSFederate.js\n\n*/ -%>\n{\n    \"federateName\": \"<%=classname%>\",\n    \"federationId\": \"<%=projectName%>\",\n    \"fomFilepath\": \"conf/<%=classname%>.xml\",\n    \"maxReconnectAttempts\": 12,\n    \"waitReconnectMs\": 5000,\n    \"isLateJoiner\": false,\n    \"stepSize\": <%=step%>,\n    \"lookAhead\": <%=lookahead%>,\n    \"portNumber\": 1345,\n    \"variableMapping\": \"conf/Variables.json\"\n}\n"
}});