
<%/* THIS IS THE ROOT CLASS OF EITHER THE INTERACTION OR OBJECT-CLASS HEIRARCHY (I.E. "InteractionRoot" OR "ObjectRoot") */%>
<%/*classroot(isinteraction)*/%>

/*
 * Copyright (c) 2016, Institute for Software Integrated Systems, Vanderbilt University
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without written agreement is
 * hereby granted, provided that the above copyright notice, the following
 * two paragraphs and the author appear in all copies of this software.
 *
 * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
 * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT
 * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 *
 * @author Himanshu Neema
 */
<% var IntOb = isinteraction ? "Interaction" : "Object"; -%>
<% var intob = isinteraction ? "interaction" : "object"; -%>
<% var ParAtt = isinteraction ? "Parameter" : "Attribute"; -%>
<% var paratt = isinteraction ? "parameter" : "attribute"; -%>
package org.cpswt.hla;

import hla.rti.*;
import hla.rti.jlc.RtiFactory;
import hla.rti.jlc.RtiFactoryFactory;

import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
<% if(isinteraction){%>import java.util.concurrent.LinkedBlockingQueue;<%}%>

import org.portico.impl.hla13.types.DoubleTime;

/**
 * <%= IntOb %>Root is the base class for all <%= intob %>s
 * defined in a given federation.  As such, an <%= IntOb %>Root
 * variable may refer to any type of interaction defined in the
 * federation.
 * <p/>
 * This <%= IntOb %>Root class provides the following:
 * - methods for constructing any <%= intob %> in the federation, either from
 * data provided by the RTI (for example, see
 * {@link #create_<%= intob %>( int classHandle )} or from a string argument
 * specifying the name of <%= intob %> to construct (see
 * {@link #create_<%= intob %>( String className )}.
 * - methods for sending <% if(isinteraction){ %>an interaction<%}else{%>object updates<%}%> to the RTI (see
 * {@link <% if(isinteraction){ %>#sendInteraction( RTIambassador rti )<%}else{%>#updateAttributeValues( RTIambassador rti )<%}%>} for an example).
 * - methods for publishing/subscribing to any <% if(isinteraction){ %>interaction<%}else{%>object/object attribute<%}%> 
 * defined in the federation (see
 * {@link #publish( String className, RTIambassador rti )} for example).
 * - methods for getting/setting any <%=  paratt  %> in the <%= intob %> to
 * which a given <%= IntOb %>Root variable is referring
 * (see {@link #get<%=  paratt  %>( String datamemberName )} and
 * {@link #set<%= ParAtt %>( String datamemberName, Object value )}
 */
public class <%= IntOb %>Root implements <%= IntOb %>RootInterface {

    private static int logId = 0;
    private static int _globalUniqueID = 0;
    
    private static int generateUniqueID() {
        return _globalUniqueID++;
    }
    
    private int _uniqueID;
    
    public int getUniqueID() { return _uniqueID; }
    
    protected static RtiFactory _factory;
    static {
        boolean factoryNotAcquired = true;
        while( factoryNotAcquired ) {
            try {
                _factory = RtiFactoryFactory.getRtiFactory( "org.portico.dlc.HLA13RTIFactory" );
                factoryNotAcquired = false;
            } catch ( Exception e ) {
                System.err.println( "ERROR: acquiring factory" );
                e.printStackTrace();
                try { Thread.sleep( 100 ); } catch ( Exception e1 ) { }
            }
        }
    }

    protected static Set< String > _classNameSet = new HashSet< String >();
    protected static Map< String, Class<?> > _classNameClassMap = new HashMap< String, Class<?> >();
    protected static Map<  String, Set< String >  > _datamemberClassNameSetMap = new HashMap<  String, Set< String >  >();
    protected static Map<  String, Set< String >  > _allDatamemberClassNameSetMap = new HashMap<  String, Set< String >  >();

    protected static Map< String, Integer > _classNameHandleMap = new HashMap< String, Integer >();
    protected static Map< Integer, String > _classHandleNameMap = new HashMap< Integer, String >();
    protected static Map< Integer, String > _classHandleSimpleNameMap = new HashMap< Integer, String >();
    
    protected static Map< String, Integer > _datamemberNameHandleMap = new HashMap< String, Integer >();
    protected static Map< Integer, String > _datamemberHandleNameMap = new HashMap< Integer, String >();
    protected static Map< String, String > _datamemberTypeMap = new HashMap< String, String >();

<% if(isinteraction){ %><%}else{%>
    protected static Map<  String, Set< String >  > _classNamePublishAttributeNameMap = new HashMap<  String, Set< String >  >();
    protected static Map<  String, Set< String >  > _classNameSubscribeAttributeNameMap = new HashMap<  String, Set< String >  >();

    protected static Map< String, AttributeHandleSet > _classNamePublishedAttributeMap = new HashMap< String, AttributeHandleSet >();
    protected static Map< String, AttributeHandleSet > _classNameSubscribedAttributeMap = new HashMap< String, AttributeHandleSet >();
    
    private static Map< Integer, ObjectRoot > _objectMap = new HashMap< Integer, ObjectRoot >();

    protected static class Attribute<T> {                                                                                 // NOMELD
        private T _value = null;                                                                                           // NOMELD
        private T _oldValue = null;                                                                                        // NOMELD
        private boolean _oldValueInit = false;                                                                             // NOMELD
        private double _time = 0;                                                                                          // NOMELD
                                                                                                                           // NOMELD
        public Attribute( T init ) {                                                                                       // NOMELD
            _value = init;                                                                                                 // NOMELD
        }                                                                                                                  // NOMELD
                                                                                                                           // NOMELD
        public T getValue() { return _value; }                                                                             // NOMELD
        public void setValue( T value ) {                                                                                  // NOMELD
            if ( value == null ) return;                                                                                   // NOMELD
            _value = value;                                                                                                // NOMELD
        }                                                                                                                  // NOMELD
                                                                                                                           // NOMELD
        public double getTime() { return _time; }                                                                          // NOMELD
        public void setTime( double time ) { _time = time; }                                                               // NOMELD
                                                                                                                           // NOMELD
        public void setHasBeenUpdated() {                                                                                  // NOMELD
            _oldValue = _value;                                                                                            // NOMELD
            _oldValueInit = true;                                                                                          // NOMELD
        }                                                                                                                  // NOMELD
                                                                                                                           // NOMELD
        public boolean shouldBeUpdated( boolean force ) { return force || !_oldValueInit || !_oldValue.equals( _value ); } // NOMELD        
    }                                                                                                                      // NOMELD
<%}%>

    <% /*classcommon(classname=%= IntOb %+"Root",hlaclassname=%= IntOb %+"Root",...)*/ %>
    <%- ejs.render(TEMPLATES["java/classcommon.java.ejs"],
        {
            isinteraction: isinteraction,
            classname: isinteraction?"InteractionRoot":"ObjectRoot",
            codeclassname: isinteraction?"InteractionRoot":"ObjectRoot",
            parentclassname: "",
            hlaclassname: isinteraction?"InteractionRoot":"ObjectRoot",
            datamembers: [],
            alldatamembers: []
    }) %>
    /**
    * Returns a set of strings containing the names of all of the <%= intob %>
    * classes in the current federation.
    *
    * @return Set< String > containing the names of all <%= intob %> classes
    * in the current federation
    */
    public static Set< String > get_<%= intob %>_names() { return new HashSet< String >( _classNameSet ); }

    /**
    * Returns a set of strings containing the names of all of the non-hidden <%= paratt %>s
    * in the <%= intob %> class specified by className.
    *
    * @param className name of <%= intob %> class for which to retrieve the
    * names of all of its <%= paratt %>s
    * @return Set< String > containing the names of all <%= paratt %>s in the
    * className <%= intob %> class
    */
    public static Set< String > get_<%= paratt %>_names( String className ) {
        return new HashSet< String >(  _datamemberClassNameSetMap.get( className )  );
    }
    
    /**
    * Returns a set of strings containing the names of all of the <%= paratt %>s
    * in the <%= intob %> class specified by className.
    *
    * @param className name of <%= intob %> class for which to retrieve the
    * names of all of its <%= paratt %>s
    * @return Set< String > containing the names of all <%= paratt %>s in the
    * className <%= intob %> class
    */
    public static Set< String > get_all_<%= paratt %>_names( String className ) {
        return new HashSet< String >(  _allDatamemberClassNameSetMap.get( className )  );
    }
    
    /**
    * Returns the fully-qualified name of the <%= intob %> class corresponding
    * to the RTI-defined classHandle.
    *
    * @param classHandle handle (defined by RTI) of <%= intob %> class for
    * which to retrieve the fully-qualified name
    * @return the fully-qualified name of the <%= intob %> class that
    * corresponds to the RTI-defined classHandle
    */
    public static String get_class_name( int classHandle ) {
        return _classHandleNameMap.get( classHandle );
    }

    /**
    * Returns the simple name of the <%= intob %> class corresponding to the
    * RTI-defined classHandle.  The simple name of an <%= intob %> class is
    * the last name in its (dot-delimited) fully-qualified name.
    *
    * @param classHandle handle (defined by RTI) of <%= intob %> class for which
    * to retrieve the simple name
    * @return the simple name of the <%= intob %> class that corresponds to
    * the RTI-defined classHandle
    */
    public static String get_simple_class_name( int classHandle ) {
        return _classHandleSimpleNameMap.get( classHandle );
    }
    
    /**
    * Returns the integer handle (RTI defined) of the <%= intob %> class
    * corresponding to the fully-qualified <%= intob %> class name in className.
    *
    * @param className fully-qualified name of <%= intob %> class for which to
    * retrieve the RTI-defined integer handle
    * @return the RTI-defined handle of the <%= intob %> class
    */
    public static int get_handle( String className ) {
    
        Integer classHandle = _classNameHandleMap.get( className );
        if ( classHandle == null ) {
            System.err.println( "Bad class name \"" + className + "\" on get_handle." );
            return -1;
        }
        
        return classHandle;        
    }
    
    /**
    * Returns the name of <% if(isinteraction){ %>a parameter<%}else{%>an attribute<%}%> corresponding to
    * its handle (RTI assigned) in datamemberHandle.
    *
    * @param datamemberHandle handle of <% if(isinteraction){ %>parameter<%}else{%>attribute<%}%> (RTI assigned)
    * for which to return the name
    * @return the name of the <% if(isinteraction){ %>parameter<%}else{%>attribute<%}%> corresponding to datamemberHandle
    */
    public static String get_<%= paratt %>_name( int datamemberHandle ) {
        return _datamemberHandleNameMap.get( datamemberHandle );
    }
    
    /**
    * Returns the handle of <% if(isinteraction){ %>a parameter<%}else{%>an attribute<%}%> (RTI assigned) given
    * its <%= intob %> class name and <%= paratt %> name
    *
    * @param className name of <%= intob %> class
    * @param datamemberName name of <%= paratt %>
    * @return the handle (RTI assigned) of the <%= paratt %> "datamemberName" of <%= intob %> class "className"
    */
    public static int get_<%= paratt %>_handle( String className, String datamemberName ) {
    
        Integer datamemberHandle = _datamemberNameHandleMap.get( className + "," + datamemberName );
        if ( datamemberHandle == null ) {
            System.err.println( "Bad <%= paratt %> \"" + datamemberName + "\" for class \"" + className + "\" on get_<%= paratt %>_handle." );
            return -1;
        }
        
        return datamemberHandle;
    }
    private static Class<?>[] pubsubArguments = new Class<?>[] { RTIambassador.class };
    
    
    /**
    * Publishes the <%= intob %> class named by "className" for a federate.
    * This can also be performed by calling the publish( RTIambassador rti )
    * method directly on the <%= intob %> class named by "className" (for
    * example, to publish the <%= IntOb %>Root class in particular,
    * see {@link <%= IntOb %>Root#publish( RTIambassador rti )}).
    *
    * @param className name of <%= intob %> class to be published for the federate
    * @param rti handle to the RTI, usu. obtained through the
    * {@link SynchronizedFederate#getRTI()} call
    */
    public static void publish( String className, RTIambassador rti ) {
        Class<?> rtiClass = _classNameClassMap.get( className );
        if ( rtiClass == null ) {
            System.err.println( "Bad class name \"" + className + "\" on publish." );
            return;
        }
        try {
            Method method = rtiClass.getMethod( "publish", pubsubArguments );
            method.invoke( null, new Object[]{ rti } );
        } catch ( Exception e ) {
            System.err.println( "Exception caught on publish!" );
            e.printStackTrace();
        }
    }

    /**
    * Unpublishes the <%= intob %> class named by "className" for a federate.
    * This can also be performed by calling the unpublish( RTIambassador rti )
    * method directly on the <%= intob %> class named by "className" (for
    * example, to unpublish the <%= IntOb %>Root class in particular,
    * see {@link <%= IntOb %>Root#unpublish( RTIambassador rti )}).
    *
    * @param className name of <%= intob %> class to be unpublished for the federate
    * @param rti handle to the RTI, usu. obtained through the
    * {@link SynchronizedFederate#getRTI()} call
    */
    public static void unpublish( String className, RTIambassador rti ) {
        Class<?> rtiClass = _classNameClassMap.get( className );
        if ( rtiClass == null ) {
            System.err.println( "Bad class name \"" + className + "\" on unpublish." );
            return;
        }
        try {
            Method method = rtiClass.getMethod( "unpublish", pubsubArguments );
            method.invoke( null, new Object[]{ rti } );
        } catch ( Exception e ) {
            System.err.println( "Exception caught on unpublish!" );
            e.printStackTrace();
        }
    }
    
    /**
    * Subscribes federate to the <%= intob %> class names by "className"
    * This can also be performed by calling the subscribe( RTIambassador rti )
    * method directly on the <%= intob %> class named by "className" (for
    * example, to subscribe a federate to the <%= IntOb %>Root class
    * in particular, see {@link <%= IntOb %>Root#subscribe( RTIambassador rti )}).
    *
    * @param className name of <%= intob %> class to which to subscribe the federate
    * @param rti handle to the RTI, usu. obtained through the
    * {@link SynchronizedFederate#getRTI()} call
    */
    public static void subscribe( String className, RTIambassador rti ) {
        Class<?> rtiClass = _classNameClassMap.get( className );
        if ( rtiClass == null ) {
            System.err.println( "Bad class name \"" + className + "\" on subscribe." );
            return;
        }
        try {
            Method method = rtiClass.getMethod( "subscribe", pubsubArguments );
            method.invoke( null, new Object[]{ rti } );
        } catch ( Exception e ) {
            System.err.println( "Exception caught on subscribe!" );
            e.printStackTrace();
        }
    }
    
    /**
    * Unsubscribes federate from the <%= intob %> class names by "className"
    * This can also be performed by calling the unsubscribe( RTIambassador rti )
    * method directly on the <%= intob %> class named by "className" (for
    * example, to unsubscribe a federate to the <%= IntOb %>Root class
    * in particular, see {@link <%= IntOb %>Root#unsubscribe( RTIambassador rti )}).
    *
    * @param className name of <%= intob %> class to which to unsubscribe the federate
    * @param rti handle to the RTI, usu. obtained through the
    * {@link SynchronizedFederate#getRTI()} call
    */
    public static void unsubscribe( String className, RTIambassador rti ) {
        Class<?> rtiClass = _classNameClassMap.get( className );
        try {
            Method method = rtiClass.getMethod( "unsubscribe", pubsubArguments );
            method.invoke( null, new Object[]{ rti } );
        } catch ( Exception e ) {
            System.err.println( "Exception caught on unsubscribe!" );
            e.printStackTrace();
        }
    }

<% if(isinteraction){ %><%}else{%>
    /**
    * Publishes the attribute named by "attributeName" of the object class named
    * by "className" for a federate.  This can also be performed by calling the
    * publish_<attributeName>() method directly on the object class named by
    * "className".
    *
    * Note:  This method only marks the attribute named by "attributeName" for
    * publication.  The attribute doesn't actually get published until the
    * "className" object class, of which it is a member, is (re)published.  See
    * {@link ObjectRoot#publish( String className, RTIambassador RTI )} and
    * {@link ObjectRoot#publish( RTIambassador RTI )} for examples of how to
    * publish the object class.
    * 
    * @param className name of object class for which the attribute named by
    * "attributeName" is to be published
    * @param attributeName name of the attribute to be published
    */
    public static void publish( String className, String attributeName ) {
        try {
            _classNamePublishAttributeNameMap.get( className ).add( attributeName );
        } catch ( Exception e ) {
            System.err.println( "ERROR:  ObjectRoot.publish:  could not publish class \"" + className + "\" \"" + attributeName + "\" attribute." );
            e.printStackTrace();
        }        
    }

    /**
    * Unpublishes the attribute named by "attributeName" of the object class named
    * by "className" for a federate.  This can also be performed by calling the
    * unpublish_<attributeName>() method directly on the object class named by
    * "className".
    *
    * Note:  This method only marks the attribute named by "attributeName" for
    * un-publication. The attribute doesn't actually get unpublished until the
    * "className" object class, of which it is a member, is (re)published.  See
    * {@link ObjectRoot#publish( String className, RTIambassador RTI )} and
    * {@link ObjectRoot#publish( RTIambassador RTI )} for examples of how to
    * publish the object class.
    * 
    * @param className name of object class for which the attribute named by
    * "attributeName" is to be unpublished (by a federate)
    * @param attributeName name of the attribute to be unpublished
    */
    public static void unpublish( String className, String attributeName ) {
        try {
            _classNamePublishAttributeNameMap.get( className ).remove( attributeName );
        } catch ( Exception e ) {
            System.err.println( "ERROR:  ObjectRoot.unpublish:  could not unpublish class \"" + className + "\" \"" + attributeName + "\" attribute." );
            e.printStackTrace();
        }        
    }

    /**
    * Subscribe a federate to the attribute named by "attributeName" of the
    * object class named by "className".  This can also be performed by calling
    * the subscribe_<attributeName>() method directly on the object class named
    * by "className".
    *
    * Note:  This method only marks the attribute named by "attributeName" for
    * subscription.  The attribute doesn't actually get subscribed to until the
    * "className" object class, of which it is a member, is (re)subscribed to.
    * See {@link ObjectRoot#subscribe( String className, RTIambassador RTI )} and
    * {@link ObjectRoot#subscribe( RTIambassador RTI )} for examples of how to
    * subscribe to the object class.
    * 
    * @param className name of object class for which the attribute named by
    * "attributeName" is to be subcribed
    * @param attributeName name of the attribute to be published
    */
    public static void subscribe( String className, String attributeName ) {
        try {
            _classNameSubscribeAttributeNameMap.get( className ).add( attributeName );
        } catch ( Exception e ) {
            System.err.println( "ERROR:  ObjectRoot.subscribe:  could not subscribe to class \"" + className + "\" \"" + attributeName + "\" attribute." );
            e.printStackTrace();
        }        
    }

    /**
    * Unsubscribe a federate from the attribute named by "attributeName" of the
    * object class named by "className".  This can also be performed by calling
    * the unsubscribe_<attributeName>() method directly on the object class named
    * by "className".
    *
    * Note:  This method only marks the attribute named by "attributeName" for
    * unsubscription.  The attribute doesn't actually get unsubscribed from until the
    * "className" object class, of which it is a member, is (re)subscribed to.
    * See {@link ObjectRoot#subscribe( String className, RTIambassador RTI )} and
    * {@link ObjectRoot#subscribe( RTIambassador RTI )} for examples of how to
    * subscribe to the object class.
    * 
    * @param className name of object class for which the attribute named by
    * "attributeName" is to be subcribed
    * @param attributeName name of the attribute to be published
    */
    public static void unsubscribe( String className, String attributeName ) {
        try {
            _classNameSubscribeAttributeNameMap.get( className ).remove( attributeName );
        } catch ( Exception e ) {
            System.err.println( "ERROR:  ObjectRoot.unsubscribe:  could not unsubscribe class \"" + className + "\" \"" + attributeName + "\" attribute." );
            e.printStackTrace();
        }        
    }
<%}%>
    
    private static <%= IntOb %>Root create_<%= intob %>( Class<?> rtiClass ) {
        <%= IntOb %>Root classRoot = null;
        try {
            classRoot = (<%= IntOb %>Root)rtiClass.newInstance();
        } catch( Exception e ) {
            System.err.println( "ERROR:  <%= IntOb %>Root:  create_<%= intob %>:  could not create/cast new <%= IntOb %>" );
            e.printStackTrace();
        }
        
        return classRoot;
    }

    private static <%= IntOb %>Root create_<%= intob %>( Class<?> rtiClass, LogicalTime logicalTime ) {    
        <%= IntOb %>Root classRoot = create_<%= intob %>( rtiClass );
        if ( classRoot != null ) classRoot.setTime( logicalTime );
        return classRoot;
    }

    private static <%= IntOb %>Root create_<%= intob %>( Class<?> rtiClass, <%=isinteraction?"ReceivedInteraction":"ReflectedAttributes"%> datamemberMap ) {
        <%= IntOb %>Root classRoot = create_<%= intob %>( rtiClass );
        classRoot.set<%= ParAtt %>s( datamemberMap );
        return classRoot;
    }
    
    private static <%= IntOb %>Root create_<%= intob %>( Class<?> rtiClass, <%=isinteraction?"ReceivedInteraction":"ReflectedAttributes"%> datamemberMap, LogicalTime logicalTime ) {
        <%= IntOb %>Root classRoot = create_<%= intob %>( rtiClass );
        classRoot.set<%= ParAtt %>s( datamemberMap );
        classRoot.setTime( logicalTime );
        return classRoot;
    }
    
    /**
    * Create an <%= intob %> that is in instance of <%= intob %> class
    * "className". An <%= IntOb %>Root reference is returned,
    * so to refer to the instance using a reference to a "className" interaction,
    * the returned reference must be cast down the <%= intob %> inheritance
    * hierarchy.
    * An instance of the "className" <%= intob %> class may also be created
    * by using the "new" operator directory on the "className" <%= intob %>
    * class.  For instance, two ways to create an <%= IntOb %>Root
    * instance are
    * <%= IntOb %>.create_<%= intob %>( "<%= IntOb %>Root" ),
    * and
    * new <%= IntOb %>Root()
    *
    * @param className fully-qualified (dot-delimited) name of the <%= intob %>
    * class for which to create an instance
    * @return instance of "className" <%= intob %> class
    */
    public static <%= IntOb %>Root create_<%= intob %>( String className ) {
        Class<?> rtiClass = _classNameClassMap.get( className );
        if ( rtiClass == null ) return null;

        return create_<%= intob %>( rtiClass );
    }

    /**
    * Like {@link #create_<%= intob %>( String className )}, but <%= intob %>
    * is created with a timestamp based on "logicalTime".
    *
    * @param className fully-qualified (dot-delimited) name of the <%= intob %>
    * class for which to create an instance
    * @param logicalTime timestamp to place on the new <%= intob %> class instance
    * @return instance of "className" <%= intob %> class with "logicalTime" time stamp.
    */
    public static <%= IntOb %>Root create_<%= intob %>( String className, LogicalTime logicalTime ) {
        Class<?> rtiClass = _classNameClassMap.get( className );
        if ( rtiClass == null ) return null;

        return create_<%= intob %>( rtiClass, logicalTime );
    }

    /**
    * Create an <%= intob %> that is in instance of <%= intob %> class
    * that corresponds to the "classHandle" handle (RTI assigned). An
    * <%= IntOb %>Root reference is returned, so to refer to the
    * instance using a reference to a "className" interaction, the returned
    * reference must be cast down the <%= intob %> inheritance hierarchy.
    *
    * @param classHandle handle of <%= intob %> class (RTI assigned) class for
    * which to create an instance
    * @return instance of <%= intob %> class corresponding to "classHandle"
    */
    public static <%= IntOb %>Root create_<%= intob %>( int classHandle ) {
        Class<?> rtiClass = _classNameClassMap.get(  _classHandleNameMap.get( classHandle )  );
        if ( rtiClass == null ) return null;

        return create_<%= intob %>( rtiClass );
    }

    /**
    * Like {@link #create_<%= intob %>( int classHandle )}, but the <%= intob %>
    * is created with a timestamp based on "logicalTime".
    *
    * @param classHandle handle of <%= intob %> class (RTI assigned) class for
    * which to create an instance
    * @param logicalTime timestamp to place on the new <%= intob %> class instance
    * @return instance of <%= intob %> class corresponding to "classHandle" with
    * "logicalTime" time stamp
    */
    public static <%= IntOb %>Root create_<%= intob %>( int classHandle, LogicalTime logicalTime ) {
        Class<?> rtiClass = _classNameClassMap.get(  _classHandleNameMap.get( classHandle )  );
        if ( rtiClass == null ) return null;

        return create_<%= intob %>( rtiClass, logicalTime );
    }

    /**
    * Like {@link #create_<%= intob %>( int classHandle )}, but the <%= intob %>'s
    * <%= paratt %>s are initialized using "datamemberMap".  The "datamemberMap"
    * is usually acquired as an argument to an RTI callback method of a federate.
    *
    * @param classHandle handle of <%= intob %> class (RTI assigned) class for
    * which to create an instance
    * @param datamemberMap contains initializing values for the <%= paratt %>s
    * of the <%= intob %> class instance
    * @return instance of <%= intob %> class corresponding to "classHandle" with
    * its <%= paratt %>s initialized with the "datamemberMap"
    */
    public static <%= IntOb %>Root create_<%= intob %>( int classHandle, <%=isinteraction?"ReceivedInteraction":"ReflectedAttributes"%> datamemberMap ) {
        Class<?> rtiClass = _classNameClassMap.get(  _classHandleNameMap.get( classHandle )  );
        if ( rtiClass == null ) return null;

        return create_<%= intob %>( rtiClass, datamemberMap );
    }

    /**
    * Like {@link #create_<%= intob %>( int classHandle, <%=isinteraction?"ReceivedInteraction":"ReflectedAttributes"%> datamemberMap )},
    * but the <%= intob %> is given a timestamp based on "logicalTime".
    *
    * @param classHandle handle of <%= intob %> class (RTI assigned) class for
    * which to create an instance
    * @param datamemberMap initializing values for the <%= paratt %>s of the
    * <%= intob %> class instance
    * @param logicalTime timestamp to place on the new <%= intob %> class instance
    * @return instance of <%= intob %> class corresponding to "classHandle" with
    * its <%= paratt %>s initialized with the "datamemberMap" and with
    * "logicalTime" timestamp
    */
    public static <%= IntOb %>Root create_<%= intob %>( int classHandle, <%=isinteraction?"ReceivedInteraction":"ReflectedAttributes"%> datamemberMap, LogicalTime logicalTime ) {
        Class<?> rtiClass = _classNameClassMap.get(  _classHandleNameMap.get( classHandle )  );
        if ( rtiClass == null ) return null;

        return create_<%= intob %>( rtiClass, datamemberMap, logicalTime );
    }

<% if(isinteraction){ %><%}else{%>
    /**
    * Creates a new instance of the object class corresponding to "class_handle",
    * registers it in an map internal to the ObjectRoot class using "object_handle"
    * as a key, and returns a reference to the instance.  Though the created
    * instance is of the object class corresponding to "class_handle" (which is
    * a handle assigned by the RTI), it is referred to, via the return value, by
    * an ObjectRoot reference.  Thus, to refer to it as an instance of the object
    * class corresponding to "class_handle", the ObjectRoot reference needs to be
    * cast down through the inheritance hierarchy.
    * <p/>
    * class_handle and object_handle are usually acquired as arguments of the
    * "discoverObjectInstance" RTI callback method of a federate.
    *
    * @param class_handle handle of object class (RTI assigned) for which to create
    * an instance
    * @param object_handle handle (also RTI assigned) of this instance as it is
    * known to the RTI.  Any updates to the instance attributes provided by the
    * RTI (via a "reflectAttributeValues" federate callback) will be identified
    * with this object_handle.
    * @return new instance of the object class corresponding to class_handle
    */
    public static ObjectRoot discover( int class_handle, int object_handle ) {
        Class<?> hlaObjectClass = _classNameClassMap.get(  _classHandleNameMap.get( class_handle )  );
        ObjectRoot objectRoot = null;
        try {
            objectRoot = (ObjectRoot)hlaObjectClass.newInstance();
            objectRoot.setObjectHandle( object_handle );
            _objectMap.put( object_handle, objectRoot );
        } catch( Exception e ) {
            System.err.println( "ERROR:  ObjectRoot:  discover:  could not discover object" );
            e.printStackTrace();
        }
        return objectRoot;
    }
    
    /**
    * Retrieves the object instance corresponding to "object_handle" from an
    * internal table in the ObjectRoot class, updates its attribute values using
    * "reflectedAttributes", and returns the instance.  Both "object_handle" and
    * "reflectedAttributes" are usually acquired as arguments of the
    * "reflectAttributeValues" RTI callback of a federate.
    * The return value is an ObjectRoot reference to the instance.  So, to refer
    * to the instance as an instance of its actual class, this reference will
    * have to be cast down the inheritance hierarchy.
    *
    * @param object_handle handle (RTI assigned) of object instance for which the
    * attributes are to be updated.
    * @param reflectedAttributes set of updated values for the attributes of the
    * object instance corresponding to object_handle.
    * @return the object instance with updated attribute values
    */
    public static ObjectRoot reflect( int object_handle, ReflectedAttributes reflectedAttributes ) {
        ObjectRoot objectRoot = _objectMap.get( object_handle );
        if ( objectRoot == null ) return null;
        objectRoot.setTime( -1 );
        objectRoot.setAttributes( reflectedAttributes );
        return objectRoot;
    }

    /**
    * Like {@link #reflect( int object_handle, ReflectedAttributes reflectedAttributes )},
    * except the updated attributes of the object instance have their timestamps
    * updated to "logicalTime".
    *
    * @param object_handle handle (RTI assigned) of object instance for which the
    * attributes are to be updated.
    * @param reflectedAttributes set of updated values for the attributes of the
    * object instance corresponding to object_handle.
    * @param logicalTime new time stamp for attributes that are updated
    * @return the object instance with updated attribute values
    */
    public static ObjectRoot reflect( int object_handle, ReflectedAttributes reflectedAttributes, LogicalTime logicalTime ) {
        ObjectRoot objectRoot = _objectMap.get( object_handle );
        if ( objectRoot == null ) return null;
        objectRoot.setTime( logicalTime );
        objectRoot.setAttributes( reflectedAttributes );
        return objectRoot;
    }

    /**
    * Like {@link #reflect( int object_handle, ReflectedAttributes reflectedAttributes )},
    * except the updated attributes of the object instance have their timestamps
    * updated to "time".
    *
    * @param object_handle handle (RTI assigned) of object instance for which the
    * attributes are to be updated.
    * @param reflectedAttributes set of updated values for the attributes of the
    * object instance corresponding to object_handle.
    * @param time new time stamp for attributes that are updated
    * @return the object instance with updated attribute values
    */
    public static ObjectRoot reflect( int object_handle, ReflectedAttributes reflectedAttributes, double time ) {
        ObjectRoot objectRoot = _objectMap.get( object_handle );
        if ( objectRoot == null ) return null;
        objectRoot.setTime( time );
        objectRoot.setAttributes( reflectedAttributes );
        return objectRoot;
    }

    /**
    * Requests an attribute update for this object instance from the federate that
    * has modification rights on these attributes.
    *
    * @param rti handle to the RTI, usu. obtained through the
    * {@link SynchronizedFederate#getRTI()} call
    */
    public void requestUpdate( RTIambassador rti ) {
        boolean requestNotSubmitted = true;
        while( requestNotSubmitted ) {
            try {        
                rti.requestObjectAttributeValueUpdate( getObjectHandle(), getSubscribedAttributeHandleSet() );
                requestNotSubmitted = false;
            } catch ( FederateNotExecutionMember f ) {
                System.err.println( "ERROR: " + getClassName() + "request for update failed:  Federate Not Execution Member" );
                f.printStackTrace();
                return;                
            } catch ( ObjectNotKnown o ) {
                System.err.println( "ERROR: " + getClassName() + "request for update failed:  Object Not Known" );
                o.printStackTrace();
                return;                
            } catch ( AttributeNotDefined a ) {
                System.err.println( "ERROR: " + getClassName() + "request for update failed:  Name Not Found" );
                a.printStackTrace();
                return;                
            } catch ( Exception e ) {
                e.printStackTrace();
                try { Thread.sleep( 50 ); } catch( Exception e1 ) { }                    
            }
        }
    }

    /**
    * Returns the object instance corresponding to the "object_handle" (RTI
    * assigned) from a map internal to the ObjectRoot class.
    * The object instance is referred to, via the return value, using an
    * an ObjectRoot reference.  To reference to it using a reference of its
    * actual class, the returned reference must be cast down through the
    * inhertance hierarchy.
    *
    * @param object_handle handle (RTI assigned) of object instance to retrieve
    * from the map internal to the ObjectRoot class.
    * @return object instance corresponding to the object_handle (RTI assigned)
    * in the map that is internal to the ObjectRoot class.
    */
    public static ObjectRoot getObject( int object_handle ) {
        return _objectMap.get( object_handle );
    }
    
    
    /**
    * Returns the object instance corresponding to the "object_handle" (RTI
    * assigned) from a map internal to the ObjectRoot class AND REMOVES IT
    * FROM THIS MAP.
    * The object instance is referred to, via the return value, using an
    * an ObjectRoot reference.  To reference to it using a reference of its
    * actual class, the returned reference must be cast down through the
    * inhertance hierarchy.
    *
    * @param object_handle handle (RTI assigned) of object instance to retrieve
    * from the map internal to the ObjectRoot class.
    * @return object instance corresponding to the object_handle (RTI assigned)
    * in the map that is internal to the ObjectRoot class.
    */
    public static ObjectRoot removeObject( int object_handle ) {
        return _objectMap.remove( object_handle );
    }
    

    private int _object_handle;

    private void setObjectHandle( int object_handle ) {
        _objectMap.remove( object_handle );
        _object_handle = object_handle;
        _objectMap.put( object_handle, this );
    }

    /**
    * Returns the handle (RTI assigned) the corresponds to this object class
    * instance.  This handle is the instance's unique identifier to the RTI.
    *
    * @return the handle (RTI assigned) of this object class instance.
    */
    public int getObjectHandle() { return _object_handle; }
    
<%}%>

    private double _time = -1;
    
    /**
    * Returns the timestamp for this <%= intob %>.  "receive order" <%= intob %>s
    * should have a timestamp of -1.
    *
    * @return timestamp for this <%= intob %>
    */
    public double getTime() { return _time; }
    
    /**
    * Sets the timestamp of this <%= intob %> to "time".
    *
    * @param time new timestamp for this <%= intob %>
    */
    public void setTime( double time ) { _time = time; }

    /**
    * Sets the timestamp of this <%= intob %> to "logicalTime".
    *
    * @param logicalTime new timestamp for this <%= intob %>
    */
    public void setTime( LogicalTime logicalTime ) {
        DoubleTime doubleTime = new DoubleTime();
        doubleTime.setTo( logicalTime );
        setTime( doubleTime.getTime() );
    }


    /**
    * Creates a new <%= IntOb %>Root instance.
    */
    public <%= IntOb %>Root() {
        _uniqueID = generateUniqueID();
    }
    
    /**
    * Creates a copy of an <%= IntOb %>Root instance.  As an
    * <%= IntOb %>Root instance contains no <%= paratt %>s,
    * this has the same effect as the default constructor.
    */
    public <%= IntOb %>Root( <%= IntOb %>Root <%= intob %>Root ) {
        this();
    }

    protected <%= IntOb %>Root( <%=isinteraction?"ReceivedInteraction":"ReflectedAttributes"%> datamemberMap, boolean initFlag ) {
        this();
        if ( initFlag ) set<%= ParAtt %>s( datamemberMap );
    }
    
    protected <%= IntOb %>Root( <%=isinteraction?"ReceivedInteraction":"ReflectedAttributes"%> datamemberMap, LogicalTime logicalTime, boolean initFlag ) {
        this();
        setTime( logicalTime );
        if ( initFlag ) set<%= ParAtt %>s( datamemberMap );
    }


    /**
    * Creates a new <%= intob %> instance and initializes its <%= paratt %>s
    * using the "datamemberMap" -- this constructor is usually called as a
    * super-class constructor to create and initialize an instance of an
    * <%= intob %> further down in the inheritance hierarchy.  "datamemberMap"
    * is usually acquired as an argument to an RTI federate callback method, such
    * as "receiveInteraction".
    *
    * @param datamemberMap contains <%= paratt %> values for the newly created
    * <%= intob %>
    */
    public <%= IntOb %>Root( <%=isinteraction?"ReceivedInteraction":"ReflectedAttributes"%> datamemberMap ) {
        this( datamemberMap, true );
    }

    /**
    * Like {@link #<%= IntOb %>Root( <%=isinteraction?"ReceivedInteraction":"ReflectedAttributes"%> datamemberMap )},
    * except the new instance has an initial timestamp of "logicalTime".
    *
    * @param datamemberMap contains <%= paratt %> values for the newly created
    * <%= intob %>
    * @param logicalTime initial timestamp for newly created <%= intob %> instance
    */    
    public <%= IntOb %>Root( <%=isinteraction?"ReceivedInteraction":"ReflectedAttributes"%> datamemberMap, LogicalTime logicalTime ) {
        this( datamemberMap, logicalTime, true );
    }

    /**
    * Returns the value of the <%= paratt %> named "datamemberName" for this
    * <%= intob %>.
    *
    * @param datamemberName name of <%= paratt %> whose value to retrieve
    * @return the value of the <%= paratt %> whose name is "datamemberName"
    */
    public Object get<%= ParAtt %>( String datamemberName ) {
        return null;
    }

    /**
    * Returns the value of the <%= paratt %> whose handle is "datamemberHandle"
    * (RTI assigned) for this <%= intob %>.
    *
    * @param datamemberHandle handle (RTI assigned) of <%= paratt %> whose
    * value to retrieve
    * @return the value of the <%= paratt %> whose handle is "datamemberHandle"
    */
    public Object get<%= ParAtt %>( int datamemberHandle ) {
        return null;
    }
        
    /**
    * Set the values of the <%= paratt %>s in this <%= intob %> using
    * "datamemberMap".  "datamemberMap" is usually acquired as an argument to
    * an RTI federate callback method such as "receiveInteraction".
    *
    * @param datamemberMap  contains new values for the <%= paratt %>s of
    * this <%= intob %>
    */
    public void set<%= ParAtt %>s( <%=isinteraction?"ReceivedInteraction":"ReflectedAttributes"%> datamemberMap ) {
        int size = datamemberMap.size();
        for( int ix = 0 ; ix < size ; ++ix ) {
            try {
                set<%= ParAtt %>(  datamemberMap.get<%= ParAtt %>Handle( ix ), datamemberMap.getValue( ix )  );
            } catch ( Exception e ) {
                System.err.println( "set<%= ParAtt %>s: Exception caught!" );
                e.printStackTrace();
            }
        }
    }

    private void set<%= ParAtt %>( int handle, byte[] val ) {
        if ( val == null ) {
            System.err.println( "set:  Attempt to set null value in class \"" + getClass().getName() + "\"" );
        }
        String valAsString = new String( val, 0, val.length );
        if (valAsString != null && valAsString.length() > 0 && valAsString.charAt(valAsString.length() - 1) == '\0') {
            valAsString = valAsString.substring(0, valAsString.length() - 1);
        }
        if (   !set<%= ParAtt %>Aux(  handle, valAsString  )   ) {
            System.err.println( "set:  bad <%= paratt %> handle in class \"" + getClass().getName() + "\"" );
        }
    }
    
    /**
    * Sets the value of the <%= paratt %> named "datamemberName" to "value"
    * in this <%= intob %>.  "value" is converted to data type of "datamemberName"
    * if needed.
    * This action can also be affected by calling the set_<datamemberName>( value )
    * method on the <%= intob %> using a reference to the <%= intob %>'s actual
    * class.
    *
    * @param datamemberName name of <%= paratt %> whose value is to be set
    * to "value"
    * @param value new value of <%= paratt %> called "datamemberName"
    */
    public void set<%= ParAtt %>( String datamemberName, String value ) {
        if (  !set<%= ParAtt %>Aux( datamemberName, value )  ) {
            System.err.println( "Error:  <%= intob %>Root:  invalid <%= paratt %> \"" + datamemberName + "\"" );
        }
    }

    /**
    * Sets the value of the <%= paratt %> named "datamemberName" to "value"
    * in this <%= intob %>.  "value" should have the same data type as that of
    * the "datamemberName" <%= paratt %>.
    * This action can also be affected by calling the set_<datamemberName>( value )
    * method on the <%= intob %> using a reference to the <%= intob %>'s actual
    * class.
    *
    * @param datamemberName name of <%= paratt %> whose value is to be set
    * to "value"
    * @param value new value of <%= paratt %> called "datamemberName"
    */
    public void set<%= ParAtt %>( String datamemberName, Object value ) {
        if (  !set<%= ParAtt %>Aux( datamemberName, value )  ) {
            System.err.println( "Error:  <%= intob %>Root:  invalid <%= paratt %> \"" + datamemberName + "\"" );
        }
    }

    protected boolean set<%= ParAtt %>Aux( int param_handle, String val ) {
        return false;
    }

    protected boolean set<%= ParAtt %>Aux( String datamemberName, String value ) {
        return false;
    }

    protected boolean set<%= ParAtt %>Aux( String datamemberName, Object value ) {
        return false;
    }

    protected Supplied<%= ParAtt %>s createSuppliedDatamembers(<% if(isinteraction){ %><%}else{%>boolean force<%}%>) {
        return _factory.createSupplied<%= ParAtt %>s();
    }
    
<% if(isinteraction){ %>
    /**
    * Sends this interaction to the RTI, with the specified timestamp "time".
    * This method should be used to send interactions that have "timestamp"
    * ordering.
    *
    * @param rti handle to the RTI, usu. obtained through the
    * {@link SynchronizedFederate#getRTI()} call
    * @param time timestamp for this interaction.  The timestamp should be no
    * less than the current federation time + the LOOKAHEAD value of the federate
    * sending this interaction.
    */
    public void sendInteraction( RTIambassador rti, double time ) throws Exception {
        synchronized( rti ) {
            try {
                SuppliedParameters datamembers = createSuppliedDatamembers();
                rti.sendInteraction(  getClassHandle(), datamembers, null, new DoubleTime( time )  );
                createLog(datamembers,time);
            } catch ( Exception e ) {
                System.err.println( "ERROR:  " + getClass().getName() + ":  could not send interaction" );
                e.printStackTrace();
            }
        }
    }

    /**
    * Sends this interaction to the RTI (without a timestamp).
    * This method should be used to send interactions that have "receive"
    * ordering.
    *
    * @param rti handle to the RTI, usu. obtained through the
    * {@link SynchronizedFederate#getRTI()} call
    */
    public void sendInteraction( RTIambassador rti ) throws Exception {
        synchronized( rti ) {
            try {
                SuppliedParameters datamembers = createSuppliedDatamembers();
                rti.sendInteraction( getClassHandle(), datamembers, null );
                createLog(datamembers,0);
            } catch ( Exception e ) {
                System.err.println( "ERROR:  " + getClass().getName() + ":  could not send interaction" );
                e.printStackTrace();
            }
        }
    }
    
    protected static String fedName = null;
    public static Boolean enablePubLog = false;
    public static Boolean enableSubLog = false;
    public static String pubLogLevel = null;
    public static String subLogLevel = null;
    
    public static void enablePublishLog(String interaction, String fed, String thislevel, String globallevel){
        if(globallevel == null || "".equals(globallevel)) return;
        if(C2WLogger.getLogLevel(thislevel)> C2WLogger.getLogLevel(globallevel)) return;
        fedName = fed;
        enablePubLog = true;
        pubLogLevel = thislevel;
        C2WLogger.addLog(interaction, fedName, true);
    }
    
    public static void enableSubscribeLog(String interaction, String fed, String thislevel, String globallevel){
        if(globallevel == null || "".equals(globallevel)) return;
        if(C2WLogger.getLogLevel(thislevel)> C2WLogger.getLogLevel(globallevel)) return;
        fedName = fed;
        enableSubLog = true;
        subLogLevel = thislevel;
        C2WLogger.addLog(interaction, fedName, false);
    }
    
    protected void createLog(final SuppliedParameters datamembers, final double time) {
        if(!enablePubLog) return;
        Thread t = new Thread(new Runnable() {                                                                                 // NOMELD
            public void run() {                                                                                                // NOMELD
                try {
                    String interactionId = fedName != null ? fedName + "_pub_"+ getSimpleClassName() :getSimpleClassName() + "_pub";

                    // First just record the interaction event as a log
                    C2WLogger.addEventLog(time, interactionId);

                    // Now, log detailed simulation data of the interaction
                    String logIdLocal = null;
                    synchronized( <%= IntOb %>Root.class ) {
                        logIdLocal = Integer.toString( logId++ );
                    }

                    int noDatamembers = datamembers.size();
                    if ( noDatamembers == 0 ) {
                        C2WLogger.addLog( interactionId, time, null, null, null, pubLogLevel, logIdLocal );
                    } else {
                        for(int ix =0; ix < datamembers.size();ix++){
                            String parameter = get_parameter_name(datamembers.getHandle( ix ) );
                            String value = new String(datamembers.getValue(ix));    
                            String type = new String(_datamemberTypeMap.get(parameter));
                            C2WLogger.addLog( interactionId, time, parameter, value, type, pubLogLevel, logIdLocal );
                        }
                    }
                } catch ( Exception e ) {
                    System.err.println( "ERROR:  " + getClass().getName() + ":  could not send interaction" );
                    e.printStackTrace();
                }
            }
        });
        t.start();
    }

<%}else{%>
    private boolean _isRegistered = false;

    /**
    * Registers this object with the RTI.  This method is usually called by a
    * federate who "owns" this object, i.e. the federate that created it and
    * has write-privileges to its attributes (so, it is responsible for updating
    * these attribute and conveying their updated values to the RTI).
    *
    * @param rti handle to the RTI, usu. obtained through the
    * {@link SynchronizedFederate#getRTI()} call
    */ 
    public void registerObject( RTIambassador rti ) {
        
        while( !_isRegistered ) {
            try {
                synchronized( rti ) {
                    _object_handle = rti.registerObjectInstance( getClassHandle() );
                }
                _isRegistered = true;
                _objectMap.put( getObjectHandle(), this );
                
            } catch ( ObjectClassNotDefined o ) {
                o.printStackTrace();
                return;
            } catch ( ObjectClassNotPublished o ) {
                o.printStackTrace();
                return;
            } catch ( FederateNotExecutionMember f ) {
                f.printStackTrace();
                return;
            } catch ( Exception e ) {
                try {
                    Thread.sleep( 500 );
                } catch ( InterruptedException e1 ) {
                    e1.printStackTrace();
                } 
            }
        }

    }
    
    /**
    * Unregisters this object with the RTI.  The RTI will destroy all information
    * it contains regarding this object as a result.  This method is usually
    * called by a federate who "owns" this object, i.e. the federate that created
    * it and has write-privileges to its attributes.
    *
    * @param rti handle to the RTI, usu. obtained through the
    * {@link SynchronizedFederate#getRTI()} call
    */ 
    public void unregisterObject( RTIambassador rti ) {
        
        while( _isRegistered ) {
            try {
                synchronized( rti ) {
                    rti.deleteObjectInstance( _object_handle, null );
                }
                _isRegistered = false;
                _objectMap.remove( getObjectHandle() );
                
            } catch ( ObjectNotKnown o ) {
                o.printStackTrace();
                return;
            } catch ( DeletePrivilegeNotHeld d ) {
                d.printStackTrace();
                return;
            } catch ( FederateNotExecutionMember f ) {
                f.printStackTrace();
                return;
            } catch ( Exception e ) {
                try {
                    Thread.sleep( 500 );
                } catch ( InterruptedException e1 ) {
                    e1.printStackTrace();
                } 
            }
        }
    }

    /**
    * Broadcasts the attributes of this object and their values to the RTI, where
    * the values have "time" as their timestamp.  This call should be used for
    * objects whose attributes have "timestamp" ordering.
    *
    * @param rti handle to the RTI, usu. obtained through the
    * {@link SynchronizedFederate#getRTI()} call
    * @param time timestamp on attribute values of this object
    * @param force if "false", only the attributes whose values have changed since
    * the last call to "updateAttributeValues" will be broadcast to the RTI.  If
    * "true", all attributes and their values are broadcast to the RTI.
    */
    public void updateAttributeValues( RTIambassador rti, double time, boolean force ) {

        SuppliedAttributes suppliedAttributes = createSuppliedDatamembers( force );
        if ( suppliedAttributes.size() == 0 ) return;

        synchronized( rti ) {
            try {
                rti.updateAttributeValues(  getObjectHandle(), suppliedAttributes, null, new DoubleTime( time )  );
                createLog(suppliedAttributes, time);
            } catch ( ObjectNotKnown o ) {
                System.err.println( "ERROR:  " + getClass().getName() + ":  could not update attributes:  Object Not Known" );
                o.printStackTrace();
                return;
            } catch ( FederateNotExecutionMember f ) {
                System.err.println( "ERROR:  " + getClass().getName() + ":  could not update attributes:  Federate Not Execution Member" );
                f.printStackTrace();
                return;
            } catch ( AttributeNotDefined a ) {
                System.err.println( "ERROR:  " + getClass().getName() + ":  could not update attributes:  Attribute Not Defined" );
                a.printStackTrace();
                return;
            } catch ( AttributeNotOwned a ) {
                System.err.println( "ERROR:  " + getClass().getName() + ":  could not update attributes:  Attribute Not Owned" );
                a.printStackTrace();
                return;
            } catch ( ConcurrentAccessAttempted c ) {
                System.err.println( "ERROR:  " + getClass().getName() + ":  could not update attributes:  Concurrent Access Attempted" );
                c.printStackTrace();
                return;
            } catch ( InvalidFederationTime i ) {
                System.err.println( "ERROR:  " + getClass().getName() + ":  could not update attributes:  Invalid Federation Time" );
                i.printStackTrace();
                return;
            } catch ( Exception e ) {
                System.err.println( "ERROR:  " + getClass().getName() + ":  could not update attributes" );
                e.printStackTrace();
            }
        }
    }

    /**
    * Like {@link #updateAttributeValues( RTIambassador rti, double time, boolean force )},
    * except "force" is always false.
    *
    * @param rti handle to the RTI, usu. obtained through the
    * {@link SynchronizedFederate#getRTI()} call
    * @param time timestamp on attribute values of this object
    */
    public void updateAttributeValues( RTIambassador rti, double time ) {
        updateAttributeValues( rti, time, false );
    }

    /**
    * Broadcasts the attributes of this object and their values to the RTI (with
    * no timestamp).  This call should be used for objects whose attributes have
    * "receive" ordering.
    *
    * @param rti handle to the RTI, usu. obtained through the
    * {@link SynchronizedFederate#getRTI()} call
    * @param force if "false", only the attributes whose values have changed since
    * the last call to "updateAttributeValues" will be broadcast to the RTI.  If
    * "true", all attributes and their values are broadcast to the RTI.
    */
    public void updateAttributeValues( RTIambassador rti, boolean force ) {

        SuppliedAttributes suppliedAttributes = createSuppliedDatamembers( force );
        if ( suppliedAttributes.size() == 0 ) return;

        synchronized( rti ) {
            try {
                rti.updateAttributeValues( getObjectHandle(), suppliedAttributes, null );
                createLog(suppliedAttributes, 0);
            } catch ( ObjectNotKnown o ) {
                System.err.println( "ERROR:  " + getClass().getName() + ":  could not update attributes:  Object Not Known" );
                o.printStackTrace();
                return;
            } catch ( FederateNotExecutionMember f ) {
                System.err.println( "ERROR:  " + getClass().getName() + ":  could not update attributes:  Federate Not Execution Member" );
                f.printStackTrace();
                return;
            } catch ( AttributeNotDefined a ) {
                System.err.println( "ERROR:  " + getClass().getName() + ":  could not update attributes:  Attribute Not Defined" );
                a.printStackTrace();
                return;
            } catch ( AttributeNotOwned a ) {
                System.err.println( "ERROR:  " + getClass().getName() + ":  could not update attributes:  Attribute Not Owned" );
                a.printStackTrace();
                return;
            } catch ( ConcurrentAccessAttempted c ) {
                System.err.println( "ERROR:  " + getClass().getName() + ":  could not update attributes:  Concurrent Access Attempted" );
                c.printStackTrace();
                return;
            } catch ( Exception e ) {
                System.err.println( "ERROR:  " + getClass().getName() + ":  could not update attributes" );
                e.printStackTrace();
            }
        }
    }

    /**
    * Like {@link #updateAttributeValues( RTIambassador rti, boolean force )},
    * except "force" is always false.
    *
    * @param rti handle to the RTI, usu. obtained through the
    * {@link SynchronizedFederate#getRTI()} call
    */
    public void updateAttributeValues( RTIambassador rti ) {
        updateAttributeValues( rti, false );
    }

    protected static String _fedName = null;
    protected static Map< String, String > _pubAttributeLogMap = new HashMap< String, String >();
    protected static Map< String, String > _subAttributeLogMap = new HashMap< String, String >();
    
    public static void enablePublishLog(String object, String attribute, String fed, String thislevel, String globallevel){
        if(globallevel == null || "".equals(globallevel)) return;
        if(C2WLogger.getLogLevel(thislevel)> C2WLogger.getLogLevel(globallevel)) return;
        _fedName = fed;
        _pubAttributeLogMap.put(attribute, thislevel);
        C2WLogger.addLog(object, attribute, fed, true);
    }
    
    public static void enableSubscribeLog(String object, String attribute, String fed, String thislevel, String globallevel){
        if(globallevel == null || "".equals(globallevel)) return;
        if(C2WLogger.getLogLevel(thislevel)> C2WLogger.getLogLevel(globallevel)) return;
        _fedName = fed;
        _subAttributeLogMap.put(attribute, thislevel);
        C2WLogger.addLog(object, attribute, fed, true);
    }
    
    protected void createLog(final SuppliedAttributes suppliedAttributes, final double time) {
        if(_pubAttributeLogMap.isEmpty()) return;
        Thread t = new Thread(new Runnable() {                                                       // NOMELD
            public void run() {                                                                      // NOMELD
                try {
                    String eventName = _fedName+"_pub_"+getSimpleClassName();

                    // First just record the interaction event as a log
                    C2WLogger.addEventLog(time, eventName);

                    // Now, log detailed simulation data of the object update
                    String logIdLocal = null;
                    synchronized( <%= IntOb %>Root.class ) {
                        logIdLocal = Integer.toString( logId++ );
                    }
                    for(int ix =0; ix < suppliedAttributes.size();ix++){                            
                        String attribute = get_attribute_name(suppliedAttributes.getHandle( ix ) );            
                        if(!_pubAttributeLogMap.containsKey(attribute)) continue;
                        String id = _fedName+"_pub_"+getSimpleClassName()+"_"+attribute;
                        String value = new String(suppliedAttributes.getValue(ix));    
                        String type = new String(_datamemberTypeMap.get(attribute));
                        String loglevel = _pubAttributeLogMap.get(attribute);
                        C2WLogger.addLog( id, time, attribute, value, type, loglevel, logIdLocal );                
                    }
                } catch ( Exception e ) {
                    System.err.println( "ERROR:  " + getClass().getName() + ":  could not send interaction" );
                    e.printStackTrace();
                }
            }
        });
        t.start();
    }
    
<%}%>

    /**
    * For use with the melding API -- this method is used to cast
    * <%= IntOb %>Root instance reference into the
    * <%= IntOb %>RootInterface interface.
    *
    * @param rootInstance <%= IntOb %>Root instance reference to be
    * cast into the <%= IntOb %>RootInterface interface
    * @return <%= IntOb %>RootInterface reference to the instance
    */
    public <%= IntOb %>RootInterface cast( <%= IntOb %>Root rootInstance ) {
        return rootInstance;
    }        

    /**
    * For use with the melding API -- this method creates a new
    * <%= IntOb %>Root instance and returns a
    * <%= IntOb %>RootInterface reference to it.
    *
    * @return <%= IntOb %>RootInterface reference to a newly created
    * <%= IntOb %>Root instance
    */
    public <%= IntOb %>RootInterface create() {
        return new <%= IntOb %>Root();
    }        

    public void copyFrom( Object object ) { }
}
