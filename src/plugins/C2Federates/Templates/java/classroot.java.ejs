<%/* THIS IS THE ROOT CLASS OF EITHER THE INTERACTION OR OBJECT-CLASS HEIRARCHY (I.E. "InteractionRoot" OR "ObjectRoot") */%>
<%/*classroot(isinteraction)*/%>
// This code has been generated by the C2W code generator.
// Do not edit manually!

/*
 * Copyright (c) 2016, Institute for Software Integrated Systems, Vanderbilt University
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without written agreement is
 * hereby granted, provided that the above copyright notice, the following
 * two paragraphs and the author appear in all copies of this software.
 *
 * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
 * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT
 * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 *
 */

package org.cpswt.hla;

import hla.rti.*;
import hla.rti.jlc.RtiFactory;
import hla.rti.jlc.RtiFactoryFactory;

import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
<% if(isinteraction){%>import java.util.concurrent.LinkedBlockingQueue;<%}%>

import org.portico.impl.hla13.types.DoubleTime;

/**
 * <%=isinteraction?"Interaction":"Object"%>Root is the base class for all <%=isinteraction?"interaction":"object"%>s
 * defined in a given federation.  As such, an <%=isinteraction?"Interaction":"Object"%>Root
 * variable may refer to any type of interaction defined in the
 * federation.
 * <p/>
 * This <%=isinteraction?"Interaction":"Object"%>Root class provides the following:
 * - methods for constructing any <%=isinteraction?"interaction":"object"%> in the federation, either from
 * data provided by the RTI (for example, see
 * {@link #create_<%=isinteraction?"interaction":"object"%>( int classHandle )} or from a string argument
 * specifying the name of <%=isinteraction?"interaction":"object"%> to construct (see
 * {@link #create_<%=isinteraction?"interaction":"object"%>( String className )}.
 * - methods for sending <% if(isinteraction){ %>an interaction<%}else{%>object updates<%}%> to the RTI (see
 * {@link <% if(isinteraction){ %>#sendInteraction( RTIambassador rti )<%}else{%>#updateAttributeValues( RTIambassador rti )<%}%>} for an example).
 * - methods for publishing/subscribing to any <% if(isinteraction){ %>interaction<%}else{%>object/object attribute<%}%> 
 * defined in the federation (see
 * {@link #publish( String className, RTIambassador rti )} for example).
 * - methods for getting/setting any <%=isinteraction?"parameter":"attribute"%> in the <%=isinteraction?"interaction":"object"%> to
 * which a given <%=isinteraction?"Interaction":"Object"%>Root variable is referring
 * (see {@link #get<%=isinteraction?"Parameter":"Attribute"%>( String datamemberName )} and
 * {@link #set<%=isinteraction?"Parameter":"Attribute"%>( String datamemberName, Object value )}
 */
public class <%=isinteraction?"Interaction":"Object"%>Root implements <%=isinteraction?"Interaction":"Object"%>RootInterface {

	private static int logId = 0;
	private static int _globalUniqueID = 0;
	
	private static int generateUniqueID() {
		return _globalUniqueID++;
	}
	
	private int _uniqueID;
	
	public int getUniqueID() { return _uniqueID; }
	
	protected static RtiFactory _factory;
	static {
		boolean factoryNotAcquired = true;
		while( factoryNotAcquired ) {
			try {
				_factory = RtiFactoryFactory.getRtiFactory( "org.portico.dlc.HLA13RTIFactory" );
				factoryNotAcquired = false;
			} catch ( Exception e ) {
				System.err.println( "ERROR: acquiring factory" );
				e.printStackTrace();
				try { Thread.sleep( 100 ); } catch ( Exception e1 ) { }
			}
		}
	}

	protected static Set< String > _classNameSet = new HashSet< String >();
	protected static Map< String, Class<?> > _classNameClassMap = new HashMap< String, Class<?> >();
	protected static Map<  String, Set< String >  > _datamemberClassNameSetMap = new HashMap<  String, Set< String >  >();
	protected static Map<  String, Set< String >  > _allDatamemberClassNameSetMap = new HashMap<  String, Set< String >  >();

	protected static Map< String, Integer > _classNameHandleMap = new HashMap< String, Integer >();
	protected static Map< Integer, String > _classHandleNameMap = new HashMap< Integer, String >();
	protected static Map< Integer, String > _classHandleSimpleNameMap = new HashMap< Integer, String >();
	
	protected static Map< String, Integer > _datamemberNameHandleMap = new HashMap< String, Integer >();
	protected static Map< Integer, String > _datamemberHandleNameMap = new HashMap< Integer, String >();
	protected static Map< String, String > _datamemberTypeMap = new HashMap< String, String >();

<% if(isinteraction){ %><%}else{%>
	protected static Map<  String, Set< String >  > _classNamePublishAttributeNameMap = new HashMap<  String, Set< String >  >();
	protected static Map<  String, Set< String >  > _classNameSubscribeAttributeNameMap = new HashMap<  String, Set< String >  >();

	protected static Map< String, AttributeHandleSet > _classNamePublishedAttributeMap = new HashMap< String, AttributeHandleSet >();
	protected static Map< String, AttributeHandleSet > _classNameSubscribedAttributeMap = new HashMap< String, AttributeHandleSet >();
	
    private static Map< Integer, ObjectRoot > _objectMap = new HashMap< Integer, ObjectRoot >();

	protected static class Attribute<T> {                                                                                 // NOMELD
		private T _value = null;                                                                                           // NOMELD
		private T _oldValue = null;                                                                                        // NOMELD
		private boolean _oldValueInit = false;                                                                             // NOMELD
		private double _time = 0;                                                                                          // NOMELD
                                                                                                                           // NOMELD
		public Attribute( T init ) {                                                                                       // NOMELD
			_value = init;                                                                                                 // NOMELD
		}                                                                                                                  // NOMELD
		                                                                                                                   // NOMELD
		public T getValue() { return _value; }                                                                             // NOMELD
		public void setValue( T value ) {                                                                                  // NOMELD
			if ( value == null ) return;                                                                                   // NOMELD
			_value = value;                                                                                                // NOMELD
		}                                                                                                                  // NOMELD
		                                                                                                                   // NOMELD
		public double getTime() { return _time; }                                                                          // NOMELD
		public void setTime( double time ) { _time = time; }                                                               // NOMELD
		                                                                                                                   // NOMELD
		public void setHasBeenUpdated() {                                                                                  // NOMELD
			_oldValue = _value;                                                                                            // NOMELD
			_oldValueInit = true;                                                                                          // NOMELD
		}                                                                                                                  // NOMELD
		                                                                                                                   // NOMELD
		public boolean shouldBeUpdated( boolean force ) { return force || !_oldValueInit || !_oldValue.equals( _value ); } // NOMELD		
	}                                                                                                                      // NOMELD
<%}%>	
	
	<% /*classcommon(classname=%=isinteraction?"Interaction":"Object"%+"Root",hlaclassname=%=isinteraction?"Interaction":"Object"%+"Root",...)*/ %>
	<%- ejs.render(TEMPLATES["java/classcommon.java.ejs"],
		{
			isinteraction: isinteraction,
			classname: isinteraction?"InteractionRoot":"ObjectRoot",
			parentclassname: "",
			hlaclassname: isinteraction?"InteractionRoot":"ObjectRoot",
			datamembers: [],
			alldatamembers: []
	}) %>
	/**
	* Returns a set of strings containing the names of all of the <%=isinteraction?"interaction":"object"%>
	* classes in the current federation.
	*
	* @return Set< String > containing the names of all <%=isinteraction?"interaction":"object"%> classes
	* in the current federation
	*/
	public static Set< String > get_<%=isinteraction?"interaction":"object"%>_names() { return new HashSet< String >( _classNameSet ); }

	/**
	* Returns a set of strings containing the names of all of the non-hidden <%=isinteraction?"parameter":"attribute"%>s
	* in the <%=isinteraction?"interaction":"object"%> class specified by className.
	*
	* @param className name of <%=isinteraction?"interaction":"object"%> class for which to retrieve the
	* names of all of its <%=isinteraction?"parameter":"attribute"%>s
	* @return Set< String > containing the names of all <%=isinteraction?"parameter":"attribute"%>s in the
	* className <%=isinteraction?"interaction":"object"%> class
	*/
	public static Set< String > get_<%=isinteraction?"parameter":"attribute"%>_names( String className ) {
		return new HashSet< String >(  _datamemberClassNameSetMap.get( className )  );
	}
	
	/**
	* Returns a set of strings containing the names of all of the <%=isinteraction?"parameter":"attribute"%>s
	* in the <%=isinteraction?"interaction":"object"%> class specified by className.
	*
	* @param className name of <%=isinteraction?"interaction":"object"%> class for which to retrieve the
	* names of all of its <%=isinteraction?"parameter":"attribute"%>s
	* @return Set< String > containing the names of all <%=isinteraction?"parameter":"attribute"%>s in the
	* className <%=isinteraction?"interaction":"object"%> class
	*/
	public static Set< String > get_all_<%=isinteraction?"parameter":"attribute"%>_names( String className ) {
		return new HashSet< String >(  _allDatamemberClassNameSetMap.get( className )  );
	}
	
	/**
	* Returns the fully-qualified name of the <%=isinteraction?"interaction":"object"%> class corresponding
	* to the RTI-defined classHandle.
	*
	* @param classHandle handle (defined by RTI) of <%=isinteraction?"interaction":"object"%> class for
	* which to retrieve the fully-qualified name
	* @return the fully-qualified name of the <%=isinteraction?"interaction":"object"%> class that
	* corresponds to the RTI-defined classHandle
	*/
	public static String get_class_name( int classHandle ) {
		return _classHandleNameMap.get( classHandle );
	}

	/**
	* Returns the simple name of the <%=isinteraction?"interaction":"object"%> class corresponding to the
	* RTI-defined classHandle.  The simple name of an <%=isinteraction?"interaction":"object"%> class is
	* the last name in its (dot-delimited) fully-qualified name.
	*
	* @param classHandle handle (defined by RTI) of <%=isinteraction?"interaction":"object"%> class for which
	* to retrieve the simple name
	* @return the simple name of the <%=isinteraction?"interaction":"object"%> class that corresponds to
	* the RTI-defined classHandle
	*/
	public static String get_simple_class_name( int classHandle ) {
		return _classHandleSimpleNameMap.get( classHandle );
	}
	
	/**
	* Returns the integer handle (RTI defined) of the <%=isinteraction?"interaction":"object"%> class
	* corresponding to the fully-qualified <%=isinteraction?"interaction":"object"%> class name in className.
	*
	* @param className fully-qualified name of <%=isinteraction?"interaction":"object"%> class for which to
	* retrieve the RTI-defined integer handle
	* @return the RTI-defined handle of the <%=isinteraction?"interaction":"object"%> class
	*/
	public static int get_handle( String className ) {
	
		Integer classHandle = _classNameHandleMap.get( className );
		if ( classHandle == null ) {
			System.err.println( "Bad class name \"" + className + "\" on get_handle." );
			return -1;
		}
		
		return classHandle;		
	}
	
	/**
	* Returns the name of <% if(isinteraction){ %>a parameter<%}else{%>an attribute<%}%> corresponding to
	* its handle (RTI assigned) in datamemberHandle.
	*
	* @param datamemberHandle handle of <% if(isinteraction){ %>parameter<%}else{%>attribute<%}%> (RTI assigned)
	* for which to return the name
	* @return the name of the <% if(isinteraction){ %>parameter<%}else{%>attribute<%}%> corresponding to datamemberHandle
	*/
	public static String get_<%=isinteraction?"parameter":"attribute"%>_name( int datamemberHandle ) {
		return _datamemberHandleNameMap.get( datamemberHandle );
	}
	
	/**
	* Returns the handle of <% if(isinteraction){ %>a parameter<%}else{%>an attribute<%}%> (RTI assigned) given
	* its <%=isinteraction?"interaction":"object"%> class name and <%=isinteraction?"parameter":"attribute"%> name
	*
	* @param className name of <%=isinteraction?"interaction":"object"%> class
	* @param datamemberName name of <%=isinteraction?"parameter":"attribute"%>
	* @return the handle (RTI assigned) of the <%=isinteraction?"parameter":"attribute"%> "datamemberName" of <%=isinteraction?"interaction":"object"%> class "className"
	*/
	public static int get_<%=isinteraction?"parameter":"attribute"%>_handle( String className, String datamemberName ) {
	
		Integer datamemberHandle = _datamemberNameHandleMap.get( className + "," + datamemberName );
		if ( datamemberHandle == null ) {
			System.err.println( "Bad <%=isinteraction?"parameter":"attribute"%> \"" + datamemberName + "\" for class \"" + className + "\" on get_<%=isinteraction?"parameter":"attribute"%>_handle." );
			return -1;
		}
		
		return datamemberHandle;		
	}
	
	private static Class<?>[] pubsubArguments = new Class<?>[] { RTIambassador.class };
	
	
	/**
	* Publishes the <%=isinteraction?"interaction":"object"%> class named by "className" for a federate.
	* This can also be performed by calling the publish( RTIambassador rti )
	* method directly on the <%=isinteraction?"interaction":"object"%> class named by "className" (for
	* example, to publish the <%=isinteraction?"Interaction":"Object"%>Root class in particular,
	* see {@link <%=isinteraction?"Interaction":"Object"%>Root#publish( RTIambassador rti )}).
	*
	* @param className name of <%=isinteraction?"interaction":"object"%> class to be published for the federate
	* @param rti handle to the RTI, usu. obtained through the
	* {@link SynchronizedFederate#getRTI()} call
	*/
	public static void publish( String className, RTIambassador rti ) {
		Class<?> rtiClass = _classNameClassMap.get( className );
		if ( rtiClass == null ) {
			System.err.println( "Bad class name \"" + className + "\" on publish." );
			return;
		}
		try {
			Method method = rtiClass.getMethod( "publish", pubsubArguments );
			method.invoke( null, new Object[]{ rti } );
		} catch ( Exception e ) {
			System.err.println( "Exception caught on publish!" );
			e.printStackTrace();
		}
	}

	/**
	* Unpublishes the <%=isinteraction?"interaction":"object"%> class named by "className" for a federate.
	* This can also be performed by calling the unpublish( RTIambassador rti )
	* method directly on the <%=isinteraction?"interaction":"object"%> class named by "className" (for
	* example, to unpublish the <%=isinteraction?"Interaction":"Object"%>Root class in particular,
	* see {@link <%=isinteraction?"Interaction":"Object"%>Root#unpublish( RTIambassador rti )}).
	*
	* @param className name of <%=isinteraction?"interaction":"object"%> class to be unpublished for the federate
	* @param rti handle to the RTI, usu. obtained through the
	* {@link SynchronizedFederate#getRTI()} call
	*/
	public static void unpublish( String className, RTIambassador rti ) {
		Class<?> rtiClass = _classNameClassMap.get( className );
		if ( rtiClass == null ) {
			System.err.println( "Bad class name \"" + className + "\" on unpublish." );
			return;
		}
		try {
			Method method = rtiClass.getMethod( "unpublish", pubsubArguments );
			method.invoke( null, new Object[]{ rti } );
		} catch ( Exception e ) {
			System.err.println( "Exception caught on unpublish!" );
			e.printStackTrace();
		}
	}
	
	/**
	* Subscribes federate to the <%=isinteraction?"interaction":"object"%> class names by "className"
	* This can also be performed by calling the subscribe( RTIambassador rti )
	* method directly on the <%=isinteraction?"interaction":"object"%> class named by "className" (for
	* example, to subscribe a federate to the <%=isinteraction?"Interaction":"Object"%>Root class
	* in particular, see {@link <%=isinteraction?"Interaction":"Object"%>Root#subscribe( RTIambassador rti )}).
	*
	* @param className name of <%=isinteraction?"interaction":"object"%> class to which to subscribe the federate
	* @param rti handle to the RTI, usu. obtained through the
	* {@link SynchronizedFederate#getRTI()} call
	*/
	public static void subscribe( String className, RTIambassador rti ) {
		Class<?> rtiClass = _classNameClassMap.get( className );
		if ( rtiClass == null ) {
			System.err.println( "Bad class name \"" + className + "\" on subscribe." );
			return;
		}
		try {
			Method method = rtiClass.getMethod( "subscribe", pubsubArguments );
			method.invoke( null, new Object[]{ rti } );
		} catch ( Exception e ) {
			System.err.println( "Exception caught on subscribe!" );
			e.printStackTrace();
		}
	}
	
	/**
	* Unsubscribes federate from the <%=isinteraction?"interaction":"object"%> class names by "className"
	* This can also be performed by calling the unsubscribe( RTIambassador rti )
	* method directly on the <%=isinteraction?"interaction":"object"%> class named by "className" (for
	* example, to unsubscribe a federate to the <%=isinteraction?"Interaction":"Object"%>Root class
	* in particular, see {@link <%=isinteraction?"Interaction":"Object"%>Root#unsubscribe( RTIambassador rti )}).
	*
	* @param className name of <%=isinteraction?"interaction":"object"%> class to which to unsubscribe the federate
	* @param rti handle to the RTI, usu. obtained through the
	* {@link SynchronizedFederate#getRTI()} call
	*/
	public static void unsubscribe( String className, RTIambassador rti ) {
		Class<?> rtiClass = _classNameClassMap.get( className );
		try {
			Method method = rtiClass.getMethod( "unsubscribe", pubsubArguments );
			method.invoke( null, new Object[]{ rti } );
		} catch ( Exception e ) {
			System.err.println( "Exception caught on unsubscribe!" );
			e.printStackTrace();
		}
	}

<% if(isinteraction){ %><%}else{%>
	/**
	* Publishes the attribute named by "attributeName" of the object class named
	* by "className" for a federate.  This can also be performed by calling the
	* publish_<attributeName>() method directly on the object class named by
	* "className".
	*
	* Note:  This method only marks the attribute named by "attributeName" for
	* publication.  The attribute doesn't actually get published until the
	* "className" object class, of which it is a member, is (re)published.  See
	* {@link ObjectRoot#publish( String className, RTIambassador RTI )} and
	* {@link ObjectRoot#publish( RTIambassador RTI )} for examples of how to
	* publish the object class.
	* 
	* @param className name of object class for which the attribute named by
	* "attributeName" is to be published
	* @param attributeName name of the attribute to be published
	*/
	public static void publish( String className, String attributeName ) {
		try {
			_classNamePublishAttributeNameMap.get( className ).add( attributeName );
		} catch ( Exception e ) {
			System.err.println( "ERROR:  ObjectRoot.publish:  could not publish class \"" + className + "\" \"" + attributeName + "\" attribute." );
			e.printStackTrace();
		}		
	}

	/**
	* Unpublishes the attribute named by "attributeName" of the object class named
	* by "className" for a federate.  This can also be performed by calling the
	* unpublish_<attributeName>() method directly on the object class named by
	* "className".
	*
	* Note:  This method only marks the attribute named by "attributeName" for
	* un-publication. The attribute doesn't actually get unpublished until the
	* "className" object class, of which it is a member, is (re)published.  See
	* {@link ObjectRoot#publish( String className, RTIambassador RTI )} and
	* {@link ObjectRoot#publish( RTIambassador RTI )} for examples of how to
	* publish the object class.
	* 
	* @param className name of object class for which the attribute named by
	* "attributeName" is to be unpublished (by a federate)
	* @param attributeName name of the attribute to be unpublished
	*/
	public static void unpublish( String className, String attributeName ) {
		try {
			_classNamePublishAttributeNameMap.get( className ).remove( attributeName );
		} catch ( Exception e ) {
			System.err.println( "ERROR:  ObjectRoot.unpublish:  could not unpublish class \"" + className + "\" \"" + attributeName + "\" attribute." );
			e.printStackTrace();
		}		
	}

	/**
	* Subscribe a federate to the attribute named by "attributeName" of the
	* object class named by "className".  This can also be performed by calling
	* the subscribe_<attributeName>() method directly on the object class named
	* by "className".
	*
	* Note:  This method only marks the attribute named by "attributeName" for
	* subscription.  The attribute doesn't actually get subscribed to until the
	* "className" object class, of which it is a member, is (re)subscribed to.
	* See {@link ObjectRoot#subscribe( String className, RTIambassador RTI )} and
	* {@link ObjectRoot#subscribe( RTIambassador RTI )} for examples of how to
	* subscribe to the object class.
	* 
	* @param className name of object class for which the attribute named by
	* "attributeName" is to be subcribed
	* @param attributeName name of the attribute to be published
	*/
	public static void subscribe( String className, String attributeName ) {
		try {
			_classNameSubscribeAttributeNameMap.get( className ).add( attributeName );
		} catch ( Exception e ) {
			System.err.println( "ERROR:  ObjectRoot.subscribe:  could not subscribe to class \"" + className + "\" \"" + attributeName + "\" attribute." );
			e.printStackTrace();
		}		
	}

	/**
	* Unsubscribe a federate from the attribute named by "attributeName" of the
	* object class named by "className".  This can also be performed by calling
	* the unsubscribe_<attributeName>() method directly on the object class named
	* by "className".
	*
	* Note:  This method only marks the attribute named by "attributeName" for
	* unsubscription.  The attribute doesn't actually get unsubscribed from until the
	* "className" object class, of which it is a member, is (re)subscribed to.
	* See {@link ObjectRoot#subscribe( String className, RTIambassador RTI )} and
	* {@link ObjectRoot#subscribe( RTIambassador RTI )} for examples of how to
	* subscribe to the object class.
	* 
	* @param className name of object class for which the attribute named by
	* "attributeName" is to be subcribed
	* @param attributeName name of the attribute to be published
	*/
	public static void unsubscribe( String className, String attributeName ) {
		try {
			_classNameSubscribeAttributeNameMap.get( className ).remove( attributeName );
		} catch ( Exception e ) {
			System.err.println( "ERROR:  ObjectRoot.unsubscribe:  could not unsubscribe class \"" + className + "\" \"" + attributeName + "\" attribute." );
			e.printStackTrace();
		}		
	}
<%}%>
	
	private static <%=isinteraction?"Interaction":"Object"%>Root create_<%=isinteraction?"interaction":"object"%>( Class<?> rtiClass ) {
		<%=isinteraction?"Interaction":"Object"%>Root classRoot = null;
		try {
			classRoot = (<%=isinteraction?"Interaction":"Object"%>Root)rtiClass.newInstance();
		} catch( Exception e ) {
			System.err.println( "ERROR:  <%=isinteraction?"Interaction":"Object"%>Root:  create_<%=isinteraction?"interaction":"object"%>:  could not create/cast new <%=isinteraction?"Interaction":"Object"%>" );
			e.printStackTrace();
		}
		
		return classRoot;
	}

	private static <%=isinteraction?"Interaction":"Object"%>Root create_<%=isinteraction?"interaction":"object"%>( Class<?> rtiClass, LogicalTime logicalTime ) {	
		<%=isinteraction?"Interaction":"Object"%>Root classRoot = create_<%=isinteraction?"interaction":"object"%>( rtiClass );
		if ( classRoot != null ) classRoot.setTime( logicalTime );
		return classRoot;
	}

	private static <%=isinteraction?"Interaction":"Object"%>Root create_<%=isinteraction?"interaction":"object"%>( Class<?> rtiClass, <%=isinteraction?"ReceivedInteraction":"ReflectedAttributes"%> datamemberMap ) {
		<%=isinteraction?"Interaction":"Object"%>Root classRoot = create_<%=isinteraction?"interaction":"object"%>( rtiClass );
		classRoot.set<%=isinteraction?"Parameter":"Attribute"%>s( datamemberMap );
		return classRoot;
	}
	
	private static <%=isinteraction?"Interaction":"Object"%>Root create_<%=isinteraction?"interaction":"object"%>( Class<?> rtiClass, <%=isinteraction?"ReceivedInteraction":"ReflectedAttributes"%> datamemberMap, LogicalTime logicalTime ) {
		<%=isinteraction?"Interaction":"Object"%>Root classRoot = create_<%=isinteraction?"interaction":"object"%>( rtiClass );
		classRoot.set<%=isinteraction?"Parameter":"Attribute"%>s( datamemberMap );
		classRoot.setTime( logicalTime );
		return classRoot;
	}
	
	/**
	* Create an <%=isinteraction?"interaction":"object"%> that is in instance of <%=isinteraction?"interaction":"object"%> class
	* "className". An <%=isinteraction?"Interaction":"Object"%>Root reference is returned,
	* so to refer to the instance using a reference to a "className" interaction,
	* the returned reference must be cast down the <%=isinteraction?"interaction":"object"%> inheritance
	* hierarchy.
	* An instance of the "className" <%=isinteraction?"interaction":"object"%> class may also be created
	* by using the "new" operator directory on the "className" <%=isinteraction?"interaction":"object"%>
	* class.  For instance, two ways to create an <%=isinteraction?"Interaction":"Object"%>Root
	* instance are
	* <%=isinteraction?"Interaction":"Object"%>.create_<%=isinteraction?"interaction":"object"%>( "<%=isinteraction?"Interaction":"Object"%>Root" ),
	* and
	* new <%=isinteraction?"Interaction":"Object"%>Root()
	*
	* @param className fully-qualified (dot-delimited) name of the <%=isinteraction?"interaction":"object"%>
	* class for which to create an instance
	* @return instance of "className" <%=isinteraction?"interaction":"object"%> class
	*/
	public static <%=isinteraction?"Interaction":"Object"%>Root create_<%=isinteraction?"interaction":"object"%>( String className ) {
		Class<?> rtiClass = _classNameClassMap.get( className );
		if ( rtiClass == null ) return null;

		return create_<%=isinteraction?"interaction":"object"%>( rtiClass );
	}

	/**
	* Like {@link #create_<%=isinteraction?"interaction":"object"%>( String className )}, but <%=isinteraction?"interaction":"object"%>
	* is created with a timestamp based on "logicalTime".
	*
	* @param className fully-qualified (dot-delimited) name of the <%=isinteraction?"interaction":"object"%>
	* class for which to create an instance
	* @param logicalTime timestamp to place on the new <%=isinteraction?"interaction":"object"%> class instance
	* @return instance of "className" <%=isinteraction?"interaction":"object"%> class with "logicalTime" time stamp.
	*/
	public static <%=isinteraction?"Interaction":"Object"%>Root create_<%=isinteraction?"interaction":"object"%>( String className, LogicalTime logicalTime ) {
		Class<?> rtiClass = _classNameClassMap.get( className );
		if ( rtiClass == null ) return null;

		return create_<%=isinteraction?"interaction":"object"%>( rtiClass, logicalTime );
	}

	/**
	* Create an <%=isinteraction?"interaction":"object"%> that is in instance of <%=isinteraction?"interaction":"object"%> class
	* that corresponds to the "classHandle" handle (RTI assigned). An
	* <%=isinteraction?"Interaction":"Object"%>Root reference is returned, so to refer to the
	* instance using a reference to a "className" interaction, the returned
	* reference must be cast down the <%=isinteraction?"interaction":"object"%> inheritance hierarchy.
	*
	* @param classHandle handle of <%=isinteraction?"interaction":"object"%> class (RTI assigned) class for
	* which to create an instance
	* @return instance of <%=isinteraction?"interaction":"object"%> class corresponding to "classHandle"
	*/
	public static <%=isinteraction?"Interaction":"Object"%>Root create_<%=isinteraction?"interaction":"object"%>( int classHandle ) {
		Class<?> rtiClass = _classNameClassMap.get(  _classHandleNameMap.get( classHandle )  );
		if ( rtiClass == null ) return null;

		return create_<%=isinteraction?"interaction":"object"%>( rtiClass );
	}

	/**
	* Like {@link #create_<%=isinteraction?"interaction":"object"%>( int classHandle )}, but the <%=isinteraction?"interaction":"object"%>
	* is created with a timestamp based on "logicalTime".
	*
	* @param classHandle handle of <%=isinteraction?"interaction":"object"%> class (RTI assigned) class for
	* which to create an instance
	* @param logicalTime timestamp to place on the new <%=isinteraction?"interaction":"object"%> class instance
	* @return instance of <%=isinteraction?"interaction":"object"%> class corresponding to "classHandle" with
	* "logicalTime" time stamp
	*/
	public static <%=isinteraction?"Interaction":"Object"%>Root create_<%=isinteraction?"interaction":"object"%>( int classHandle, LogicalTime logicalTime ) {
		Class<?> rtiClass = _classNameClassMap.get(  _classHandleNameMap.get( classHandle )  );
		if ( rtiClass == null ) return null;

		return create_<%=isinteraction?"interaction":"object"%>( rtiClass, logicalTime );
	}

	/**
	* Like {@link #create_<%=isinteraction?"interaction":"object"%>( int classHandle )}, but the <%=isinteraction?"interaction":"object"%>'s
	* <%=isinteraction?"parameter":"attribute"%>s are initialized using "datamemberMap".  The "datamemberMap"
	* is usually acquired as an argument to an RTI callback method of a federate.
	*
	* @param classHandle handle of <%=isinteraction?"interaction":"object"%> class (RTI assigned) class for
	* which to create an instance
	* @param datamemberMap contains initializing values for the <%=isinteraction?"parameter":"attribute"%>s
	* of the <%=isinteraction?"interaction":"object"%> class instance
	* @return instance of <%=isinteraction?"interaction":"object"%> class corresponding to "classHandle" with
	* its <%=isinteraction?"parameter":"attribute"%>s initialized with the "datamemberMap"
	*/
	public static <%=isinteraction?"Interaction":"Object"%>Root create_<%=isinteraction?"interaction":"object"%>( int classHandle, <%=isinteraction?"ReceivedInteraction":"ReflectedAttributes"%> datamemberMap ) {
		Class<?> rtiClass = _classNameClassMap.get(  _classHandleNameMap.get( classHandle )  );
		if ( rtiClass == null ) return null;

		return create_<%=isinteraction?"interaction":"object"%>( rtiClass, datamemberMap );
	}

	/**
	* Like {@link #create_<%=isinteraction?"interaction":"object"%>( int classHandle, <%=isinteraction?"ReceivedInteraction":"ReflectedAttributes"%> datamemberMap )},
	* but the <%=isinteraction?"interaction":"object"%> is given a timestamp based on "logicalTime".
	*
	* @param classHandle handle of <%=isinteraction?"interaction":"object"%> class (RTI assigned) class for
	* which to create an instance
	* @param datamemberMap initializing values for the <%=isinteraction?"parameter":"attribute"%>s of the
	* <%=isinteraction?"interaction":"object"%> class instance
	* @param logicalTime timestamp to place on the new <%=isinteraction?"interaction":"object"%> class instance
	* @return instance of <%=isinteraction?"interaction":"object"%> class corresponding to "classHandle" with
	* its <%=isinteraction?"parameter":"attribute"%>s initialized with the "datamemberMap" and with
	* "logicalTime" timestamp
	*/
	public static <%=isinteraction?"Interaction":"Object"%>Root create_<%=isinteraction?"interaction":"object"%>( int classHandle, <%=isinteraction?"ReceivedInteraction":"ReflectedAttributes"%> datamemberMap, LogicalTime logicalTime ) {
		Class<?> rtiClass = _classNameClassMap.get(  _classHandleNameMap.get( classHandle )  );
		if ( rtiClass == null ) return null;

		return create_<%=isinteraction?"interaction":"object"%>( rtiClass, datamemberMap, logicalTime );
	}

<% if(isinteraction){ %><%}else{%>
	/**
	* Creates a new instance of the object class corresponding to "class_handle",
	* registers it in an map internal to the ObjectRoot class using "object_handle"
	* as a key, and returns a reference to the instance.  Though the created
	* instance is of the object class corresponding to "class_handle" (which is
	* a handle assigned by the RTI), it is referred to, via the return value, by
	* an ObjectRoot reference.  Thus, to refer to it as an instance of the object
	* class corresponding to "class_handle", the ObjectRoot reference needs to be
	* cast down through the inheritance hierarchy.
	* <p/>
	* class_handle and object_handle are usually acquired as arguments of the
	* "discoverObjectInstance" RTI callback method of a federate.
	*
	* @param class_handle handle of object class (RTI assigned) for which to create
	* an instance
	* @param object_handle handle (also RTI assigned) of this instance as it is
	* known to the RTI.  Any updates to the instance attributes provided by the
	* RTI (via a "reflectAttributeValues" federate callback) will be identified
	* with this object_handle.
	* @return new instance of the object class corresponding to class_handle
	*/
    public static ObjectRoot discover( int class_handle, int object_handle ) {
        Class<?> hlaObjectClass = _classNameClassMap.get(  _classHandleNameMap.get( class_handle )  );
        ObjectRoot objectRoot = null;
        try {
            objectRoot = (ObjectRoot)hlaObjectClass.newInstance();
            objectRoot.setObjectHandle( object_handle );
            _objectMap.put( object_handle, objectRoot );
        } catch( Exception e ) {
            System.err.println( "ERROR:  ObjectRoot:  discover:  could not discover object" );
            e.printStackTrace();
        }
        return objectRoot;
    }
    
    /**
    * Retrieves the object instance corresponding to "object_handle" from an
    * internal table in the ObjectRoot class, updates its attribute values using
    * "reflectedAttributes", and returns the instance.  Both "object_handle" and
    * "reflectedAttributes" are usually acquired as arguments of the
    * "reflectAttributeValues" RTI callback of a federate.
    * The return value is an ObjectRoot reference to the instance.  So, to refer
    * to the instance as an instance of its actual class, this reference will
    * have to be cast down the inheritance hierarchy.
    *
    * @param object_handle handle (RTI assigned) of object instance for which the
    * attributes are to be updated.
    * @param reflectedAttributes set of updated values for the attributes of the
    * object instance corresponding to object_handle.
    * @return the object instance with updated attribute values
    */
    public static ObjectRoot reflect( int object_handle, ReflectedAttributes reflectedAttributes ) {
    	ObjectRoot objectRoot = _objectMap.get( object_handle );
    	if ( objectRoot == null ) return null;
    	objectRoot.setTime( -1 );
    	objectRoot.setAttributes( reflectedAttributes );
    	return objectRoot;
    }

	/**
	* Like {@link #reflect( int object_handle, ReflectedAttributes reflectedAttributes )},
	* except the updated attributes of the object instance have their timestamps
	* updated to "logicalTime".
	*
    * @param object_handle handle (RTI assigned) of object instance for which the
    * attributes are to be updated.
    * @param reflectedAttributes set of updated values for the attributes of the
    * object instance corresponding to object_handle.
    * @param logicalTime new time stamp for attributes that are updated
    * @return the object instance with updated attribute values
    */
    public static ObjectRoot reflect( int object_handle, ReflectedAttributes reflectedAttributes, LogicalTime logicalTime ) {
    	ObjectRoot objectRoot = _objectMap.get( object_handle );
    	if ( objectRoot == null ) return null;
    	objectRoot.setTime( logicalTime );
    	objectRoot.setAttributes( reflectedAttributes );
    	return objectRoot;
    }

	/**
	* Like {@link #reflect( int object_handle, ReflectedAttributes reflectedAttributes )},
	* except the updated attributes of the object instance have their timestamps
	* updated to "time".
	*
    * @param object_handle handle (RTI assigned) of object instance for which the
    * attributes are to be updated.
    * @param reflectedAttributes set of updated values for the attributes of the
    * object instance corresponding to object_handle.
    * @param time new time stamp for attributes that are updated
    * @return the object instance with updated attribute values
    */
    public static ObjectRoot reflect( int object_handle, ReflectedAttributes reflectedAttributes, double time ) {
    	ObjectRoot objectRoot = _objectMap.get( object_handle );
    	if ( objectRoot == null ) return null;
    	objectRoot.setTime( time );
    	objectRoot.setAttributes( reflectedAttributes );
    	return objectRoot;
    }

	/**
	* Requests an attribute update for this object instance from the federate that
	* has modification rights on these attributes.
	*
	* @param rti handle to the RTI, usu. obtained through the
	* {@link SynchronizedFederate#getRTI()} call
	*/
	public void requestUpdate( RTIambassador rti ) {
		boolean requestNotSubmitted = true;
		while( requestNotSubmitted ) {
			try {		
				rti.requestObjectAttributeValueUpdate( getObjectHandle(), getSubscribedAttributeHandleSet() );
				requestNotSubmitted = false;
			} catch ( FederateNotExecutionMember f ) {
				System.err.println( "ERROR: " + getClassName() + "request for update failed:  Federate Not Execution Member" );
				f.printStackTrace();
				return;				
			} catch ( ObjectNotKnown o ) {
				System.err.println( "ERROR: " + getClassName() + "request for update failed:  Object Not Known" );
				o.printStackTrace();
				return;				
			} catch ( AttributeNotDefined a ) {
				System.err.println( "ERROR: " + getClassName() + "request for update failed:  Name Not Found" );
				a.printStackTrace();
				return;				
			} catch ( Exception e ) {
				e.printStackTrace();
				try { Thread.sleep( 50 ); } catch( Exception e1 ) { }					
			}
		}
	}

	/**
	* Returns the object instance corresponding to the "object_handle" (RTI
	* assigned) from a map internal to the ObjectRoot class.
	* The object instance is referred to, via the return value, using an
	* an ObjectRoot reference.  To reference to it using a reference of its
	* actual class, the returned reference must be cast down through the
	* inhertance hierarchy.
	*
	* @param object_handle handle (RTI assigned) of object instance to retrieve
	* from the map internal to the ObjectRoot class.
	* @return object instance corresponding to the object_handle (RTI assigned)
	* in the map that is internal to the ObjectRoot class.
	*/
	public static ObjectRoot getObject( int object_handle ) {
		return _objectMap.get( object_handle );
	}
	
	
	/**
	* Returns the object instance corresponding to the "object_handle" (RTI
	* assigned) from a map internal to the ObjectRoot class AND REMOVES IT
	* FROM THIS MAP.
	* The object instance is referred to, via the return value, using an
	* an ObjectRoot reference.  To reference to it using a reference of its
	* actual class, the returned reference must be cast down through the
	* inhertance hierarchy.
	*
	* @param object_handle handle (RTI assigned) of object instance to retrieve
	* from the map internal to the ObjectRoot class.
	* @return object instance corresponding to the object_handle (RTI assigned)
	* in the map that is internal to the ObjectRoot class.
	*/
    public static ObjectRoot removeObject( int object_handle ) {
        return _objectMap.remove( object_handle );
    }
    

    private int _object_handle;

    private void setObjectHandle( int object_handle ) {
        _objectMap.remove( object_handle );
        _object_handle = object_handle;
        _objectMap.put( object_handle, this );
    }

	/**
	* Returns the handle (RTI assigned) the corresponds to this object class
	* instance.  This handle is the instance's unique identifier to the RTI.
	*
	* @return the handle (RTI assigned) of this object class instance.
	*/
    public int getObjectHandle() { return _object_handle; }
	
<%}%>

	private double _time = -1;
	
	/**
	* Returns the timestamp for this <%=isinteraction?"interaction":"object"%>.  "receive order" <%=isinteraction?"interaction":"object"%>s
	* should have a timestamp of -1.
	*
	* @return timestamp for this <%=isinteraction?"interaction":"object"%>
	*/
	public double getTime() { return _time; }
	
	/**
	* Sets the timestamp of this <%=isinteraction?"interaction":"object"%> to "time".
	*
	* @param time new timestamp for this <%=isinteraction?"interaction":"object"%>
	*/
	public void setTime( double time ) { _time = time; }

	/**
	* Sets the timestamp of this <%=isinteraction?"interaction":"object"%> to "logicalTime".
	*
	* @param logicalTime new timestamp for this <%=isinteraction?"interaction":"object"%>
	*/
	public void setTime( LogicalTime logicalTime ) {
		DoubleTime doubleTime = new DoubleTime();
		doubleTime.setTo( logicalTime );
		setTime( doubleTime.getTime() );
	}


	/**
	* Creates a new <%=isinteraction?"Interaction":"Object"%>Root instance.
	*/
	public <%=isinteraction?"Interaction":"Object"%>Root() {
		_uniqueID = generateUniqueID();
	}
	
	/**
	* Creates a copy of an <%=isinteraction?"Interaction":"Object"%>Root instance.  As an
	* <%=isinteraction?"Interaction":"Object"%>Root instance contains no <%=isinteraction?"parameter":"attribute"%>s,
	* this has the same effect as the default constructor.
	*/
	public <%=isinteraction?"Interaction":"Object"%>Root( <%=isinteraction?"Interaction":"Object"%>Root <%=isinteraction?"interaction":"object"%>Root ) {
		this();
	}

	protected <%=isinteraction?"Interaction":"Object"%>Root( <%=isinteraction?"ReceivedInteraction":"ReflectedAttributes"%> datamemberMap, boolean initFlag ) {
		this();
		if ( initFlag ) set<%=isinteraction?"Parameter":"Attribute"%>s( datamemberMap );
	}
	
	protected <%=isinteraction?"Interaction":"Object"%>Root( <%=isinteraction?"ReceivedInteraction":"ReflectedAttributes"%> datamemberMap, LogicalTime logicalTime, boolean initFlag ) {
		this();
		setTime( logicalTime );
		if ( initFlag ) set<%=isinteraction?"Parameter":"Attribute"%>s( datamemberMap );
	}


	/**
	* Creates a new <%=isinteraction?"interaction":"object"%> instance and initializes its <%=isinteraction?"parameter":"attribute"%>s
	* using the "datamemberMap" -- this constructor is usually called as a
	* super-class constructor to create and initialize an instance of an
	* <%=isinteraction?"interaction":"object"%> further down in the inheritance hierarchy.  "datamemberMap"
	* is usually acquired as an argument to an RTI federate callback method, such
	* as "receiveInteraction".
	*
	* @param datamemberMap contains <%=isinteraction?"parameter":"attribute"%> values for the newly created
	* <%=isinteraction?"interaction":"object"%>
	*/
	public <%=isinteraction?"Interaction":"Object"%>Root( <%=isinteraction?"ReceivedInteraction":"ReflectedAttributes"%> datamemberMap ) {
		this( datamemberMap, true );
	}

	/**
	* Like {@link #<%=isinteraction?"Interaction":"Object"%>Root( <%=isinteraction?"ReceivedInteraction":"ReflectedAttributes"%> datamemberMap )},
	* except the new instance has an initial timestamp of "logicalTime".
	*
	* @param datamemberMap contains <%=isinteraction?"parameter":"attribute"%> values for the newly created
	* <%=isinteraction?"interaction":"object"%>
	* @param logicalTime initial timestamp for newly created <%=isinteraction?"interaction":"object"%> instance
	*/	
	public <%=isinteraction?"Interaction":"Object"%>Root( <%=isinteraction?"ReceivedInteraction":"ReflectedAttributes"%> datamemberMap, LogicalTime logicalTime ) {
		this( datamemberMap, logicalTime, true );
	}

	/**
	* Returns the value of the <%=isinteraction?"parameter":"attribute"%> named "datamemberName" for this
	* <%=isinteraction?"interaction":"object"%>.
	*
	* @param datamemberName name of <%=isinteraction?"parameter":"attribute"%> whose value to retrieve
	* @return the value of the <%=isinteraction?"parameter":"attribute"%> whose name is "datamemberName"
	*/
	public Object get<%=isinteraction?"Parameter":"Attribute"%>( String datamemberName ) {
		return null;
	}

	/**
	* Returns the value of the <%=isinteraction?"parameter":"attribute"%> whose handle is "datamemberHandle"
	* (RTI assigned) for this <%=isinteraction?"interaction":"object"%>.
	*
	* @param datamemberHandle handle (RTI assigned) of <%=isinteraction?"parameter":"attribute"%> whose
	* value to retrieve
	* @return the value of the <%=isinteraction?"parameter":"attribute"%> whose handle is "datamemberHandle"
	*/
	public Object get<%=isinteraction?"Parameter":"Attribute"%>( int datamemberHandle ) {
		return null;
	}
		
	/**
	* Set the values of the <%=isinteraction?"parameter":"attribute"%>s in this <%=isinteraction?"interaction":"object"%> using
	* "datamemberMap".  "datamemberMap" is usually acquired as an argument to
	* an RTI federate callback method such as "receiveInteraction".
	*
	* @param datamemberMap  contains new values for the <%=isinteraction?"parameter":"attribute"%>s of
	* this <%=isinteraction?"interaction":"object"%>
	*/
	public void set<%=isinteraction?"Parameter":"Attribute"%>s( <%=isinteraction?"ReceivedInteraction":"ReflectedAttributes"%> datamemberMap ) {
		int size = datamemberMap.size();
		for( int ix = 0 ; ix < size ; ++ix ) {
			try {
				set<%=isinteraction?"Parameter":"Attribute"%>(  datamemberMap.get<%=isinteraction?"Parameter":"Attribute"%>Handle( ix ), datamemberMap.getValue( ix )  );
			} catch ( Exception e ) {
				System.err.println( "set<%=isinteraction?"Parameter":"Attribute"%>s: Exception caught!" );
				e.printStackTrace();
			}
		}
	}

	private void set<%=isinteraction?"Parameter":"Attribute"%>( int handle, byte[] val ) {
		if ( val == null ) {
			System.err.println( "set:  Attempt to set null value in class \"" + getClass().getName() + "\"" );
		}
		if (   !set<%=isinteraction?"Parameter":"Attribute"%>Aux(  handle, new String( val )  )   ) {
			System.err.println( "set:  bad <%=isinteraction?"parameter":"attribute"%> handle in class \"" + getClass().getName() + "\"" );
		}
	}
	
	/**
	* Sets the value of the <%=isinteraction?"parameter":"attribute"%> named "datamemberName" to "value"
	* in this <%=isinteraction?"interaction":"object"%>.  "value" is converted to data type of "datamemberName"
	* if needed.
	* This action can also be affected by calling the set_<datamemberName>( value )
	* method on the <%=isinteraction?"interaction":"object"%> using a reference to the <%=isinteraction?"interaction":"object"%>'s actual
	* class.
	*
	* @param datamemberName name of <%=isinteraction?"parameter":"attribute"%> whose value is to be set
	* to "value"
	* @param value new value of <%=isinteraction?"parameter":"attribute"%> called "datamemberName"
	*/
	public void set<%=isinteraction?"Parameter":"Attribute"%>( String datamemberName, String value ) {
		if (  !set<%=isinteraction?"Parameter":"Attribute"%>Aux( datamemberName, value )  ) {
			System.err.println( "Error:  <%=isinteraction?"interaction":"object"%>Root:  invalid <%=isinteraction?"parameter":"attribute"%> \"" + datamemberName + "\"" );
		}
	}

	/**
	* Sets the value of the <%=isinteraction?"parameter":"attribute"%> named "datamemberName" to "value"
	* in this <%=isinteraction?"interaction":"object"%>.  "value" should have the same data type as that of
	* the "datamemberName" <%=isinteraction?"parameter":"attribute"%>.
	* This action can also be affected by calling the set_<datamemberName>( value )
	* method on the <%=isinteraction?"interaction":"object"%> using a reference to the <%=isinteraction?"interaction":"object"%>'s actual
	* class.
	*
	* @param datamemberName name of <%=isinteraction?"parameter":"attribute"%> whose value is to be set
	* to "value"
	* @param value new value of <%=isinteraction?"parameter":"attribute"%> called "datamemberName"
	*/
	public void set<%=isinteraction?"Parameter":"Attribute"%>( String datamemberName, Object value ) {
		if (  !set<%=isinteraction?"Parameter":"Attribute"%>Aux( datamemberName, value )  ) {
			System.err.println( "Error:  <%=isinteraction?"interaction":"object"%>Root:  invalid <%=isinteraction?"parameter":"attribute"%> \"" + datamemberName + "\"" );
		}
	}

	protected boolean set<%=isinteraction?"Parameter":"Attribute"%>Aux( int param_handle, String val ) {
		return false;
	}

	protected boolean set<%=isinteraction?"Parameter":"Attribute"%>Aux( String datamemberName, String value ) {
		return false;
	}

	protected boolean set<%=isinteraction?"Parameter":"Attribute"%>Aux( String datamemberName, Object value ) {
		return false;
	}

	protected Supplied<%=isinteraction?"Parameter":"Attribute"%>s createSuppliedDatamembers(<% if(isinteraction){ %><%}else{%>boolean force<%}%>) {
		return _factory.createSupplied<%=isinteraction?"Parameter":"Attribute"%>s();
	}
	
<% if(isinteraction){ %>
	/**
	* Sends this interaction to the RTI, with the specified timestamp "time".
	* This method should be used to send interactions that have "timestamp"
	* ordering.
	*
	* @param rti handle to the RTI, usu. obtained through the
	* {@link SynchronizedFederate#getRTI()} call
	* @param time timestamp for this interaction.  The timestamp should be no
	* less than the current federation time + the LOOKAHEAD value of the federate
	* sending this interaction.
	*/
	public void sendInteraction( RTIambassador rti, double time ) throws Exception {
		synchronized( rti ) {
			try {
				SuppliedParameters datamembers = createSuppliedDatamembers();
				rti.sendInteraction(  getClassHandle(), datamembers, null, new DoubleTime( time )  );
				createLog(datamembers,time);
			} catch ( Exception e ) {
				System.err.println( "ERROR:  " + getClass().getName() + ":  could not send interaction" );
				e.printStackTrace();
			}
		}
	}

	/**
	* Sends this interaction to the RTI (without a timestamp).
	* This method should be used to send interactions that have "receive"
	* ordering.
	*
	* @param rti handle to the RTI, usu. obtained through the
	* {@link SynchronizedFederate#getRTI()} call
	*/
	public void sendInteraction( RTIambassador rti ) throws Exception {
		synchronized( rti ) {
			try {
				SuppliedParameters datamembers = createSuppliedDatamembers();
				rti.sendInteraction( getClassHandle(), datamembers, null );
				createLog(datamembers,0);
			} catch ( Exception e ) {
				System.err.println( "ERROR:  " + getClass().getName() + ":  could not send interaction" );
				e.printStackTrace();
			}
		}
	}
	
	protected static String fedName = null;
	public static Boolean enablePubLog = false;
	public static Boolean enableSubLog = false;
	public static String pubLogLevel = null;
	public static String subLogLevel = null;
	
	public static void enablePublishLog(String interaction, String fed, String thislevel, String globallevel){
		if(globallevel == null || "".equals(globallevel)) return;
		if(C2WLogger.getLogLevel(thislevel)> C2WLogger.getLogLevel(globallevel)) return;
		fedName = fed;
		enablePubLog = true;
		pubLogLevel = thislevel;
		C2WLogger.addLog(interaction, fedName, true);
	}
	
	public static void enableSubscribeLog(String interaction, String fed, String thislevel, String globallevel){
		if(globallevel == null || "".equals(globallevel)) return;
		if(C2WLogger.getLogLevel(thislevel)> C2WLogger.getLogLevel(globallevel)) return;
		fedName = fed;
		enableSubLog = true;
		subLogLevel = thislevel;
		C2WLogger.addLog(interaction, fedName, false);
	}
	
	protected void createLog(final SuppliedParameters datamembers, final double time) {
		if(!enablePubLog) return;
        Thread t = new Thread(new Runnable() {                                                                                 // NOMELD
            public void run() {                                                                                                // NOMELD
				try {
					String interactionId = fedName != null ? fedName + "_pub_"+ getSimpleClassName() :getSimpleClassName() + "_pub";

					// First just record the interaction event as a log
					C2WLogger.addEventLog(time, interactionId);

					// Now, log detailed simulation data of the interaction
					String logIdLocal = null;
					synchronized( <%=isinteraction?"Interaction":"Object"%>Root.class ) {
						logIdLocal = Integer.toString( logId++ );
					}

					int noDatamembers = datamembers.size();
					if ( noDatamembers == 0 ) {
						C2WLogger.addLog( interactionId, time, null, null, null, pubLogLevel, logIdLocal );
					} else {
						for(int ix =0; ix < datamembers.size();ix++){
							String parameter = get_parameter_name(datamembers.getHandle( ix ) );
							String value = new String(datamembers.getValue(ix));	
							String type = new String(_datamemberTypeMap.get(parameter));
							C2WLogger.addLog( interactionId, time, parameter, value, type, pubLogLevel, logIdLocal );
						}
					}
				} catch ( Exception e ) {
					System.err.println( "ERROR:  " + getClass().getName() + ":  could not send interaction" );
					e.printStackTrace();
				}
            }
        });
        t.start();
	}

<%}else{%>
    private boolean _isRegistered = false;

	/**
	* Registers this object with the RTI.  This method is usually called by a
	* federate who "owns" this object, i.e. the federate that created it and
	* has write-privileges to its attributes (so, it is responsible for updating
	* these attribute and conveying their updated values to the RTI).
	*
	* @param rti handle to the RTI, usu. obtained through the
	* {@link SynchronizedFederate#getRTI()} call
	*/ 
    public void registerObject( RTIambassador rti ) {
        
        while( !_isRegistered ) {
            try {
                synchronized( rti ) {
                    _object_handle = rti.registerObjectInstance( getClassHandle() );
                }
                _isRegistered = true;
                _objectMap.put( getObjectHandle(), this );
                
            } catch ( ObjectClassNotDefined o ) {
                o.printStackTrace();
                return;
            } catch ( ObjectClassNotPublished o ) {
                o.printStackTrace();
                return;
            } catch ( FederateNotExecutionMember f ) {
                f.printStackTrace();
                return;
            } catch ( Exception e ) {
                try {
                    Thread.sleep( 500 );
                } catch ( InterruptedException e1 ) {
                    e1.printStackTrace();
                } 
            }
        }

    }
    
	/**
	* Unregisters this object with the RTI.  The RTI will destroy all information
	* it contains regarding this object as a result.  This method is usually
	* called by a federate who "owns" this object, i.e. the federate that created
	* it and has write-privileges to its attributes.
	*
	* @param rti handle to the RTI, usu. obtained through the
	* {@link SynchronizedFederate#getRTI()} call
	*/ 
    public void unregisterObject( RTIambassador rti ) {
        
        while( _isRegistered ) {
            try {
                synchronized( rti ) {
                    rti.deleteObjectInstance( _object_handle, null );
                }
                _isRegistered = false;
                _objectMap.remove( getObjectHandle() );
                
            } catch ( ObjectNotKnown o ) {
                o.printStackTrace();
                return;
            } catch ( DeletePrivilegeNotHeld d ) {
                d.printStackTrace();
                return;
            } catch ( FederateNotExecutionMember f ) {
                f.printStackTrace();
                return;
            } catch ( Exception e ) {
                try {
                    Thread.sleep( 500 );
                } catch ( InterruptedException e1 ) {
                    e1.printStackTrace();
                } 
            }
        }
    }

	/**
	* Broadcasts the attributes of this object and their values to the RTI, where
	* the values have "time" as their timestamp.  This call should be used for
	* objects whose attributes have "timestamp" ordering.
	*
	* @param rti handle to the RTI, usu. obtained through the
	* {@link SynchronizedFederate#getRTI()} call
	* @param time timestamp on attribute values of this object
	* @param force if "false", only the attributes whose values have changed since
	* the last call to "updateAttributeValues" will be broadcast to the RTI.  If
	* "true", all attributes and their values are broadcast to the RTI.
	*/
    public void updateAttributeValues( RTIambassador rti, double time, boolean force ) {

        SuppliedAttributes suppliedAttributes = createSuppliedDatamembers( force );
        if ( suppliedAttributes.size() == 0 ) return;

        synchronized( rti ) {
            try {
                rti.updateAttributeValues(  getObjectHandle(), suppliedAttributes, null, new DoubleTime( time )  );
                createLog(suppliedAttributes, time);
            } catch ( ObjectNotKnown o ) {
                System.err.println( "ERROR:  " + getClass().getName() + ":  could not update attributes:  Object Not Known" );
                o.printStackTrace();
                return;
            } catch ( FederateNotExecutionMember f ) {
                System.err.println( "ERROR:  " + getClass().getName() + ":  could not update attributes:  Federate Not Execution Member" );
                f.printStackTrace();
                return;
            } catch ( AttributeNotDefined a ) {
                System.err.println( "ERROR:  " + getClass().getName() + ":  could not update attributes:  Attribute Not Defined" );
                a.printStackTrace();
                return;
            } catch ( AttributeNotOwned a ) {
                System.err.println( "ERROR:  " + getClass().getName() + ":  could not update attributes:  Attribute Not Owned" );
                a.printStackTrace();
                return;
            } catch ( ConcurrentAccessAttempted c ) {
                System.err.println( "ERROR:  " + getClass().getName() + ":  could not update attributes:  Concurrent Access Attempted" );
                c.printStackTrace();
                return;
            } catch ( InvalidFederationTime i ) {
                System.err.println( "ERROR:  " + getClass().getName() + ":  could not update attributes:  Invalid Federation Time" );
                i.printStackTrace();
                return;
            } catch ( Exception e ) {
                System.err.println( "ERROR:  " + getClass().getName() + ":  could not update attributes" );
                e.printStackTrace();
            }
        }
    }

	/**
    * Like {@link #updateAttributeValues( RTIambassador rti, double time, boolean force )},
    * except "force" is always false.
	*
	* @param rti handle to the RTI, usu. obtained through the
	* {@link SynchronizedFederate#getRTI()} call
	* @param time timestamp on attribute values of this object
	*/
    public void updateAttributeValues( RTIambassador rti, double time ) {
    	updateAttributeValues( rti, time, false );
    }

	/**
	* Broadcasts the attributes of this object and their values to the RTI (with
	* no timestamp).  This call should be used for objects whose attributes have
	* "receive" ordering.
	*
	* @param rti handle to the RTI, usu. obtained through the
	* {@link SynchronizedFederate#getRTI()} call
	* @param force if "false", only the attributes whose values have changed since
	* the last call to "updateAttributeValues" will be broadcast to the RTI.  If
	* "true", all attributes and their values are broadcast to the RTI.
	*/
    public void updateAttributeValues( RTIambassador rti, boolean force ) {

        SuppliedAttributes suppliedAttributes = createSuppliedDatamembers( force );
        if ( suppliedAttributes.size() == 0 ) return;

        synchronized( rti ) {
            try {
                rti.updateAttributeValues( getObjectHandle(), suppliedAttributes, null );
                createLog(suppliedAttributes, 0);
            } catch ( ObjectNotKnown o ) {
                System.err.println( "ERROR:  " + getClass().getName() + ":  could not update attributes:  Object Not Known" );
                o.printStackTrace();
                return;
            } catch ( FederateNotExecutionMember f ) {
                System.err.println( "ERROR:  " + getClass().getName() + ":  could not update attributes:  Federate Not Execution Member" );
                f.printStackTrace();
                return;
            } catch ( AttributeNotDefined a ) {
                System.err.println( "ERROR:  " + getClass().getName() + ":  could not update attributes:  Attribute Not Defined" );
                a.printStackTrace();
                return;
            } catch ( AttributeNotOwned a ) {
                System.err.println( "ERROR:  " + getClass().getName() + ":  could not update attributes:  Attribute Not Owned" );
                a.printStackTrace();
                return;
            } catch ( ConcurrentAccessAttempted c ) {
                System.err.println( "ERROR:  " + getClass().getName() + ":  could not update attributes:  Concurrent Access Attempted" );
                c.printStackTrace();
                return;
            } catch ( Exception e ) {
                System.err.println( "ERROR:  " + getClass().getName() + ":  could not update attributes" );
                e.printStackTrace();
            }
        }
    }

	/**
    * Like {@link #updateAttributeValues( RTIambassador rti, boolean force )},
    * except "force" is always false.
	*
	* @param rti handle to the RTI, usu. obtained through the
	* {@link SynchronizedFederate#getRTI()} call
	*/
	public void updateAttributeValues( RTIambassador rti ) {
		updateAttributeValues( rti, false );
	}

	protected static String _fedName = null;
	protected static Map< String, String > _pubAttributeLogMap = new HashMap< String, String >();
	protected static Map< String, String > _subAttributeLogMap = new HashMap< String, String >();
	
	public static void enablePublishLog(String object, String attribute, String fed, String thislevel, String globallevel){
		if(globallevel == null || "".equals(globallevel)) return;
		if(C2WLogger.getLogLevel(thislevel)> C2WLogger.getLogLevel(globallevel)) return;
		_fedName = fed;
		_pubAttributeLogMap.put(attribute, thislevel);
		C2WLogger.addLog(object, attribute, fed, true);
	}
	
	public static void enableSubscribeLog(String object, String attribute, String fed, String thislevel, String globallevel){
		if(globallevel == null || "".equals(globallevel)) return;
		if(C2WLogger.getLogLevel(thislevel)> C2WLogger.getLogLevel(globallevel)) return;
		_fedName = fed;
		_subAttributeLogMap.put(attribute, thislevel);
		C2WLogger.addLog(object, attribute, fed, true);
	}
	
	protected void createLog(final SuppliedAttributes suppliedAttributes, final double time) {
		if(_pubAttributeLogMap.isEmpty()) return;
        Thread t = new Thread(new Runnable() {                                                       // NOMELD
            public void run() {                                                                      // NOMELD
				try {
					String eventName = _fedName+"_pub_"+getSimpleClassName();

					// First just record the interaction event as a log
					C2WLogger.addEventLog(time, eventName);

					// Now, log detailed simulation data of the object update
					String logIdLocal = null;
					synchronized( <%=isinteraction?"Interaction":"Object"%>Root.class ) {
						logIdLocal = Integer.toString( logId++ );
					}
					for(int ix =0; ix < suppliedAttributes.size();ix++){							
						String attribute = get_attribute_name(suppliedAttributes.getHandle( ix ) );			
						if(!_pubAttributeLogMap.containsKey(attribute)) continue;
						String id = _fedName+"_pub_"+getSimpleClassName()+"_"+attribute;
						String value = new String(suppliedAttributes.getValue(ix));	
						String type = new String(_datamemberTypeMap.get(attribute));
						String loglevel = _pubAttributeLogMap.get(attribute);
						C2WLogger.addLog( id, time, attribute, value, type, loglevel, logIdLocal );				
					}
				} catch ( Exception e ) {
					System.err.println( "ERROR:  " + getClass().getName() + ":  could not send interaction" );
					e.printStackTrace();
				}
            }
        });
        t.start();
	}
	
<%}%>

	/**
	* For use with the melding API -- this method is used to cast
	* <%=isinteraction?"Interaction":"Object"%>Root instance reference into the
	* <%=isinteraction?"Interaction":"Object"%>RootInterface interface.
	*
	* @param rootInstance <%=isinteraction?"Interaction":"Object"%>Root instance reference to be
	* cast into the <%=isinteraction?"Interaction":"Object"%>RootInterface interface
	* @return <%=isinteraction?"Interaction":"Object"%>RootInterface reference to the instance
	*/
	public <%=isinteraction?"Interaction":"Object"%>RootInterface cast( <%=isinteraction?"Interaction":"Object"%>Root rootInstance ) {
		return rootInstance;
	}		

	/**
	* For use with the melding API -- this method creates a new
	* <%=isinteraction?"Interaction":"Object"%>Root instance and returns a
	* <%=isinteraction?"Interaction":"Object"%>RootInterface reference to it.
	*
	* @return <%=isinteraction?"Interaction":"Object"%>RootInterface reference to a newly created
	* <%=isinteraction?"Interaction":"Object"%>Root instance
	*/
	public <%=isinteraction?"Interaction":"Object"%>RootInterface create() {
		return new <%=isinteraction?"Interaction":"Object"%>Root();
	}		

	public void copyFrom( Object object ) { }
}
